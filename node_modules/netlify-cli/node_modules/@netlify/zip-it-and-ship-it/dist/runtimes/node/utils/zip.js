import { Buffer } from 'buffer';
import { promises as fs } from 'fs';
import os from 'os';
import { basename, join } from 'path';
import { copyFile } from 'cp-file';
import { deleteAsync as deleteFiles } from 'del';
import pMap from 'p-map';
import { startZip, addZipFile, addZipContent, endZip } from '../../../archive.js';
import { cachedLstat, mkdirAndWriteFile } from '../../../utils/fs.js';
import { conflictsWithEntryFile, getEntryFile, isNamedLikeEntryFile } from './entry_file.js';
import { normalizeFilePath } from './normalize_path.js';
// Taken from https://www.npmjs.com/package/cpy.
const COPY_FILE_CONCURRENCY = os.cpus().length === 0 ? 2 : os.cpus().length * 2;
// Sub-directory to place all user-defined files  (i.e. everything other than
// the entry file generated by zip-it-and-ship-it).
const DEFAULT_USER_SUBDIRECTORY = 'src';
const createDirectory = async function ({ aliases = new Map(), basePath, destFolder, extension, featureFlags, filename, mainFile, moduleFormat, rewrites = new Map(), srcFiles, }) {
    const { contents: entryContents, filename: entryFilename } = getEntryFile({
        commonPrefix: basePath,
        featureFlags,
        filename,
        mainFile,
        moduleFormat,
        userNamespace: DEFAULT_USER_SUBDIRECTORY,
    });
    const functionFolder = join(destFolder, basename(filename, extension));
    // Deleting the functions directory in case it exists before creating it.
    await deleteFiles(functionFolder, { force: true });
    await fs.mkdir(functionFolder, { recursive: true });
    // Writing entry file.
    await fs.writeFile(join(functionFolder, entryFilename), entryContents);
    // Copying source files.
    await pMap(srcFiles, (srcFile) => {
        const destPath = aliases.get(srcFile) || srcFile;
        const normalizedDestPath = normalizeFilePath({
            commonPrefix: basePath,
            path: destPath,
            userNamespace: DEFAULT_USER_SUBDIRECTORY,
        });
        const absoluteDestPath = join(functionFolder, normalizedDestPath);
        if (rewrites.has(srcFile)) {
            return mkdirAndWriteFile(absoluteDestPath, rewrites.get(srcFile));
        }
        return copyFile(srcFile, absoluteDestPath);
    }, { concurrency: COPY_FILE_CONCURRENCY });
    return functionFolder;
};
const createZipArchive = async function ({ aliases, basePath, cache, destFolder, extension, featureFlags, filename, mainFile, moduleFormat, rewrites, srcFiles, }) {
    const destPath = join(destFolder, `${basename(filename, extension)}.zip`);
    const { archive, output } = startZip(destPath);
    // There is a naming conflict with the entry file if one of the supporting
    // files (i.e. not the main file) has the path that the entry file needs to
    // take.
    const hasEntryFileConflict = conflictsWithEntryFile(srcFiles, {
        basePath,
        filename,
        mainFile,
    });
    // We don't need an entry file if it would end up with the same path as the
    // function's main file. Unless we have a file conflict and need to move everything into a subfolder
    const needsEntryFile = hasEntryFileConflict || !isNamedLikeEntryFile(mainFile, { basePath, filename });
    // If there is a naming conflict, we move all user files (everything other
    // than the entry file) to its own sub-directory.
    const userNamespace = hasEntryFileConflict ? DEFAULT_USER_SUBDIRECTORY : '';
    if (needsEntryFile) {
        const entryFile = getEntryFile({
            commonPrefix: basePath,
            filename,
            mainFile,
            moduleFormat,
            userNamespace,
            featureFlags,
        });
        addEntryFileToZip(archive, entryFile);
    }
    const srcFilesInfos = await Promise.all(srcFiles.map((file) => addStat(cache, file)));
    // We ensure this is not async, so that the archive's checksum is
    // deterministic. Otherwise it depends on the order the files were added.
    srcFilesInfos.forEach(({ srcFile, stat }) => {
        zipJsFile({
            aliases,
            archive,
            commonPrefix: basePath,
            rewrites,
            srcFile,
            stat,
            userNamespace,
        });
    });
    await endZip(archive, output);
    return destPath;
};
export const zipNodeJs = function ({ archiveFormat, ...options }) {
    if (archiveFormat === 'zip') {
        return createZipArchive(options);
    }
    return createDirectory(options);
};
const addEntryFileToZip = function (archive, { contents, filename }) {
    const contentBuffer = Buffer.from(contents);
    addZipContent(archive, contentBuffer, filename);
};
const addStat = async function (cache, srcFile) {
    const stat = await cachedLstat(cache.lstatCache, srcFile);
    return { srcFile, stat };
};
const zipJsFile = function ({ aliases = new Map(), archive, commonPrefix, rewrites = new Map(), stat, srcFile, userNamespace, }) {
    const destPath = aliases.get(srcFile) || srcFile;
    const normalizedDestPath = normalizeFilePath({ commonPrefix, path: destPath, userNamespace });
    if (rewrites.has(srcFile)) {
        addZipContent(archive, rewrites.get(srcFile), normalizedDestPath);
    }
    else {
        addZipFile(archive, srcFile, normalizedDestPath, stat);
    }
};
//# sourceMappingURL=zip.js.map