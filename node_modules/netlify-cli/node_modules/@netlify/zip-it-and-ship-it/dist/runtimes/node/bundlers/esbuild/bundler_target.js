import { DEFAULT_NODE_VERSION, getNodeSupportMatrix, } from '../../utils/node_version.js';
import { getClosestPackageJson } from '../../utils/package_json.js';
const versionMap = {
    '8.x': 'node8',
    '10.x': 'node10',
    '12.x': 'node12',
    '14.x': 'node14',
    '16.x': 'node16',
    '18.x': 'node18',
};
const getBundlerTarget = (suppliedVersion) => {
    const version = normalizeVersion(suppliedVersion);
    if (version && version in versionMap) {
        return versionMap[version];
    }
    return versionMap[`${DEFAULT_NODE_VERSION}.x`];
};
const getModuleFormat = async (srcDir, featureFlags, extension, configVersion) => {
    if (extension === ".mjs" /* ModuleFileExtension.MJS */ && featureFlags.zisi_pure_esm_mjs) {
        return {
            includedFiles: [],
            moduleFormat: "esm" /* ModuleFormat.ESM */,
        };
    }
    const packageJsonFile = await getClosestPackageJson(srcDir);
    const nodeSupport = getNodeSupportMatrix(configVersion);
    if (featureFlags.zisi_pure_esm && packageJsonFile?.contents.type === 'module' && nodeSupport.esm) {
        return {
            includedFiles: [packageJsonFile.path],
            moduleFormat: "esm" /* ModuleFormat.ESM */,
        };
    }
    return {
        includedFiles: [],
        moduleFormat: "cjs" /* ModuleFormat.COMMONJS */,
    };
};
const normalizeVersion = (version) => {
    const match = version && version.match(/^nodejs(.*)$/);
    return match ? match[1] : version;
};
export { getBundlerTarget, getModuleFormat };
//# sourceMappingURL=bundler_target.js.map