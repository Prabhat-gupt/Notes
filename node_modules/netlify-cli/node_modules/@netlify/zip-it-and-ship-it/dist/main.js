import { extname } from 'path';
import { getFlags } from './feature_flags.js';
import { getFunctionFromPath, getFunctionsFromPaths } from './runtimes/index.js';
import { findISCDeclarationsInPath } from './runtimes/node/in_source_config/index.js';
import { RuntimeCache } from './utils/cache.js';
import { listFunctionsDirectories, resolveFunctionsDirectories } from './utils/fs.js';
export { zipFunction, zipFunctions } from './zip.js';
const augmentWithISC = async (func) => {
    // ISC is currently only supported in JavaScript and TypeScript functions
    // and only supports scheduled functions.
    if (func.runtime.name !== "js" /* RuntimeType.JAVASCRIPT */) {
        return func;
    }
    const inSourceConfig = await findISCDeclarationsInPath(func.mainFile, func.name);
    return { ...func, inSourceConfig };
};
// List all Netlify Functions main entry files for a specific directory
export const listFunctions = async function (relativeSrcFolders, { featureFlags: inputFeatureFlags, config, configFileDirectories, parseISC = false, } = {}) {
    const featureFlags = getFlags(inputFeatureFlags);
    const srcFolders = resolveFunctionsDirectories(relativeSrcFolders);
    const paths = await listFunctionsDirectories(srcFolders);
    const cache = new RuntimeCache();
    const functionsMap = await getFunctionsFromPaths(paths, { cache, config, configFileDirectories, featureFlags });
    const functions = [...functionsMap.values()];
    const augmentedFunctions = parseISC ? await Promise.all(functions.map(augmentWithISC)) : functions;
    return augmentedFunctions.map(getListedFunction);
};
// Finds a function at a specific path.
export const listFunction = async function (path, { featureFlags: inputFeatureFlags, config, configFileDirectories, parseISC = false, } = {}) {
    const featureFlags = getFlags(inputFeatureFlags);
    const cache = new RuntimeCache();
    const func = await getFunctionFromPath(path, { cache, config, configFileDirectories, featureFlags });
    if (!func) {
        return;
    }
    const augmentedFunction = parseISC ? await augmentWithISC(func) : func;
    return getListedFunction(augmentedFunction);
};
// List all Netlify Functions files for a specific directory
export const listFunctionsFiles = async function (relativeSrcFolders, { basePath, config, configFileDirectories, featureFlags: inputFeatureFlags, parseISC = false, } = {}) {
    const featureFlags = getFlags(inputFeatureFlags);
    const srcFolders = resolveFunctionsDirectories(relativeSrcFolders);
    const paths = await listFunctionsDirectories(srcFolders);
    const cache = new RuntimeCache();
    const functionsMap = await getFunctionsFromPaths(paths, { cache, config, configFileDirectories, featureFlags });
    const functions = [...functionsMap.values()];
    const augmentedFunctions = parseISC ? await Promise.all(functions.map(augmentWithISC)) : functions;
    const listedFunctionsFiles = await Promise.all(augmentedFunctions.map((func) => getListedFunctionFiles(func, { basePath, featureFlags })));
    return listedFunctionsFiles.flat();
};
const getListedFunction = function ({ runtime, name, mainFile, extension, config, inSourceConfig, }) {
    return {
        name,
        displayName: config.name,
        mainFile,
        runtime: runtime.name,
        extension,
        schedule: inSourceConfig?.schedule ?? config.schedule,
    };
};
const getListedFunctionFiles = async function (func, options) {
    const srcFiles = await getSrcFiles({ ...func, ...options });
    return srcFiles.map((srcFile) => ({ ...getListedFunction(func), srcFile, extension: extname(srcFile) }));
};
const getSrcFiles = async function ({ extension, runtime, srcPath, ...args }) {
    const { getSrcFiles: getRuntimeSrcFiles } = runtime;
    if (extension === '.zip' || typeof getRuntimeSrcFiles !== 'function') {
        return [srcPath];
    }
    return await getRuntimeSrcFiles({
        extension,
        runtime,
        srcPath,
        ...args,
    });
};
//# sourceMappingURL=main.js.map