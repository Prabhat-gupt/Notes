import type { FeatureFlags } from './feature_flags.js';
import { FunctionSource } from './function.js';
import type { NodeBundlerType } from './runtimes/node/bundlers/types.js';
import type { NodeVersionString } from './runtimes/node/index.js';
import type { ModuleFormat } from './runtimes/node/utils/module_format.js';
interface FunctionConfig {
    externalNodeModules?: string[];
    includedFiles?: string[];
    includedFilesBasePath?: string;
    ignoredNodeModules?: string[];
    nodeBundler?: NodeBundlerType;
    nodeSourcemap?: boolean;
    nodeVersion?: NodeVersionString;
    processDynamicNodeImports?: boolean;
    rustTargetDirectory?: string;
    schedule?: string;
    zipGo?: boolean;
    name?: string;
    nodeModuleFormat?: ModuleFormat;
}
type GlobPattern = string;
type Config = Record<GlobPattern, FunctionConfig>;
type FunctionWithoutConfig = Omit<FunctionSource, 'config'>;
declare const getConfigForFunction: ({ config, configFileDirectories, func, featureFlags, }: {
    config?: Config | undefined;
    configFileDirectories?: string[] | undefined;
    func: FunctionWithoutConfig;
    featureFlags: FeatureFlags;
}) => Promise<FunctionConfig>;
export { Config, FunctionConfig, FunctionWithoutConfig, getConfigForFunction };
