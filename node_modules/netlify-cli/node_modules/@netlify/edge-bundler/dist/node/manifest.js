import { promises as fs } from 'fs';
import { join } from 'path';
import globToRegExp from 'glob-to-regexp';
import { getPackageVersion } from './package_json.js';
import { nonNullable } from './utils/non_nullable.js';
const serializePattern = (regex) => regex.source.replace(/\\\//g, '/');
const sanitizeEdgeFunctionConfig = (config) => {
    const newConfig = {};
    for (const [name, functionConfig] of Object.entries(config)) {
        if (functionConfig.excluded_patterns.length !== 0) {
            newConfig[name] = functionConfig;
        }
    }
    return newConfig;
};
const generateManifest = ({ bundles = [], declarations = [], functions, functionConfig = {}, importMap, layers = [], }) => {
    const preCacheRoutes = [];
    const postCacheRoutes = [];
    const manifestFunctionConfig = Object.fromEntries(functions.map(({ name }) => [name, { excluded_patterns: [] }]));
    for (const [name, { excludedPath }] of Object.entries(functionConfig)) {
        if (excludedPath) {
            const paths = Array.isArray(excludedPath) ? excludedPath : [excludedPath];
            const excludedPatterns = paths.map(pathToRegularExpression).map(serializePattern);
            manifestFunctionConfig[name].excluded_patterns.push(...excludedPatterns);
        }
    }
    declarations.forEach((declaration) => {
        const func = functions.find(({ name }) => declaration.function === name);
        if (func === undefined) {
            return;
        }
        const pattern = getRegularExpression(declaration);
        const route = {
            function: func.name,
            name: declaration.name,
            pattern: serializePattern(pattern),
        };
        const excludedPattern = getExcludedRegularExpression(declaration);
        if (excludedPattern) {
            manifestFunctionConfig[func.name].excluded_patterns.push(serializePattern(excludedPattern));
        }
        if (declaration.cache === "manual" /* Cache.Manual */) {
            postCacheRoutes.push(route);
        }
        else {
            preCacheRoutes.push(route);
        }
    });
    const manifestBundles = bundles.map(({ extension, format, hash }) => ({
        asset: hash + extension,
        format,
    }));
    const manifest = {
        bundles: manifestBundles,
        routes: preCacheRoutes.filter(nonNullable),
        post_cache_routes: postCacheRoutes.filter(nonNullable),
        bundler_version: getPackageVersion(),
        layers,
        import_map: importMap,
        function_config: sanitizeEdgeFunctionConfig(manifestFunctionConfig),
    };
    return manifest;
};
const pathToRegularExpression = (path) => {
    // We use the global flag so that `globToRegExp` will not wrap the expression
    // with `^` and `$`. We'll do that ourselves.
    const regularExpression = globToRegExp(path, { flags: 'g' });
    // Wrapping the expression source with `^` and `$`. Also, adding an optional
    // trailing slash, so that a declaration of `path: "/foo"` matches requests
    // for both `/foo` and `/foo/`.
    const normalizedSource = `^${regularExpression.source}\\/?$`;
    return new RegExp(normalizedSource);
};
const getRegularExpression = (declaration) => {
    if ('pattern' in declaration) {
        return new RegExp(declaration.pattern);
    }
    return pathToRegularExpression(declaration.path);
};
const getExcludedRegularExpression = (declaration) => {
    if ('pattern' in declaration && declaration.excludedPattern) {
        return new RegExp(declaration.excludedPattern);
    }
    if ('path' in declaration && declaration.excludedPath) {
        return pathToRegularExpression(declaration.excludedPath);
    }
};
const writeManifest = async ({ distDirectory, ...rest }) => {
    const manifest = generateManifest(rest);
    const manifestPath = join(distDirectory, 'manifest.json');
    await fs.writeFile(manifestPath, JSON.stringify(manifest));
    return manifest;
};
export { generateManifest, writeManifest };
