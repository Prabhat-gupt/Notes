"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorCode = void 0;
exports.addGravatarSupport = addGravatarSupport;
exports.addScope = addScope;
Object.defineProperty(exports, "buildToken", {
  enumerable: true,
  get: function () {
    return _utils.buildToken;
  }
});
exports.convertPayloadToBase64 = convertPayloadToBase64;
exports.deleteProperties = deleteProperties;
exports.encodeScopedUri = encodeScopedUri;
exports.fileExists = fileExists;
exports.folderExists = folderExists;
exports.formatAuthor = formatAuthor;
exports.getUserAgent = getUserAgent;
exports.getVersion = getVersion;
exports.getVersionFromTarball = getVersionFromTarball;
exports.getWebProtocol = getWebProtocol;
exports.hasDiffOneKey = hasDiffOneKey;
exports.hasLogin = hasLogin;
exports.isHTTPProtocol = isHTTPProtocol;
exports.isHost = isHost;
exports.isObject = void 0;
exports.isObjectOrArray = isObjectOrArray;
exports.isRelatedToDeprecation = isRelatedToDeprecation;
exports.isVersionValid = isVersionValid;
exports.mask = mask;
exports.normalizeDistTags = normalizeDistTags;
exports.pad = pad;
exports.parseAddress = parseAddress;
exports.parseConfigFile = parseConfigFile;
exports.parseInterval = parseInterval;
exports.parseReadme = parseReadme;
exports.semverSort = semverSort;
exports.sortByName = sortByName;
exports.tagVersion = tagVersion;
exports.validateURL = validateURL;
var _assert = _interopRequireDefault(require("assert"));
var _debug = _interopRequireDefault(require("debug"));
var _fs = _interopRequireDefault(require("fs"));
var _jsYaml = _interopRequireDefault(require("js-yaml"));
var _lodash = _interopRequireDefault(require("lodash"));
var _semver = _interopRequireDefault(require("semver"));
var _url = require("url");
var _validator = _interopRequireDefault(require("validator"));
var _core = require("@verdaccio/core");
var _utils = require("@verdaccio/utils");
var _constants = require("./constants");
var _logger = require("./logger");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const {
  getBadData,
  getBadRequest,
  getCode,
  getConflict,
  getForbidden,
  getInternalError,
  getNotFound,
  getServiceUnavailable,
  getUnauthorized
} = _core.errorUtils;
const debug = (0, _debug.default)('verdaccio');

// eslint-disable-next-line @typescript-eslint/no-unused-vars
// eslint-disable-next-line @typescript-eslint/no-var-requires
require('pkginfo')(module);
const pkgVersion = module.exports.version;
const pkgName = module.exports.name;
const validProtocols = ['https', 'http'];
function getUserAgent(customUserAgent) {
  (0, _assert.default)(_lodash.default.isString(pkgName));
  (0, _assert.default)(_lodash.default.isString(pkgVersion));
  if (customUserAgent === true) {
    return `${pkgName}/${pkgVersion}`;
  } else if (_lodash.default.isString(customUserAgent) && _lodash.default.isEmpty(customUserAgent) === false) {
    return customUserAgent;
  } else if (customUserAgent === false) {
    return '';
  }
  return `${pkgName}/${pkgVersion}`;
}
function convertPayloadToBase64(payload) {
  return Buffer.from(payload, 'base64');
}

/**
 * Check whether an element is an Object
 * @param {*} obj the element
 * @return {Boolean}
 */
const isObject = _core.validatioUtils.isObject;

/**
 * @deprecated not used un v6
 */
exports.isObject = isObject;
function isObjectOrArray(obj) {
  return _lodash.default.isObject(obj) && _lodash.default.isNull(obj) === false;
}
function tagVersion(data, version, tag) {
  if (tag && data[_constants.DIST_TAGS][tag] !== version && _semver.default.parse(version, true)) {
    // valid version - store
    data[_constants.DIST_TAGS][tag] = version;
    return true;
  }
  return false;
}

/**
 * Gets version from a package object taking into account semver weirdness.
 * @return {String} return the semantic version of a package
 */
function getVersion(pkg, version) {
  // this condition must allow cast
  if (_lodash.default.isNil(pkg.versions[version]) === false) {
    return pkg.versions[version];
  }
  try {
    version = _semver.default.parse(version, true);
    for (const versionItem in pkg.versions) {
      if (version.compare(_semver.default.parse(versionItem, true)) === 0) {
        return pkg.versions[versionItem];
      }
    }
  } catch (err) {
    return undefined;
  }
}

/**
 * Parse an internet address
 * Allow:
 - https:localhost:1234        - protocol + host + port
 - localhost:1234              - host + port
 - 1234                        - port
 - http::1234                  - protocol + port
 - https://localhost:443/      - full url + https
 - http://[::1]:443/           - ipv6
 - unix:/tmp/http.sock         - unix sockets
 - https://unix:/tmp/http.sock - unix sockets (https)
 * @param {*} urlAddress the internet address definition
 * @return {Object|Null} literal object that represent the address parsed
 */
function parseAddress(urlAddress) {
  //
  // TODO: refactor it to something more reasonable?
  //
  //        protocol :  //      (  host  )|(    ipv6     ):  port  /
  let urlPattern = /^((https?):(\/\/)?)?((([^\/:]*)|\[([^\[\]]+)\]):)?(\d+)\/?$/.exec(urlAddress);
  if (urlPattern) {
    return {
      proto: urlPattern[2] || _constants.DEFAULT_PROTOCOL,
      host: urlPattern[6] || urlPattern[7] || _constants.DEFAULT_DOMAIN,
      port: urlPattern[8] || _constants.DEFAULT_PORT
    };
  }
  urlPattern = /^((https?):(\/\/)?)?unix:(.*)$/.exec(urlAddress);
  if (urlPattern) {
    return {
      proto: urlPattern[2] || _constants.DEFAULT_PROTOCOL,
      path: urlPattern[4]
    };
  }
  return null;
}

/**
 * Function filters out bad semver versions and sorts the array.
 * @return {Array} sorted Array
 */
function semverSort(listVersions) {
  return listVersions.filter(function (x) {
    if (!_semver.default.parse(x, true)) {
      _logger.logger.warn({
        ver: x
      }, 'ignoring bad version @{ver}');
      return false;
    }
    return true;
  })
  // FIXME: it seems the @types/semver do not handle a legitimate method named 'compareLoose'
  // @ts-ignore
  .sort(_semver.default.compareLoose).map(String);
}

/**
 * Flatten arrays of tags.
 * @param {*} data
 */
function normalizeDistTags(pkg) {
  let sorted;
  if (!pkg[_constants.DIST_TAGS].latest) {
    // overwrite latest with highest known version based on semver sort
    sorted = semverSort(Object.keys(pkg.versions));
    if (sorted && sorted.length) {
      pkg[_constants.DIST_TAGS].latest = sorted.pop();
    }
  }
  for (const tag in pkg[_constants.DIST_TAGS]) {
    if (_lodash.default.isArray(pkg[_constants.DIST_TAGS][tag])) {
      if (pkg[_constants.DIST_TAGS][tag].length) {
        // sort array
        // FIXME: this is clearly wrong, we need to research why this is like this.
        // @ts-ignore
        sorted = semverSort(pkg[_constants.DIST_TAGS][tag]);
        if (sorted.length) {
          // use highest version based on semver sort
          pkg[_constants.DIST_TAGS][tag] = sorted.pop();
        }
      } else {
        delete pkg[_constants.DIST_TAGS][tag];
      }
    } else if (_lodash.default.isString(pkg[_constants.DIST_TAGS][tag])) {
      if (!_semver.default.parse(pkg[_constants.DIST_TAGS][tag], true)) {
        // if the version is invalid, delete the dist-tag entry
        delete pkg[_constants.DIST_TAGS][tag];
      }
    }
  }
}
const parseIntervalTable = {
  '': 1000,
  ms: 1,
  s: 1000,
  m: 60 * 1000,
  h: 60 * 60 * 1000,
  d: 86400000,
  w: 7 * 86400000,
  M: 30 * 86400000,
  y: 365 * 86400000
};

/**
 * Parse an internal string to number
 * @param {*} interval
 * @return {Number}
 */
function parseInterval(interval) {
  if (typeof interval === 'number') {
    return interval * 1000;
  }
  let result = 0;
  let last_suffix = Infinity;
  interval.split(/\s+/).forEach(function (x) {
    if (!x) {
      return;
    }
    const m = x.match(/^((0|[1-9][0-9]*)(\.[0-9]+)?)(ms|s|m|h|d|w|M|y|)$/);
    if (!m || parseIntervalTable[m[4]] >= last_suffix || m[4] === '' && last_suffix !== Infinity) {
      throw Error('invalid interval: ' + interval);
    }
    last_suffix = parseIntervalTable[m[4]];
    result += Number(m[1]) * parseIntervalTable[m[4]];
  });
  return result;
}

/**
 * Detect running protocol (http or https)
 */
function getWebProtocol(headerProtocol, protocol) {
  let returnProtocol;
  const [, defaultProtocol] = validProtocols;
  // HAProxy variant might return http,http with X-Forwarded-Proto
  if (typeof headerProtocol === 'string' && headerProtocol !== '') {
    debug('header protocol: %o', protocol);
    const commaIndex = headerProtocol.indexOf(',');
    returnProtocol = commaIndex > 0 ? headerProtocol.substr(0, commaIndex) : headerProtocol;
  } else {
    debug('req protocol: %o', headerProtocol);
    returnProtocol = protocol;
  }
  return validProtocols.includes(returnProtocol) ? returnProtocol : defaultProtocol;
}
const ErrorCode = {
  getConflict,
  getBadData,
  getBadRequest,
  getInternalError,
  getUnauthorized,
  getForbidden,
  getServiceUnavailable,
  getNotFound,
  getCode
};
exports.ErrorCode = ErrorCode;
function parseConfigFile(configPath) {
  try {
    if (/\.ya?ml$/i.test(configPath)) {
      return _jsYaml.default.load(_fs.default.readFileSync(configPath, 'utf-8'));
    }
    debug('yaml parsed');
    return require(configPath);
  } catch (e) {
    debug('yaml parse failed');
    if (e.code !== 'MODULE_NOT_FOUND') {
      e.message = _constants.APP_ERROR.CONFIG_NOT_VALID;
    }
    throw new Error(e);
  }
}

/**
 * Check whether the path already exist.
 * @param {String} path
 * @return {Boolean}
 */
function folderExists(path) {
  try {
    const stat = _fs.default.statSync(path);
    return stat.isDirectory();
  } catch (_) {
    return false;
  }
}

/**
 * Check whether the file already exist.
 * @param {String} path
 * @return {Boolean}
 */
function fileExists(path) {
  try {
    const stat = _fs.default.statSync(path);
    return stat.isFile();
  } catch (_) {
    return false;
  }
}
function sortByName(packages, orderAscending = true) {
  return packages.slice().sort(function (a, b) {
    const comparatorNames = a.name.toLowerCase() < b.name.toLowerCase();
    return orderAscending ? comparatorNames ? -1 : 1 : comparatorNames ? 1 : -1;
  });
}
function addScope(scope, packageName) {
  return `@${scope}/${packageName}`;
}
function deleteProperties(propertiesToDelete, objectItem) {
  _lodash.default.forEach(propertiesToDelete, property => {
    delete objectItem[property];
  });
  return objectItem;
}
function addGravatarSupport(pkgInfo, online = true) {
  const pkgInfoCopy = _objectSpread({}, pkgInfo);
  const author = _lodash.default.get(pkgInfo, 'latest.author', null);
  const contributors = (0, _utils.normalizeContributors)(_lodash.default.get(pkgInfo, 'latest.contributors', []));
  const maintainers = _lodash.default.get(pkgInfo, 'latest.maintainers', []);

  // for author.
  if (author && _lodash.default.isObject(author)) {
    const {
      email
    } = author;
    pkgInfoCopy.latest.author.avatar = (0, _utils.generateGravatarUrl)(email, online);
  }
  if (author && _lodash.default.isString(author)) {
    pkgInfoCopy.latest.author = {
      avatar: _utils.GENERIC_AVATAR,
      email: '',
      author
    };
  }

  // for contributors
  if (_lodash.default.isEmpty(contributors) === false) {
    pkgInfoCopy.latest.contributors = contributors.map(contributor => {
      if (isObject(contributor)) {
        contributor.avatar = (0, _utils.generateGravatarUrl)(contributor.email, online);
      } else if (_lodash.default.isString(contributor)) {
        contributor = {
          avatar: _utils.GENERIC_AVATAR,
          email: contributor,
          name: contributor
        };
      }
      return contributor;
    });
  }

  // for maintainers
  if (_lodash.default.isEmpty(maintainers) === false) {
    pkgInfoCopy.latest.maintainers = maintainers.map(maintainer => {
      maintainer.avatar = (0, _utils.generateGravatarUrl)(maintainer.email, online);
      return maintainer;
    });
  }
  return pkgInfoCopy;
}

/**
 * parse package readme - markdown/ascii
 * @param {String} packageName name of package
 * @param {String} readme package readme

 * @return {String} converted html template
 */
function parseReadme(packageName, readme) {
  if (_lodash.default.isEmpty(readme) === false) {
    return readme;
  }

  // logs readme not found error
  _logger.logger.info({
    packageName
  }, '@{packageName}: No readme found');
  return 'ERROR: No README data found!';
}

/**
 * return package version from tarball name
 * @param {String} name
 * @returns {String}
 */
function getVersionFromTarball(name) {
  // FIXME: we know the regex is valid, but we should improve this part as ts suggest
  // @ts-ignore
  return /.+-(\d.+)\.tgz/.test(name) ? name.match(/.+-(\d.+)\.tgz/)[1] : undefined;
}
/**
 * Formats author field for webui.
 * @see https://docs.npmjs.com/files/package.json#author
 * @param {string|object|undefined} author
 */
function formatAuthor(author) {
  let authorDetails = {
    name: _constants.DEFAULT_USER,
    email: '',
    url: ''
  };
  if (_lodash.default.isNil(author)) {
    return authorDetails;
  }
  if (_lodash.default.isString(author)) {
    authorDetails = _objectSpread(_objectSpread({}, authorDetails), {}, {
      name: author
    });
  }
  if (_lodash.default.isObject(author)) {
    authorDetails = _objectSpread(_objectSpread({}, authorDetails), author);
  }
  return authorDetails;
}

/**
 * Check if URI is starting with "http://", "https://" or "//"
 * @param {string} uri
 */
function isHTTPProtocol(uri) {
  return /^(https?:)?\/\//.test(uri);
}

/**
 * Apply whitespaces based on the length
 * @param {*} str the log message
 * @return {String}
 */
function pad(str, max) {
  if (str.length < max) {
    return str + ' '.repeat(max - str.length);
  }
  return str;
}

/**
 * return a masquerade string with its first and last {charNum} and three dots in between.
 * @param {String} str
 * @param {Number} charNum
 * @returns {String}
 */
function mask(str, charNum = 3) {
  return `${str.substr(0, charNum)}...${str.substr(-charNum)}`;
}
function encodeScopedUri(packageName) {
  return packageName.replace(/\//g, '%2f');
}
function hasDiffOneKey(versions) {
  return Object.keys(versions).length !== 1;
}
function isVersionValid(packageMeta, packageVersion) {
  const hasVersion = typeof packageVersion !== 'undefined';
  if (!hasVersion) {
    return false;
  }
  const hasMatchVersion = Object.keys(packageMeta.versions).includes(packageVersion);
  return hasMatchVersion;
}
function isRelatedToDeprecation(pkgInfo) {
  const {
    versions
  } = pkgInfo;
  for (const version in versions) {
    if (Object.prototype.hasOwnProperty.call(versions[version], 'deprecated')) {
      return true;
    }
  }
  return false;
}
function validateURL(publicUrl) {
  try {
    const parsed = new _url.URL(publicUrl);
    if (!validProtocols.includes(parsed.protocol.replace(':', ''))) {
      throw Error('invalid protocol');
    }
    return true;
  } catch (err) {
    // TODO: add error logger here
    return false;
  }
}
function isHost(url = '', options = {}) {
  return _validator.default.isURL(url, _objectSpread({
    require_host: true,
    allow_trailing_dot: false,
    require_valid_protocol: false,
    // @ts-ignore
    require_port: false,
    require_tld: false
  }, options));
}
function hasLogin(config) {
  var _config$web, _config$web2;
  // FIXME: types are not yet on the library verdaccio/monorepo
  // @ts-ignore
  return _lodash.default.isNil(config === null || config === void 0 ? void 0 : (_config$web = config.web) === null || _config$web === void 0 ? void 0 : _config$web.login) || (config === null || config === void 0 ? void 0 : (_config$web2 = config.web) === null || _config$web2 === void 0 ? void 0 : _config$web2.login) === true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnZXRCYWREYXRhIiwiZ2V0QmFkUmVxdWVzdCIsImdldENvZGUiLCJnZXRDb25mbGljdCIsImdldEZvcmJpZGRlbiIsImdldEludGVybmFsRXJyb3IiLCJnZXROb3RGb3VuZCIsImdldFNlcnZpY2VVbmF2YWlsYWJsZSIsImdldFVuYXV0aG9yaXplZCIsImVycm9yVXRpbHMiLCJkZWJ1ZyIsImJ1aWxkRGVidWciLCJyZXF1aXJlIiwibW9kdWxlIiwicGtnVmVyc2lvbiIsImV4cG9ydHMiLCJ2ZXJzaW9uIiwicGtnTmFtZSIsIm5hbWUiLCJ2YWxpZFByb3RvY29scyIsImdldFVzZXJBZ2VudCIsImN1c3RvbVVzZXJBZ2VudCIsImFzc2VydCIsIl8iLCJpc1N0cmluZyIsImlzRW1wdHkiLCJjb252ZXJ0UGF5bG9hZFRvQmFzZTY0IiwicGF5bG9hZCIsIkJ1ZmZlciIsImZyb20iLCJpc09iamVjdCIsInZhbGlkYXRpb1V0aWxzIiwiaXNPYmplY3RPckFycmF5Iiwib2JqIiwiaXNOdWxsIiwidGFnVmVyc2lvbiIsImRhdGEiLCJ0YWciLCJESVNUX1RBR1MiLCJzZW12ZXIiLCJwYXJzZSIsImdldFZlcnNpb24iLCJwa2ciLCJpc05pbCIsInZlcnNpb25zIiwidmVyc2lvbkl0ZW0iLCJjb21wYXJlIiwiZXJyIiwidW5kZWZpbmVkIiwicGFyc2VBZGRyZXNzIiwidXJsQWRkcmVzcyIsInVybFBhdHRlcm4iLCJleGVjIiwicHJvdG8iLCJERUZBVUxUX1BST1RPQ09MIiwiaG9zdCIsIkRFRkFVTFRfRE9NQUlOIiwicG9ydCIsIkRFRkFVTFRfUE9SVCIsInBhdGgiLCJzZW12ZXJTb3J0IiwibGlzdFZlcnNpb25zIiwiZmlsdGVyIiwieCIsImxvZ2dlciIsIndhcm4iLCJ2ZXIiLCJzb3J0IiwiY29tcGFyZUxvb3NlIiwibWFwIiwiU3RyaW5nIiwibm9ybWFsaXplRGlzdFRhZ3MiLCJzb3J0ZWQiLCJsYXRlc3QiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwicG9wIiwiaXNBcnJheSIsInBhcnNlSW50ZXJ2YWxUYWJsZSIsIm1zIiwicyIsIm0iLCJoIiwiZCIsInciLCJNIiwieSIsInBhcnNlSW50ZXJ2YWwiLCJpbnRlcnZhbCIsInJlc3VsdCIsImxhc3Rfc3VmZml4IiwiSW5maW5pdHkiLCJzcGxpdCIsImZvckVhY2giLCJtYXRjaCIsIkVycm9yIiwiTnVtYmVyIiwiZ2V0V2ViUHJvdG9jb2wiLCJoZWFkZXJQcm90b2NvbCIsInByb3RvY29sIiwicmV0dXJuUHJvdG9jb2wiLCJkZWZhdWx0UHJvdG9jb2wiLCJjb21tYUluZGV4IiwiaW5kZXhPZiIsInN1YnN0ciIsImluY2x1ZGVzIiwiRXJyb3JDb2RlIiwicGFyc2VDb25maWdGaWxlIiwiY29uZmlnUGF0aCIsInRlc3QiLCJZQU1MIiwibG9hZCIsImZzIiwicmVhZEZpbGVTeW5jIiwiZSIsImNvZGUiLCJtZXNzYWdlIiwiQVBQX0VSUk9SIiwiQ09ORklHX05PVF9WQUxJRCIsImZvbGRlckV4aXN0cyIsInN0YXQiLCJzdGF0U3luYyIsImlzRGlyZWN0b3J5IiwiZmlsZUV4aXN0cyIsImlzRmlsZSIsInNvcnRCeU5hbWUiLCJwYWNrYWdlcyIsIm9yZGVyQXNjZW5kaW5nIiwic2xpY2UiLCJhIiwiYiIsImNvbXBhcmF0b3JOYW1lcyIsInRvTG93ZXJDYXNlIiwiYWRkU2NvcGUiLCJzY29wZSIsInBhY2thZ2VOYW1lIiwiZGVsZXRlUHJvcGVydGllcyIsInByb3BlcnRpZXNUb0RlbGV0ZSIsIm9iamVjdEl0ZW0iLCJwcm9wZXJ0eSIsImFkZEdyYXZhdGFyU3VwcG9ydCIsInBrZ0luZm8iLCJvbmxpbmUiLCJwa2dJbmZvQ29weSIsImF1dGhvciIsImdldCIsImNvbnRyaWJ1dG9ycyIsIm5vcm1hbGl6ZUNvbnRyaWJ1dG9ycyIsIm1haW50YWluZXJzIiwiZW1haWwiLCJhdmF0YXIiLCJnZW5lcmF0ZUdyYXZhdGFyVXJsIiwiR0VORVJJQ19BVkFUQVIiLCJjb250cmlidXRvciIsIm1haW50YWluZXIiLCJwYXJzZVJlYWRtZSIsInJlYWRtZSIsImluZm8iLCJnZXRWZXJzaW9uRnJvbVRhcmJhbGwiLCJmb3JtYXRBdXRob3IiLCJhdXRob3JEZXRhaWxzIiwiREVGQVVMVF9VU0VSIiwidXJsIiwiaXNIVFRQUHJvdG9jb2wiLCJ1cmkiLCJwYWQiLCJzdHIiLCJtYXgiLCJyZXBlYXQiLCJtYXNrIiwiY2hhck51bSIsImVuY29kZVNjb3BlZFVyaSIsInJlcGxhY2UiLCJoYXNEaWZmT25lS2V5IiwiaXNWZXJzaW9uVmFsaWQiLCJwYWNrYWdlTWV0YSIsInBhY2thZ2VWZXJzaW9uIiwiaGFzVmVyc2lvbiIsImhhc01hdGNoVmVyc2lvbiIsImlzUmVsYXRlZFRvRGVwcmVjYXRpb24iLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWxpZGF0ZVVSTCIsInB1YmxpY1VybCIsInBhcnNlZCIsIlVSTCIsImlzSG9zdCIsIm9wdGlvbnMiLCJ2YWxpZGF0b3IiLCJpc1VSTCIsInJlcXVpcmVfaG9zdCIsImFsbG93X3RyYWlsaW5nX2RvdCIsInJlcXVpcmVfdmFsaWRfcHJvdG9jb2wiLCJyZXF1aXJlX3BvcnQiLCJyZXF1aXJlX3RsZCIsImhhc0xvZ2luIiwiY29uZmlnIiwid2ViIiwibG9naW4iXSwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBidWlsZERlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgWUFNTCBmcm9tICdqcy15YW1sJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgeyBVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0IHZhbGlkYXRvciBmcm9tICd2YWxpZGF0b3InO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuaW1wb3J0IHsgZXJyb3JVdGlscywgdmFsaWRhdGlvVXRpbHMgfSBmcm9tICdAdmVyZGFjY2lvL2NvcmUnO1xuaW1wb3J0IHsgU3RyaW5nVmFsdWUgfSBmcm9tICdAdmVyZGFjY2lvL3R5cGVzJztcbmltcG9ydCB7IEF1dGhvciwgQ29uZmlnLCBQYWNrYWdlLCBWZXJzaW9uIH0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5pbXBvcnQge1xuICBHRU5FUklDX0FWQVRBUixcbiAgYnVpbGRUb2tlbiBhcyBidWlsZFRva2VuVXRpbCxcbiAgZ2VuZXJhdGVHcmF2YXRhclVybCxcbiAgbm9ybWFsaXplQ29udHJpYnV0b3JzLFxufSBmcm9tICdAdmVyZGFjY2lvL3V0aWxzJztcblxuaW1wb3J0IHsgQXV0aG9yQXZhdGFyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgQVBQX0VSUk9SLFxuICBERUZBVUxUX0RPTUFJTixcbiAgREVGQVVMVF9QT1JULFxuICBERUZBVUxUX1BST1RPQ09MLFxuICBERUZBVUxUX1VTRVIsXG4gIERJU1RfVEFHUyxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuXG5jb25zdCB7XG4gIGdldEJhZERhdGEsXG4gIGdldEJhZFJlcXVlc3QsXG4gIGdldENvZGUsXG4gIGdldENvbmZsaWN0LFxuICBnZXRGb3JiaWRkZW4sXG4gIGdldEludGVybmFsRXJyb3IsXG4gIGdldE5vdEZvdW5kLFxuICBnZXRTZXJ2aWNlVW5hdmFpbGFibGUsXG4gIGdldFVuYXV0aG9yaXplZCxcbn0gPSBlcnJvclV0aWxzO1xuY29uc3QgZGVidWcgPSBidWlsZERlYnVnKCd2ZXJkYWNjaW8nKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbnJlcXVpcmUoJ3BrZ2luZm8nKShtb2R1bGUpO1xuY29uc3QgcGtnVmVyc2lvbiA9IG1vZHVsZS5leHBvcnRzLnZlcnNpb247XG5jb25zdCBwa2dOYW1lID0gbW9kdWxlLmV4cG9ydHMubmFtZTtcbmNvbnN0IHZhbGlkUHJvdG9jb2xzID0gWydodHRwcycsICdodHRwJ107XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyQWdlbnQoY3VzdG9tVXNlckFnZW50PzogYm9vbGVhbiB8IHN0cmluZyk6IHN0cmluZyB7XG4gIGFzc2VydChfLmlzU3RyaW5nKHBrZ05hbWUpKTtcbiAgYXNzZXJ0KF8uaXNTdHJpbmcocGtnVmVyc2lvbikpO1xuICBpZiAoY3VzdG9tVXNlckFnZW50ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGAke3BrZ05hbWV9LyR7cGtnVmVyc2lvbn1gO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoY3VzdG9tVXNlckFnZW50KSAmJiBfLmlzRW1wdHkoY3VzdG9tVXNlckFnZW50KSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gY3VzdG9tVXNlckFnZW50O1xuICB9IGVsc2UgaWYgKGN1c3RvbVVzZXJBZ2VudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gYCR7cGtnTmFtZX0vJHtwa2dWZXJzaW9ufWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UGF5bG9hZFRvQmFzZTY0KHBheWxvYWQ6IHN0cmluZyk6IEJ1ZmZlciB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShwYXlsb2FkLCAnYmFzZTY0Jyk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIE9iamVjdFxuICogQHBhcmFtIHsqfSBvYmogdGhlIGVsZW1lbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9IHZhbGlkYXRpb1V0aWxzLmlzT2JqZWN0O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIG5vdCB1c2VkIHVuIHY2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdE9yQXJyYXkob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIF8uaXNPYmplY3Qob2JqKSAmJiBfLmlzTnVsbChvYmopID09PSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhZ1ZlcnNpb24oZGF0YTogUGFja2FnZSwgdmVyc2lvbjogc3RyaW5nLCB0YWc6IFN0cmluZ1ZhbHVlKTogYm9vbGVhbiB7XG4gIGlmICh0YWcgJiYgZGF0YVtESVNUX1RBR1NdW3RhZ10gIT09IHZlcnNpb24gJiYgc2VtdmVyLnBhcnNlKHZlcnNpb24sIHRydWUpKSB7XG4gICAgLy8gdmFsaWQgdmVyc2lvbiAtIHN0b3JlXG4gICAgZGF0YVtESVNUX1RBR1NdW3RhZ10gPSB2ZXJzaW9uO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXRzIHZlcnNpb24gZnJvbSBhIHBhY2thZ2Ugb2JqZWN0IHRha2luZyBpbnRvIGFjY291bnQgc2VtdmVyIHdlaXJkbmVzcy5cbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG9mIGEgcGFja2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVyc2lvbihwa2c6IFBhY2thZ2UsIHZlcnNpb246IGFueSk6IFZlcnNpb24gfCB2b2lkIHtcbiAgLy8gdGhpcyBjb25kaXRpb24gbXVzdCBhbGxvdyBjYXN0XG4gIGlmIChfLmlzTmlsKHBrZy52ZXJzaW9uc1t2ZXJzaW9uXSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHBrZy52ZXJzaW9uc1t2ZXJzaW9uXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmVyc2lvbiA9IHNlbXZlci5wYXJzZSh2ZXJzaW9uLCB0cnVlKTtcbiAgICBmb3IgKGNvbnN0IHZlcnNpb25JdGVtIGluIHBrZy52ZXJzaW9ucykge1xuICAgICAgaWYgKHZlcnNpb24uY29tcGFyZShzZW12ZXIucGFyc2UodmVyc2lvbkl0ZW0sIHRydWUpKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcGtnLnZlcnNpb25zW3ZlcnNpb25JdGVtXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBpbnRlcm5ldCBhZGRyZXNzXG4gKiBBbGxvdzpcbiAtIGh0dHBzOmxvY2FsaG9zdDoxMjM0ICAgICAgICAtIHByb3RvY29sICsgaG9zdCArIHBvcnRcbiAtIGxvY2FsaG9zdDoxMjM0ICAgICAgICAgICAgICAtIGhvc3QgKyBwb3J0XG4gLSAxMjM0ICAgICAgICAgICAgICAgICAgICAgICAgLSBwb3J0XG4gLSBodHRwOjoxMjM0ICAgICAgICAgICAgICAgICAgLSBwcm90b2NvbCArIHBvcnRcbiAtIGh0dHBzOi8vbG9jYWxob3N0OjQ0My8gICAgICAtIGZ1bGwgdXJsICsgaHR0cHNcbiAtIGh0dHA6Ly9bOjoxXTo0NDMvICAgICAgICAgICAtIGlwdjZcbiAtIHVuaXg6L3RtcC9odHRwLnNvY2sgICAgICAgICAtIHVuaXggc29ja2V0c1xuIC0gaHR0cHM6Ly91bml4Oi90bXAvaHR0cC5zb2NrIC0gdW5peCBzb2NrZXRzIChodHRwcylcbiAqIEBwYXJhbSB7Kn0gdXJsQWRkcmVzcyB0aGUgaW50ZXJuZXQgYWRkcmVzcyBkZWZpbml0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R8TnVsbH0gbGl0ZXJhbCBvYmplY3QgdGhhdCByZXByZXNlbnQgdGhlIGFkZHJlc3MgcGFyc2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFkZHJlc3ModXJsQWRkcmVzczogYW55KTogYW55IHtcbiAgLy9cbiAgLy8gVE9ETzogcmVmYWN0b3IgaXQgdG8gc29tZXRoaW5nIG1vcmUgcmVhc29uYWJsZT9cbiAgLy9cbiAgLy8gICAgICAgIHByb3RvY29sIDogIC8vICAgICAgKCAgaG9zdCAgKXwoICAgIGlwdjYgICAgICk6ICBwb3J0ICAvXG4gIGxldCB1cmxQYXR0ZXJuID0gL14oKGh0dHBzPyk6KFxcL1xcLyk/KT8oKChbXlxcLzpdKil8XFxbKFteXFxbXFxdXSspXFxdKTopPyhcXGQrKVxcLz8kLy5leGVjKHVybEFkZHJlc3MpO1xuXG4gIGlmICh1cmxQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RvOiB1cmxQYXR0ZXJuWzJdIHx8IERFRkFVTFRfUFJPVE9DT0wsXG4gICAgICBob3N0OiB1cmxQYXR0ZXJuWzZdIHx8IHVybFBhdHRlcm5bN10gfHwgREVGQVVMVF9ET01BSU4sXG4gICAgICBwb3J0OiB1cmxQYXR0ZXJuWzhdIHx8IERFRkFVTFRfUE9SVCxcbiAgICB9O1xuICB9XG5cbiAgdXJsUGF0dGVybiA9IC9eKChodHRwcz8pOihcXC9cXC8pPyk/dW5peDooLiopJC8uZXhlYyh1cmxBZGRyZXNzKTtcblxuICBpZiAodXJsUGF0dGVybikge1xuICAgIHJldHVybiB7XG4gICAgICBwcm90bzogdXJsUGF0dGVyblsyXSB8fCBERUZBVUxUX1BST1RPQ09MLFxuICAgICAgcGF0aDogdXJsUGF0dGVybls0XSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gZmlsdGVycyBvdXQgYmFkIHNlbXZlciB2ZXJzaW9ucyBhbmQgc29ydHMgdGhlIGFycmF5LlxuICogQHJldHVybiB7QXJyYXl9IHNvcnRlZCBBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VtdmVyU29ydChsaXN0VmVyc2lvbnM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICByZXR1cm4gKFxuICAgIGxpc3RWZXJzaW9uc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIXNlbXZlci5wYXJzZSh4LCB0cnVlKSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKHsgdmVyOiB4IH0sICdpZ25vcmluZyBiYWQgdmVyc2lvbiBAe3Zlcn0nKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KVxuICAgICAgLy8gRklYTUU6IGl0IHNlZW1zIHRoZSBAdHlwZXMvc2VtdmVyIGRvIG5vdCBoYW5kbGUgYSBsZWdpdGltYXRlIG1ldGhvZCBuYW1lZCAnY29tcGFyZUxvb3NlJ1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgLnNvcnQoc2VtdmVyLmNvbXBhcmVMb29zZSlcbiAgICAgIC5tYXAoU3RyaW5nKVxuICApO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYXJyYXlzIG9mIHRhZ3MuXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZURpc3RUYWdzKHBrZzogUGFja2FnZSk6IHZvaWQge1xuICBsZXQgc29ydGVkO1xuICBpZiAoIXBrZ1tESVNUX1RBR1NdLmxhdGVzdCkge1xuICAgIC8vIG92ZXJ3cml0ZSBsYXRlc3Qgd2l0aCBoaWdoZXN0IGtub3duIHZlcnNpb24gYmFzZWQgb24gc2VtdmVyIHNvcnRcbiAgICBzb3J0ZWQgPSBzZW12ZXJTb3J0KE9iamVjdC5rZXlzKHBrZy52ZXJzaW9ucykpO1xuICAgIGlmIChzb3J0ZWQgJiYgc29ydGVkLmxlbmd0aCkge1xuICAgICAgcGtnW0RJU1RfVEFHU10ubGF0ZXN0ID0gc29ydGVkLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgdGFnIGluIHBrZ1tESVNUX1RBR1NdKSB7XG4gICAgaWYgKF8uaXNBcnJheShwa2dbRElTVF9UQUdTXVt0YWddKSkge1xuICAgICAgaWYgKHBrZ1tESVNUX1RBR1NdW3RhZ10ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHNvcnQgYXJyYXlcbiAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgY2xlYXJseSB3cm9uZywgd2UgbmVlZCB0byByZXNlYXJjaCB3aHkgdGhpcyBpcyBsaWtlIHRoaXMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc29ydGVkID0gc2VtdmVyU29ydChwa2dbRElTVF9UQUdTXVt0YWddKTtcbiAgICAgICAgaWYgKHNvcnRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyB1c2UgaGlnaGVzdCB2ZXJzaW9uIGJhc2VkIG9uIHNlbXZlciBzb3J0XG4gICAgICAgICAgcGtnW0RJU1RfVEFHU11bdGFnXSA9IHNvcnRlZC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHBrZ1tESVNUX1RBR1NdW3RhZ107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHBrZ1tESVNUX1RBR1NdW3RhZ10pKSB7XG4gICAgICBpZiAoIXNlbXZlci5wYXJzZShwa2dbRElTVF9UQUdTXVt0YWddLCB0cnVlKSkge1xuICAgICAgICAvLyBpZiB0aGUgdmVyc2lvbiBpcyBpbnZhbGlkLCBkZWxldGUgdGhlIGRpc3QtdGFnIGVudHJ5XG4gICAgICAgIGRlbGV0ZSBwa2dbRElTVF9UQUdTXVt0YWddO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwYXJzZUludGVydmFsVGFibGUgPSB7XG4gICcnOiAxMDAwLFxuICBtczogMSxcbiAgczogMTAwMCxcbiAgbTogNjAgKiAxMDAwLFxuICBoOiA2MCAqIDYwICogMTAwMCxcbiAgZDogODY0MDAwMDAsXG4gIHc6IDcgKiA4NjQwMDAwMCxcbiAgTTogMzAgKiA4NjQwMDAwMCxcbiAgeTogMzY1ICogODY0MDAwMDAsXG59O1xuXG4vKipcbiAqIFBhcnNlIGFuIGludGVybmFsIHN0cmluZyB0byBudW1iZXJcbiAqIEBwYXJhbSB7Kn0gaW50ZXJ2YWxcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW50ZXJ2YWwoaW50ZXJ2YWw6IGFueSk6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGludGVydmFsICogMTAwMDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gMDtcbiAgbGV0IGxhc3Rfc3VmZml4ID0gSW5maW5pdHk7XG4gIGludGVydmFsLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoeCk6IHZvaWQge1xuICAgIGlmICgheCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtID0geC5tYXRjaCgvXigoMHxbMS05XVswLTldKikoXFwuWzAtOV0rKT8pKG1zfHN8bXxofGR8d3xNfHl8KSQvKTtcbiAgICBpZiAoXG4gICAgICAhbSB8fFxuICAgICAgcGFyc2VJbnRlcnZhbFRhYmxlW21bNF1dID49IGxhc3Rfc3VmZml4IHx8XG4gICAgICAobVs0XSA9PT0gJycgJiYgbGFzdF9zdWZmaXggIT09IEluZmluaXR5KVxuICAgICkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2ludmFsaWQgaW50ZXJ2YWw6ICcgKyBpbnRlcnZhbCk7XG4gICAgfVxuICAgIGxhc3Rfc3VmZml4ID0gcGFyc2VJbnRlcnZhbFRhYmxlW21bNF1dO1xuICAgIHJlc3VsdCArPSBOdW1iZXIobVsxXSkgKiBwYXJzZUludGVydmFsVGFibGVbbVs0XV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVjdCBydW5uaW5nIHByb3RvY29sIChodHRwIG9yIGh0dHBzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2ViUHJvdG9jb2woaGVhZGVyUHJvdG9jb2w6IHN0cmluZyB8IHZvaWQsIHByb3RvY29sOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgcmV0dXJuUHJvdG9jb2w7XG4gIGNvbnN0IFssIGRlZmF1bHRQcm90b2NvbF0gPSB2YWxpZFByb3RvY29scztcbiAgLy8gSEFQcm94eSB2YXJpYW50IG1pZ2h0IHJldHVybiBodHRwLGh0dHAgd2l0aCBYLUZvcndhcmRlZC1Qcm90b1xuICBpZiAodHlwZW9mIGhlYWRlclByb3RvY29sID09PSAnc3RyaW5nJyAmJiBoZWFkZXJQcm90b2NvbCAhPT0gJycpIHtcbiAgICBkZWJ1ZygnaGVhZGVyIHByb3RvY29sOiAlbycsIHByb3RvY29sKTtcbiAgICBjb25zdCBjb21tYUluZGV4ID0gaGVhZGVyUHJvdG9jb2wuaW5kZXhPZignLCcpO1xuICAgIHJldHVyblByb3RvY29sID0gY29tbWFJbmRleCA+IDAgPyBoZWFkZXJQcm90b2NvbC5zdWJzdHIoMCwgY29tbWFJbmRleCkgOiBoZWFkZXJQcm90b2NvbDtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncmVxIHByb3RvY29sOiAlbycsIGhlYWRlclByb3RvY29sKTtcbiAgICByZXR1cm5Qcm90b2NvbCA9IHByb3RvY29sO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkUHJvdG9jb2xzLmluY2x1ZGVzKHJldHVyblByb3RvY29sKSA/IHJldHVyblByb3RvY29sIDogZGVmYXVsdFByb3RvY29sO1xufVxuXG5leHBvcnQgY29uc3QgRXJyb3JDb2RlID0ge1xuICBnZXRDb25mbGljdCxcbiAgZ2V0QmFkRGF0YSxcbiAgZ2V0QmFkUmVxdWVzdCxcbiAgZ2V0SW50ZXJuYWxFcnJvcixcbiAgZ2V0VW5hdXRob3JpemVkLFxuICBnZXRGb3JiaWRkZW4sXG4gIGdldFNlcnZpY2VVbmF2YWlsYWJsZSxcbiAgZ2V0Tm90Rm91bmQsXG4gIGdldENvZGUsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb25maWdGaWxlKGNvbmZpZ1BhdGg6IHN0cmluZyk6IGFueSB7XG4gIHRyeSB7XG4gICAgaWYgKC9cXC55YT9tbCQvaS50ZXN0KGNvbmZpZ1BhdGgpKSB7XG4gICAgICByZXR1cm4gWUFNTC5sb2FkKGZzLnJlYWRGaWxlU3luYyhjb25maWdQYXRoLCAndXRmLTgnKSk7XG4gICAgfVxuICAgIGRlYnVnKCd5YW1sIHBhcnNlZCcpO1xuICAgIHJldHVybiByZXF1aXJlKGNvbmZpZ1BhdGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ3lhbWwgcGFyc2UgZmFpbGVkJyk7XG4gICAgaWYgKGUuY29kZSAhPT0gJ01PRFVMRV9OT1RfRk9VTkQnKSB7XG4gICAgICBlLm1lc3NhZ2UgPSBBUFBfRVJST1IuQ09ORklHX05PVF9WQUxJRDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBwYXRoIGFscmVhZHkgZXhpc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvbGRlckV4aXN0cyhwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMocGF0aCk7XG4gICAgcmV0dXJuIHN0YXQuaXNEaXJlY3RvcnkoKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGZpbGUgYWxyZWFkeSBleGlzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsZUV4aXN0cyhwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMocGF0aCk7XG4gICAgcmV0dXJuIHN0YXQuaXNGaWxlKCk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRCeU5hbWUocGFja2FnZXM6IGFueVtdLCBvcmRlckFzY2VuZGluZzogYm9vbGVhbiB8IHZvaWQgPSB0cnVlKTogc3RyaW5nW10ge1xuICByZXR1cm4gcGFja2FnZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKTogbnVtYmVyIHtcbiAgICBjb25zdCBjb21wYXJhdG9yTmFtZXMgPSBhLm5hbWUudG9Mb3dlckNhc2UoKSA8IGIubmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgcmV0dXJuIG9yZGVyQXNjZW5kaW5nID8gKGNvbXBhcmF0b3JOYW1lcyA/IC0xIDogMSkgOiBjb21wYXJhdG9yTmFtZXMgPyAxIDogLTE7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkU2NvcGUoc2NvcGU6IHN0cmluZywgcGFja2FnZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgQCR7c2NvcGV9LyR7cGFja2FnZU5hbWV9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnRpZXMocHJvcGVydGllc1RvRGVsZXRlOiBzdHJpbmdbXSwgb2JqZWN0SXRlbTogYW55KTogYW55IHtcbiAgXy5mb3JFYWNoKHByb3BlcnRpZXNUb0RlbGV0ZSwgKHByb3BlcnR5KTogYW55ID0+IHtcbiAgICBkZWxldGUgb2JqZWN0SXRlbVtwcm9wZXJ0eV07XG4gIH0pO1xuXG4gIHJldHVybiBvYmplY3RJdGVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkR3JhdmF0YXJTdXBwb3J0KHBrZ0luZm86IFBhY2thZ2UsIG9ubGluZSA9IHRydWUpOiBBdXRob3JBdmF0YXIge1xuICBjb25zdCBwa2dJbmZvQ29weSA9IHsgLi4ucGtnSW5mbyB9IGFzIGFueTtcbiAgY29uc3QgYXV0aG9yOiBhbnkgPSBfLmdldChwa2dJbmZvLCAnbGF0ZXN0LmF1dGhvcicsIG51bGwpIGFzIGFueTtcbiAgY29uc3QgY29udHJpYnV0b3JzOiBBdXRob3JBdmF0YXJbXSA9IG5vcm1hbGl6ZUNvbnRyaWJ1dG9ycyhcbiAgICBfLmdldChwa2dJbmZvLCAnbGF0ZXN0LmNvbnRyaWJ1dG9ycycsIFtdKVxuICApO1xuICBjb25zdCBtYWludGFpbmVycyA9IF8uZ2V0KHBrZ0luZm8sICdsYXRlc3QubWFpbnRhaW5lcnMnLCBbXSk7XG5cbiAgLy8gZm9yIGF1dGhvci5cbiAgaWYgKGF1dGhvciAmJiBfLmlzT2JqZWN0KGF1dGhvcikpIHtcbiAgICBjb25zdCB7IGVtYWlsIH0gPSBhdXRob3IgYXMgQXV0aG9yO1xuICAgIHBrZ0luZm9Db3B5LmxhdGVzdC5hdXRob3IuYXZhdGFyID0gZ2VuZXJhdGVHcmF2YXRhclVybChlbWFpbCwgb25saW5lKTtcbiAgfVxuXG4gIGlmIChhdXRob3IgJiYgXy5pc1N0cmluZyhhdXRob3IpKSB7XG4gICAgcGtnSW5mb0NvcHkubGF0ZXN0LmF1dGhvciA9IHtcbiAgICAgIGF2YXRhcjogR0VORVJJQ19BVkFUQVIsXG4gICAgICBlbWFpbDogJycsXG4gICAgICBhdXRob3IsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGZvciBjb250cmlidXRvcnNcbiAgaWYgKF8uaXNFbXB0eShjb250cmlidXRvcnMpID09PSBmYWxzZSkge1xuICAgIHBrZ0luZm9Db3B5LmxhdGVzdC5jb250cmlidXRvcnMgPSBjb250cmlidXRvcnMubWFwKChjb250cmlidXRvcik6IEF1dGhvckF2YXRhciA9PiB7XG4gICAgICBpZiAoaXNPYmplY3QoY29udHJpYnV0b3IpKSB7XG4gICAgICAgIGNvbnRyaWJ1dG9yLmF2YXRhciA9IGdlbmVyYXRlR3JhdmF0YXJVcmwoY29udHJpYnV0b3IuZW1haWwsIG9ubGluZSk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoY29udHJpYnV0b3IpKSB7XG4gICAgICAgIGNvbnRyaWJ1dG9yID0ge1xuICAgICAgICAgIGF2YXRhcjogR0VORVJJQ19BVkFUQVIsXG4gICAgICAgICAgZW1haWw6IGNvbnRyaWJ1dG9yLFxuICAgICAgICAgIG5hbWU6IGNvbnRyaWJ1dG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udHJpYnV0b3I7XG4gICAgfSk7XG4gIH1cblxuICAvLyBmb3IgbWFpbnRhaW5lcnNcbiAgaWYgKF8uaXNFbXB0eShtYWludGFpbmVycykgPT09IGZhbHNlKSB7XG4gICAgcGtnSW5mb0NvcHkubGF0ZXN0Lm1haW50YWluZXJzID0gbWFpbnRhaW5lcnMubWFwKChtYWludGFpbmVyKTogdm9pZCA9PiB7XG4gICAgICBtYWludGFpbmVyLmF2YXRhciA9IGdlbmVyYXRlR3JhdmF0YXJVcmwobWFpbnRhaW5lci5lbWFpbCwgb25saW5lKTtcbiAgICAgIHJldHVybiBtYWludGFpbmVyO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBrZ0luZm9Db3B5O1xufVxuXG4vKipcbiAqIHBhcnNlIHBhY2thZ2UgcmVhZG1lIC0gbWFya2Rvd24vYXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrYWdlTmFtZSBuYW1lIG9mIHBhY2thZ2VcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFkbWUgcGFja2FnZSByZWFkbWVcblxuICogQHJldHVybiB7U3RyaW5nfSBjb252ZXJ0ZWQgaHRtbCB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWFkbWUocGFja2FnZU5hbWU6IHN0cmluZywgcmVhZG1lOiBzdHJpbmcpOiBzdHJpbmcgfCB2b2lkIHtcbiAgaWYgKF8uaXNFbXB0eShyZWFkbWUpID09PSBmYWxzZSkge1xuICAgIHJldHVybiByZWFkbWU7XG4gIH1cblxuICAvLyBsb2dzIHJlYWRtZSBub3QgZm91bmQgZXJyb3JcbiAgbG9nZ2VyLmluZm8oeyBwYWNrYWdlTmFtZSB9LCAnQHtwYWNrYWdlTmFtZX06IE5vIHJlYWRtZSBmb3VuZCcpO1xuXG4gIHJldHVybiAnRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kISc7XG59XG5cbi8qKlxuICogcmV0dXJuIHBhY2thZ2UgdmVyc2lvbiBmcm9tIHRhcmJhbGwgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzaW9uRnJvbVRhcmJhbGwobmFtZTogc3RyaW5nKTogc3RyaW5nIHwgdm9pZCB7XG4gIC8vIEZJWE1FOiB3ZSBrbm93IHRoZSByZWdleCBpcyB2YWxpZCwgYnV0IHdlIHNob3VsZCBpbXByb3ZlIHRoaXMgcGFydCBhcyB0cyBzdWdnZXN0XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIC8uKy0oXFxkLispXFwudGd6Ly50ZXN0KG5hbWUpID8gbmFtZS5tYXRjaCgvListKFxcZC4rKVxcLnRnei8pWzFdIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgdHlwZSBBdXRob3JGb3JtYXQgPSBBdXRob3IgfCBzdHJpbmcgfCBudWxsIHwgb2JqZWN0IHwgdm9pZDtcblxuLyoqXG4gKiBGb3JtYXRzIGF1dGhvciBmaWVsZCBmb3Igd2VidWkuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5ucG1qcy5jb20vZmlsZXMvcGFja2FnZS5qc29uI2F1dGhvclxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fHVuZGVmaW5lZH0gYXV0aG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBdXRob3IoYXV0aG9yOiBBdXRob3JGb3JtYXQpOiBhbnkge1xuICBsZXQgYXV0aG9yRGV0YWlscyA9IHtcbiAgICBuYW1lOiBERUZBVUxUX1VTRVIsXG4gICAgZW1haWw6ICcnLFxuICAgIHVybDogJycsXG4gIH07XG5cbiAgaWYgKF8uaXNOaWwoYXV0aG9yKSkge1xuICAgIHJldHVybiBhdXRob3JEZXRhaWxzO1xuICB9XG5cbiAgaWYgKF8uaXNTdHJpbmcoYXV0aG9yKSkge1xuICAgIGF1dGhvckRldGFpbHMgPSB7XG4gICAgICAuLi5hdXRob3JEZXRhaWxzLFxuICAgICAgbmFtZTogYXV0aG9yIGFzIHN0cmluZyxcbiAgICB9O1xuICB9XG5cbiAgaWYgKF8uaXNPYmplY3QoYXV0aG9yKSkge1xuICAgIGF1dGhvckRldGFpbHMgPSB7XG4gICAgICAuLi5hdXRob3JEZXRhaWxzLFxuICAgICAgLi4uKGF1dGhvciBhcyBBdXRob3IpLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gYXV0aG9yRGV0YWlscztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBVUkkgaXMgc3RhcnRpbmcgd2l0aCBcImh0dHA6Ly9cIiwgXCJodHRwczovL1wiIG9yIFwiLy9cIlxuICogQHBhcmFtIHtzdHJpbmd9IHVyaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIVFRQUHJvdG9jb2wodXJpOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9eKGh0dHBzPzopP1xcL1xcLy8udGVzdCh1cmkpO1xufVxuXG4vKipcbiAqIEFwcGx5IHdoaXRlc3BhY2VzIGJhc2VkIG9uIHRoZSBsZW5ndGhcbiAqIEBwYXJhbSB7Kn0gc3RyIHRoZSBsb2cgbWVzc2FnZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkKHN0ciwgbWF4KTogc3RyaW5nIHtcbiAgaWYgKHN0ci5sZW5ndGggPCBtYXgpIHtcbiAgICByZXR1cm4gc3RyICsgJyAnLnJlcGVhdChtYXggLSBzdHIubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIHJldHVybiBhIG1hc3F1ZXJhZGUgc3RyaW5nIHdpdGggaXRzIGZpcnN0IGFuZCBsYXN0IHtjaGFyTnVtfSBhbmQgdGhyZWUgZG90cyBpbiBiZXR3ZWVuLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJOdW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXNrKHN0cjogc3RyaW5nLCBjaGFyTnVtID0gMyk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtzdHIuc3Vic3RyKDAsIGNoYXJOdW0pfS4uLiR7c3RyLnN1YnN0cigtY2hhck51bSl9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVNjb3BlZFVyaShwYWNrYWdlTmFtZSk6IHN0cmluZyB7XG4gIHJldHVybiBwYWNrYWdlTmFtZS5yZXBsYWNlKC9cXC8vZywgJyUyZicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzRGlmZk9uZUtleSh2ZXJzaW9ucyk6IGJvb2xlYW4ge1xuICByZXR1cm4gT2JqZWN0LmtleXModmVyc2lvbnMpLmxlbmd0aCAhPT0gMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2lvblZhbGlkKHBhY2thZ2VNZXRhLCBwYWNrYWdlVmVyc2lvbik6IGJvb2xlYW4ge1xuICBjb25zdCBoYXNWZXJzaW9uID0gdHlwZW9mIHBhY2thZ2VWZXJzaW9uICE9PSAndW5kZWZpbmVkJztcbiAgaWYgKCFoYXNWZXJzaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgaGFzTWF0Y2hWZXJzaW9uID0gT2JqZWN0LmtleXMocGFja2FnZU1ldGEudmVyc2lvbnMpLmluY2x1ZGVzKHBhY2thZ2VWZXJzaW9uKTtcbiAgcmV0dXJuIGhhc01hdGNoVmVyc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVsYXRlZFRvRGVwcmVjYXRpb24ocGtnSW5mbzogUGFja2FnZSk6IGJvb2xlYW4ge1xuICBjb25zdCB7IHZlcnNpb25zIH0gPSBwa2dJbmZvO1xuICBmb3IgKGNvbnN0IHZlcnNpb24gaW4gdmVyc2lvbnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZlcnNpb25zW3ZlcnNpb25dLCAnZGVwcmVjYXRlZCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVVUkwocHVibGljVXJsOiBzdHJpbmcgfCB2b2lkKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IFVSTChwdWJsaWNVcmwgYXMgc3RyaW5nKTtcbiAgICBpZiAoIXZhbGlkUHJvdG9jb2xzLmluY2x1ZGVzKHBhcnNlZC5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2ludmFsaWQgcHJvdG9jb2wnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFRPRE86IGFkZCBlcnJvciBsb2dnZXIgaGVyZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIb3N0KHVybDogc3RyaW5nID0gJycsIG9wdGlvbnMgPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdmFsaWRhdG9yLmlzVVJMKHVybCwge1xuICAgIHJlcXVpcmVfaG9zdDogdHJ1ZSxcbiAgICBhbGxvd190cmFpbGluZ19kb3Q6IGZhbHNlLFxuICAgIHJlcXVpcmVfdmFsaWRfcHJvdG9jb2w6IGZhbHNlLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXF1aXJlX3BvcnQ6IGZhbHNlLFxuICAgIHJlcXVpcmVfdGxkOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0xvZ2luKGNvbmZpZzogQ29uZmlnKSB7XG4gIC8vIEZJWE1FOiB0eXBlcyBhcmUgbm90IHlldCBvbiB0aGUgbGlicmFyeSB2ZXJkYWNjaW8vbW9ub3JlcG9cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gXy5pc05pbChjb25maWc/LndlYj8ubG9naW4pIHx8IGNvbmZpZz8ud2ViPy5sb2dpbiA9PT0gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgYnVpbGRUb2tlblV0aWwgYXMgYnVpbGRUb2tlbiB9O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFRQTtBQVFBO0FBQWtDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVsQyxNQUFNO0VBQ0pBLFVBQVU7RUFDVkMsYUFBYTtFQUNiQyxPQUFPO0VBQ1BDLFdBQVc7RUFDWEMsWUFBWTtFQUNaQyxnQkFBZ0I7RUFDaEJDLFdBQVc7RUFDWEMscUJBQXFCO0VBQ3JCQztBQUNGLENBQUMsR0FBR0MsZ0JBQVU7QUFDZCxNQUFNQyxLQUFLLEdBQUcsSUFBQUMsY0FBVSxFQUFDLFdBQVcsQ0FBQzs7QUFFckM7QUFDQTtBQUNBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUNDLE1BQU0sQ0FBQztBQUMxQixNQUFNQyxVQUFVLEdBQUdELE1BQU0sQ0FBQ0UsT0FBTyxDQUFDQyxPQUFPO0FBQ3pDLE1BQU1DLE9BQU8sR0FBR0osTUFBTSxDQUFDRSxPQUFPLENBQUNHLElBQUk7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