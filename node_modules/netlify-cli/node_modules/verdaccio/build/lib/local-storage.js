"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _assert = _interopRequireDefault(require("assert"));
var _debug = _interopRequireDefault(require("debug"));
var _lodash = _interopRequireDefault(require("lodash"));
var _url = _interopRequireDefault(require("url"));
var _localStorage = _interopRequireDefault(require("@verdaccio/local-storage"));
var _streams = require("@verdaccio/streams");
var _utils = require("@verdaccio/utils");
var _pluginLoader = _interopRequireDefault(require("../lib/plugin-loader"));
var _constants = require("./constants");
var _storageUtils = require("./storage-utils");
var _utils2 = require("./utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const debug = (0, _debug.default)('verdaccio:local-storage');
/**
 * Implements Storage interface (same for storage.js, local-storage.js, up-storage.js).
 */
class LocalStorage {
  constructor(config, logger) {
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "storagePlugin", void 0);
    _defineProperty(this, "logger", void 0);
    this.logger = logger;
    this.config = config;
    this.storagePlugin = this._loadStorage(config, logger);
  }
  addPackage(name, pkg, callback) {
    const storage = this._getLocalStorage(name);
    if (_lodash.default.isNil(storage)) {
      return callback(_utils2.ErrorCode.getNotFound('this package cannot be added'));
    }
    storage.createPackage(name, (0, _storageUtils.generatePackageTemplate)(name), err => {
      // FIXME: it will be fixed here https://github.com/verdaccio/verdaccio/pull/1360
      // @ts-ignore
      if (_lodash.default.isNull(err) === false && (err.code === _constants.STORAGE.FILE_EXIST_ERROR || err.code === _constants.HTTP_STATUS.CONFLICT)) {
        return callback(_utils2.ErrorCode.getConflict());
      }
      const latest = (0, _utils.getLatestVersion)(pkg);
      if (_lodash.default.isNil(latest) === false && pkg.versions[latest]) {
        return callback(null, pkg.versions[latest]);
      }
      return callback();
    });
  }

  /**
   * Remove package.
   * @param {*} name
   * @param {*} callback
   * @return {Function}
   */
  removePackage(name, callback) {
    const storage = this._getLocalStorage(name);
    debug('[storage] removing package %o', name);
    if (_lodash.default.isNil(storage)) {
      return callback(_utils2.ErrorCode.getNotFound());
    }
    storage.readPackage(name, (err, data) => {
      if (_lodash.default.isNil(err) === false) {
        if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
          return callback(_utils2.ErrorCode.getNotFound());
        }
        return callback(err);
      }
      data = (0, _storageUtils.normalizePackage)(data);
      this.storagePlugin.remove(name, removeFailed => {
        if (removeFailed) {
          // This will happen when database is locked
          this.logger.error({
            name
          }, `[storage/removePackage] the database is locked, removed has failed for @{name}`);
          return callback(_utils2.ErrorCode.getBadData(removeFailed.message));
        }
        storage.deletePackage(_constants.STORAGE.PACKAGE_FILE_NAME, err => {
          if (err) {
            return callback(err);
          }
          const attachments = Object.keys(data._attachments);
          this._deleteAttachments(storage, attachments, callback);
        });
      });
    });
  }

  /**
   * Synchronize remote package info with the local one
   * @param {*} name
   * @param {*} packageInfo
   * @param {*} callback
   */
  updateVersions(name, packageInfo, callback) {
    this._readCreatePackage(name, (err, packageLocalJson) => {
      if (err) {
        return callback(err);
      }
      let change = false;
      // updating readme
      packageLocalJson.readme = (0, _storageUtils.getLatestReadme)(packageInfo);
      if (packageInfo.readme !== packageLocalJson.readme) {
        change = true;
      }
      for (const versionId in packageInfo.versions) {
        if (_lodash.default.isNil(packageLocalJson.versions[versionId])) {
          let version = packageInfo.versions[versionId];

          // we don't keep readme for package versions,
          // only one readme per package
          version = (0, _storageUtils.cleanUpReadme)(version);
          version.contributors = (0, _utils.normalizeContributors)(version.contributors);
          change = true;
          packageLocalJson.versions[versionId] = version;
          if (version.dist && version.dist.tarball) {
            const urlObject = _url.default.parse(version.dist.tarball);
            const filename = urlObject.pathname.replace(/^.*\//, '');

            // we do NOT overwrite any existing records
            if (_lodash.default.isNil(packageLocalJson._distfiles[filename])) {
              const hash = packageLocalJson._distfiles[filename] = {
                url: version.dist.tarball,
                sha: version.dist.shasum
              };
              /* eslint spaced-comment: 0 */
              const upLink = version[Symbol.for('__verdaccio_uplink')];
              if (_lodash.default.isNil(upLink) === false) {
                this._updateUplinkToRemoteProtocol(hash, upLink);
              }
            }
          }
        }
      }
      for (const tag in packageInfo[_constants.DIST_TAGS]) {
        if (!packageLocalJson[_constants.DIST_TAGS][tag] || packageLocalJson[_constants.DIST_TAGS][tag] !== packageInfo[_constants.DIST_TAGS][tag]) {
          change = true;
          packageLocalJson[_constants.DIST_TAGS][tag] = packageInfo[_constants.DIST_TAGS][tag];
        }
      }
      for (const up in packageInfo._uplinks) {
        if (Object.prototype.hasOwnProperty.call(packageInfo._uplinks, up)) {
          const need_change = !(0, _utils2.isObject)(packageLocalJson._uplinks[up]) || packageInfo._uplinks[up].etag !== packageLocalJson._uplinks[up].etag || packageInfo._uplinks[up].fetched !== packageLocalJson._uplinks[up].fetched;
          if (need_change) {
            change = true;
            packageLocalJson._uplinks[up] = packageInfo._uplinks[up];
          }
        }
      }
      if ('time' in packageInfo && !_lodash.default.isEqual(packageLocalJson.time, packageInfo.time)) {
        packageLocalJson.time = packageInfo.time;
        change = true;
      }
      if (change) {
        debug('updating package %o info', name);
        this._writePackage(name, packageLocalJson, function (err) {
          callback(err, packageLocalJson);
        });
      } else {
        callback(null, packageLocalJson);
      }
    });
  }

  /**
   * Add a new version to a previous local package.
   * @param {*} name
   * @param {*} version
   * @param {*} metadata
   * @param {*} tag
   * @param {*} callback
   */
  addVersion(name, version, metadata, tag, callback) {
    this._updatePackage(name, (data, cb) => {
      // keep only one readme per package
      data.readme = metadata.readme;

      // TODO: lodash remove
      metadata = (0, _storageUtils.cleanUpReadme)(metadata);
      metadata.contributors = (0, _utils.normalizeContributors)(metadata.contributors);
      const hasVersion = data.versions[version] != null;
      if (hasVersion) {
        return cb(_utils2.ErrorCode.getConflict());
      }

      // if uploaded tarball has a different shasum, it's very likely that we have some kind of error
      if ((0, _utils2.isObject)(metadata.dist) && _lodash.default.isString(metadata.dist.tarball)) {
        const tarball = metadata.dist.tarball.replace(/.*\//, '');
        if ((0, _utils2.isObject)(data._attachments[tarball])) {
          if (_lodash.default.isNil(data._attachments[tarball].shasum) === false && _lodash.default.isNil(metadata.dist.shasum) === false) {
            if (data._attachments[tarball].shasum != metadata.dist.shasum) {
              const errorMessage = `shasum error, ${data._attachments[tarball].shasum} != ${metadata.dist.shasum}`;
              return cb(_utils2.ErrorCode.getBadRequest(errorMessage));
            }
          }
          const currentDate = new Date().toISOString();

          // some old storage do not have this field #740
          if (_lodash.default.isNil(data.time)) {
            data.time = {};
          }
          data.time['modified'] = currentDate;
          if ('created' in data.time === false) {
            data.time.created = currentDate;
          }
          data.time[version] = currentDate;
          data._attachments[tarball].version = version;
        }
      }
      data.versions[version] = metadata;
      (0, _utils2.tagVersion)(data, version, tag);
      this.storagePlugin.add(name, addFailed => {
        if (addFailed) {
          return cb(_utils2.ErrorCode.getBadData(addFailed.message));
        }
        cb();
      });
    }, callback);
  }

  /**
   * Merge a new list of tags for a local packages with the existing one.
   * @param {*} pkgName
   * @param {*} tags
   * @param {*} callback
   */
  mergeTags(pkgName, tags, callback) {
    this._updatePackage(pkgName, (data, cb) => {
      /* eslint guard-for-in: 0 */
      for (const tag in tags) {
        // this handle dist-tag rm command
        if (_lodash.default.isNull(tags[tag])) {
          delete data[_constants.DIST_TAGS][tag];
          continue;
        }
        if (_lodash.default.isNil(data.versions[tags[tag]])) {
          return cb(this._getVersionNotFound());
        }
        const version = tags[tag];
        (0, _utils2.tagVersion)(data, version, tag);
      }
      cb(null);
    }, callback);
  }

  /**
   * Return version not found
   * @return {String}
   * @private
   */
  _getVersionNotFound() {
    return _utils2.ErrorCode.getNotFound(_constants.API_ERROR.VERSION_NOT_EXIST);
  }

  /**
   * Return file no available
   * @return {String}
   * @private
   */
  _getFileNotAvailable() {
    return _utils2.ErrorCode.getNotFound('no such file available');
  }

  /**
   * Update the package metadata, tags and attachments (tarballs).
   * Note: Currently supports unpublishing and deprecation.
   * @param {*} name
   * @param {*} incomingPkg
   * @param {*} revision
   * @param {*} callback
   * @return {Function}
   */
  changePackage(name, incomingPkg, revision, callback) {
    if (!(0, _utils2.isObject)(incomingPkg.versions) || !(0, _utils2.isObject)(incomingPkg[_constants.DIST_TAGS])) {
      this.logger.error({
        name
      }, `changePackage bad data for @{name}`);
      return callback(_utils2.ErrorCode.getBadData());
    }
    debug('changePackage udapting package for %o', name);
    this._updatePackage(name, (localData, cb) => {
      for (const version in localData.versions) {
        const incomingVersion = incomingPkg.versions[version];
        if (_lodash.default.isNil(incomingVersion)) {
          this.logger.info({
            name: name,
            version: version
          }, 'unpublishing @{name}@@{version}');

          // FIXME: I prefer return a new object rather mutate the metadata
          delete localData.versions[version];
          delete localData.time[version];
          for (const file in localData._attachments) {
            if (localData._attachments[file].version === version) {
              delete localData._attachments[file].version;
            }
          }
        } else if (Object.prototype.hasOwnProperty.call(incomingVersion, 'deprecated')) {
          const incomingDeprecated = incomingVersion.deprecated;
          if (incomingDeprecated != localData.versions[version].deprecated) {
            if (!incomingDeprecated) {
              this.logger.info({
                name: name,
                version: version
              }, 'undeprecating @{name}@@{version}');
              delete localData.versions[version].deprecated;
            } else {
              this.logger.info({
                name: name,
                version: version
              }, 'deprecating @{name}@@{version}');
              localData.versions[version].deprecated = incomingDeprecated;
            }
            localData.time.modified = new Date().toISOString();
          }
        }
      }
      localData[_constants.USERS] = incomingPkg[_constants.USERS];
      localData[_constants.DIST_TAGS] = incomingPkg[_constants.DIST_TAGS];
      cb(null);
    }, function (err) {
      if (err) {
        return callback(err);
      }
      callback();
    });
  }
  /**
   * Remove a tarball.
   * @param {*} name
   * @param {*} filename
   * @param {*} revision
   * @param {*} callback
   */
  removeTarball(name, filename, revision, callback) {
    (0, _assert.default)((0, _utils.validateName)(filename));
    this._updatePackage(name, (data, cb) => {
      if (data._attachments[filename]) {
        delete data._attachments[filename];
        cb(null);
      } else {
        cb(this._getFileNotAvailable());
      }
    }, err => {
      if (err) {
        return callback(err);
      }
      const storage = this._getLocalStorage(name);
      if (storage) {
        storage.deletePackage(filename, callback);
      }
    });
  }

  /**
   * Add a tarball.
   * @param {String} name
   * @param {String} filename
   * @return {Stream}
   */
  addTarball(name, filename) {
    (0, _assert.default)((0, _utils.validateName)(filename));
    let length = 0;
    const shaOneHash = (0, _utils.createTarballHash)();
    const uploadStream = new _streams.UploadTarball({});
    const _transform = uploadStream._transform;
    const storage = this._getLocalStorage(name);
    uploadStream.abort = function () {};
    uploadStream.done = function () {};
    uploadStream._transform = function (data, ...args) {
      shaOneHash.update(data);
      // measure the length for validation reasons
      length += data.length;
      const appliedData = [data, ...args];
      // FIXME: not sure about this approach, tsc complains
      // @ts-ignore
      _transform.apply(uploadStream, appliedData);
    };
    if (name === '__proto__') {
      process.nextTick(() => {
        uploadStream.emit('error', _utils2.ErrorCode.getForbidden());
      });
      return uploadStream;
    }
    if (!storage) {
      process.nextTick(() => {
        uploadStream.emit('error', "can't upload this package");
      });
      return uploadStream;
    }
    const writeStream = storage.writeTarball(filename);
    writeStream.on('error', err => {
      // @ts-ignore
      if (err.code === _constants.STORAGE.FILE_EXIST_ERROR || err.code === _constants.HTTP_STATUS.CONFLICT) {
        uploadStream.emit('error', _utils2.ErrorCode.getConflict());
        uploadStream.abort();
        // @ts-ignore
      } else if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
        // check if package exists to throw an appropriate message
        this.getPackageMetadata(name, function (_err, _res) {
          if (_err) {
            uploadStream.emit('error', _err);
          } else {
            uploadStream.emit('error', err);
          }
        });
      } else {
        uploadStream.emit('error', err);
      }
    });
    writeStream.on('open', function () {
      // re-emitting open because it's handled in storage.js
      uploadStream.emit('open');
    });
    writeStream.on('success', () => {
      this._updatePackage(name, function updater(data, cb) {
        data._attachments[filename] = {
          shasum: shaOneHash.digest('hex')
        };
        cb(null);
      }, function (err) {
        if (err) {
          uploadStream.emit('error', err);
        } else {
          uploadStream.emit('success');
        }
      });
    });
    uploadStream.abort = function () {
      writeStream.abort();
    };
    uploadStream.done = function () {
      if (!length) {
        uploadStream.emit('error', _utils2.ErrorCode.getBadData('refusing to accept zero-length file'));
        writeStream.abort();
      } else {
        writeStream.done();
      }
    };
    uploadStream.pipe(writeStream);
    return uploadStream;
  }

  /**
   * Get a tarball.
   * @param {*} name
   * @param {*} filename
   * @return {ReadTarball}
   */
  getTarball(name, filename) {
    (0, _assert.default)((0, _utils.validateName)(filename));
    const storage = this._getLocalStorage(name);
    if (_lodash.default.isNil(storage)) {
      return this._createFailureStreamResponse();
    }
    return this._streamSuccessReadTarBall(storage, filename);
  }

  /**
   * Return a stream that emits a read failure.
   * @private
   * @return {ReadTarball}
   */
  _createFailureStreamResponse() {
    const stream = new _streams.ReadTarball({});
    process.nextTick(() => {
      stream.emit('error', this._getFileNotAvailable());
    });
    return stream;
  }

  /**
   * Return a stream that emits the tarball data
   * @param {Object} storage
   * @param {String} filename
   * @private
   * @return {ReadTarball}
   */
  _streamSuccessReadTarBall(storage, filename) {
    const stream = new _streams.ReadTarball({});
    const readTarballStream = storage.readTarball(filename);
    const e404 = _utils2.ErrorCode.getNotFound;
    stream.abort = function () {
      if (_lodash.default.isNil(readTarballStream) === false) {
        readTarballStream.abort();
      }
    };
    readTarballStream.on('error', function (err) {
      // @ts-ignore
      if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
        stream.emit('error', e404('no such file available'));
      } else {
        stream.emit('error', err);
      }
    });
    readTarballStream.on('content-length', function (content) {
      stream.emit('content-length', content);
    });
    readTarballStream.on('open', function () {
      // re-emitting open because it's handled in storage.js
      stream.emit('open');
      readTarballStream.pipe(stream);
    });
    return stream;
  }

  /**
   * Retrieve a package by name.
   * @param {*} name
   * @param {*} callback
   * @return {Function}
   */
  getPackageMetadata(name, callback = () => {}) {
    const storage = this._getLocalStorage(name);
    if (_lodash.default.isNil(storage)) {
      return callback(_utils2.ErrorCode.getNotFound());
    }
    this._readPackage(name, storage, callback);
  }

  /**
   * Search a local package.
   * @param {*} startKey
   * @param {*} options
   * @return {Function}
   */
  search(startKey, options) {
    const stream = new _streams.ReadTarball({
      objectMode: true
    });
    this._searchEachPackage((item, cb) => {
      // @ts-ignore
      if (item.time > parseInt(startKey, 10)) {
        this.getPackageMetadata(item.name, (err, data) => {
          if (err) {
            return cb(err);
          }

          // @ts-ignore
          const time = new Date(item.time).toISOString();
          const result = (0, _storageUtils.prepareSearchPackage)(data, time);
          if (_lodash.default.isNil(result) === false) {
            stream.push(result);
          }
          cb(null);
        });
      } else {
        cb(null);
      }
    }, function onEnd(err) {
      if (err) {
        stream.emit('error', err);
        return;
      }
      stream.end();
    });
    return stream;
  }

  /**
   * Retrieve a wrapper that provide access to the package location.
   * @param {Object} pkgName package name.
   * @return {Object}
   */
  _getLocalStorage(pkgName) {
    return this.storagePlugin.getPackageStorage(pkgName);
  }

  /**
   * Read a json file from storage.
   * @param {Object} storage
   * @param {Function} callback
   */
  _readPackage(name, storage, callback) {
    storage.readPackage(name, (err, result) => {
      if (err) {
        if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
          return callback(_utils2.ErrorCode.getNotFound());
        }
        return callback(this._internalError(err, _constants.STORAGE.PACKAGE_FILE_NAME, 'error reading'));
      }
      callback(err, (0, _storageUtils.normalizePackage)(result));
    });
  }

  /**
   * Walks through each package and calls `on_package` on them.
   * @param {*} onPackage
   * @param {*} onEnd
   */
  _searchEachPackage(onPackage, onEnd) {
    // save wait whether plugin still do not support search functionality
    if (_lodash.default.isNil(this.storagePlugin.search)) {
      this.logger.warn('plugin search not implemented yet');
      onEnd();
    } else {
      this.storagePlugin.search(onPackage, onEnd, _utils.validateName);
    }
  }

  /**
   * Retrieve either a previous created local package or a boilerplate.
   * @param {*} pkgName
   * @param {*} callback
   * @return {Function}
   */
  _readCreatePackage(pkgName, callback) {
    const storage = this._getLocalStorage(pkgName);
    if (_lodash.default.isNil(storage)) {
      this._createNewPackage(pkgName, callback);
      return;
    }
    storage.readPackage(pkgName, (err, data) => {
      // TODO: race condition
      if (_lodash.default.isNil(err) === false) {
        if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
          data = (0, _storageUtils.generatePackageTemplate)(pkgName);
        } else {
          return callback(this._internalError(err, _constants.STORAGE.PACKAGE_FILE_NAME, 'error reading'));
        }
      }
      callback(null, (0, _storageUtils.normalizePackage)(data));
    });
  }
  _createNewPackage(name, callback) {
    return callback(null, (0, _storageUtils.normalizePackage)((0, _storageUtils.generatePackageTemplate)(name)));
  }

  /**
   * Handle internal error
   * @param {*} err
   * @param {*} file
   * @param {*} message
   * @return {Object} Error instance
   */
  _internalError(err, file, message) {
    this.logger.error({
      err: err,
      file: file
    }, `${message}  @{file}: @{!err.message}`);
    return _utils2.ErrorCode.getInternalError();
  }

  /**
   * @param {*} name package name
   * @param {*} updateHandler function(package, cb) - update function
   * @param {*} callback callback that gets invoked after it's all updated
   * @return {Function}
   */
  _updatePackage(name, updateHandler, callback) {
    const storage = this._getLocalStorage(name);
    if (!storage) {
      return callback(_utils2.ErrorCode.getNotFound());
    }
    storage.updatePackage(name, updateHandler, this._writePackage.bind(this), _storageUtils.normalizePackage, callback);
  }

  /**
   * Update the revision (_rev) string for a package.
   * @param {*} name
   * @param {*} json
   * @param {*} callback
   * @return {Function}
   */
  _writePackage(name, json, callback) {
    const storage = this._getLocalStorage(name);
    if (_lodash.default.isNil(storage)) {
      return callback();
    }
    storage.savePackage(name, this._setDefaultRevision(json), callback);
  }
  _setDefaultRevision(json) {
    // calculate revision from couch db
    if (_lodash.default.isString(json._rev) === false) {
      json._rev = _constants.STORAGE.DEFAULT_REVISION;
    }

    // this is intended in debug mode we do not want modify the store revision
    if (_lodash.default.isNil(this.config._debug)) {
      json._rev = (0, _storageUtils.generateRevision)(json._rev);
    }
    return json;
  }
  _deleteAttachments(storage, attachments, callback) {
    debug('[storage/_deleteAttachments] delete attachments total: %o', attachments === null || attachments === void 0 ? void 0 : attachments.length);
    const unlinkNext = function (cb) {
      if (_lodash.default.isEmpty(attachments)) {
        return cb();
      }
      const attachment = attachments.shift();
      storage.deletePackage(attachment, function () {
        unlinkNext(cb);
      });
    };
    unlinkNext(function () {
      // try to unlink the directory, but ignore errors because it can fail
      storage.removePackage(function (err) {
        callback(err);
      });
    });
  }

  /**
   * Ensure the dist file remains as the same protocol
   * @param {Object} hash metadata
   * @param {String} upLinkKey registry key
   * @private
   */
  _updateUplinkToRemoteProtocol(hash, upLinkKey) {
    // if we got this information from a known registry,
    // use the same protocol for the tarball
    //
    // see https://github.com/rlidwka/sinopia/issues/166
    const tarballUrl = _url.default.parse(hash.url);
    const uplinkUrl = _url.default.parse(this.config.uplinks[upLinkKey].url);
    if (uplinkUrl.host === tarballUrl.host) {
      tarballUrl.protocol = uplinkUrl.protocol;
      hash.registry = upLinkKey;
      hash.url = _url.default.format(tarballUrl);
    }
  }
  async getSecret(config) {
    const secretKey = await this.storagePlugin.getSecret();
    return this.storagePlugin.setSecret(config.checkSecretKey(secretKey));
  }
  _loadStorage(config, logger) {
    const Storage = this._loadStorePlugin();
    if (_lodash.default.isNil(Storage)) {
      (0, _assert.default)(this.config.storage, 'CONFIG: storage path not defined');
      return new _localStorage.default(this.config, logger);
    }
    return Storage;
  }
  _loadStorePlugin() {
    const plugin_params = {
      config: this.config,
      logger: this.logger
    };

    // eslint-disable-next-line max-len
    const plugins = (0, _pluginLoader.default)(this.config, this.config.store, plugin_params, plugin => {
      return plugin.getPackageStorage;
    });
    return _lodash.default.head(plugins);
  }
  saveToken(token) {
    if (_lodash.default.isFunction(this.storagePlugin.saveToken) === false) {
      return Promise.reject(_utils2.ErrorCode.getCode(_constants.HTTP_STATUS.SERVICE_UNAVAILABLE, _constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }
    return this.storagePlugin.saveToken(token);
  }
  deleteToken(user, tokenKey) {
    if (_lodash.default.isFunction(this.storagePlugin.deleteToken) === false) {
      return Promise.reject(_utils2.ErrorCode.getCode(_constants.HTTP_STATUS.SERVICE_UNAVAILABLE, _constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }
    return this.storagePlugin.deleteToken(user, tokenKey);
  }
  readTokens(filter) {
    if (_lodash.default.isFunction(this.storagePlugin.readTokens) === false) {
      return Promise.reject(_utils2.ErrorCode.getCode(_constants.HTTP_STATUS.SERVICE_UNAVAILABLE, _constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }
    return this.storagePlugin.readTokens(filter);
  }
}
var _default = LocalStorage;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWJ1ZyIsImJ1aWxEZWJ1ZyIsIkxvY2FsU3RvcmFnZSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwibG9nZ2VyIiwic3RvcmFnZVBsdWdpbiIsIl9sb2FkU3RvcmFnZSIsImFkZFBhY2thZ2UiLCJuYW1lIiwicGtnIiwiY2FsbGJhY2siLCJzdG9yYWdlIiwiX2dldExvY2FsU3RvcmFnZSIsIl8iLCJpc05pbCIsIkVycm9yQ29kZSIsImdldE5vdEZvdW5kIiwiY3JlYXRlUGFja2FnZSIsImdlbmVyYXRlUGFja2FnZVRlbXBsYXRlIiwiZXJyIiwiaXNOdWxsIiwiY29kZSIsIlNUT1JBR0UiLCJGSUxFX0VYSVNUX0VSUk9SIiwiSFRUUF9TVEFUVVMiLCJDT05GTElDVCIsImdldENvbmZsaWN0IiwibGF0ZXN0IiwiZ2V0TGF0ZXN0VmVyc2lvbiIsInZlcnNpb25zIiwicmVtb3ZlUGFja2FnZSIsInJlYWRQYWNrYWdlIiwiZGF0YSIsIk5PX1NVQ0hfRklMRV9FUlJPUiIsIk5PVF9GT1VORCIsIm5vcm1hbGl6ZVBhY2thZ2UiLCJyZW1vdmUiLCJyZW1vdmVGYWlsZWQiLCJlcnJvciIsImdldEJhZERhdGEiLCJtZXNzYWdlIiwiZGVsZXRlUGFja2FnZSIsIlBBQ0tBR0VfRklMRV9OQU1FIiwiYXR0YWNobWVudHMiLCJPYmplY3QiLCJrZXlzIiwiX2F0dGFjaG1lbnRzIiwiX2RlbGV0ZUF0dGFjaG1lbnRzIiwidXBkYXRlVmVyc2lvbnMiLCJwYWNrYWdlSW5mbyIsIl9yZWFkQ3JlYXRlUGFja2FnZSIsInBhY2thZ2VMb2NhbEpzb24iLCJjaGFuZ2UiLCJyZWFkbWUiLCJnZXRMYXRlc3RSZWFkbWUiLCJ2ZXJzaW9uSWQiLCJ2ZXJzaW9uIiwiY2xlYW5VcFJlYWRtZSIsImNvbnRyaWJ1dG9ycyIsIm5vcm1hbGl6ZUNvbnRyaWJ1dG9ycyIsImRpc3QiLCJ0YXJiYWxsIiwidXJsT2JqZWN0IiwiVXJsTm9kZSIsInBhcnNlIiwiZmlsZW5hbWUiLCJwYXRobmFtZSIsInJlcGxhY2UiLCJfZGlzdGZpbGVzIiwiaGFzaCIsInVybCIsInNoYSIsInNoYXN1bSIsInVwTGluayIsIlN5bWJvbCIsImZvciIsIl91cGRhdGVVcGxpbmtUb1JlbW90ZVByb3RvY29sIiwidGFnIiwiRElTVF9UQUdTIiwidXAiLCJfdXBsaW5rcyIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm5lZWRfY2hhbmdlIiwiaXNPYmplY3QiLCJldGFnIiwiZmV0Y2hlZCIsImlzRXF1YWwiLCJ0aW1lIiwiX3dyaXRlUGFja2FnZSIsImFkZFZlcnNpb24iLCJtZXRhZGF0YSIsIl91cGRhdGVQYWNrYWdlIiwiY2IiLCJoYXNWZXJzaW9uIiwiaXNTdHJpbmciLCJlcnJvck1lc3NhZ2UiLCJnZXRCYWRSZXF1ZXN0IiwiY3VycmVudERhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjcmVhdGVkIiwidGFnVmVyc2lvbiIsImFkZCIsImFkZEZhaWxlZCIsIm1lcmdlVGFncyIsInBrZ05hbWUiLCJ0YWdzIiwiX2dldFZlcnNpb25Ob3RGb3VuZCIsIkFQSV9FUlJPUiIsIlZFUlNJT05fTk9UX0VYSVNUIiwiX2dldEZpbGVOb3RBdmFpbGFibGUiLCJjaGFuZ2VQYWNrYWdlIiwiaW5jb21pbmdQa2ciLCJyZXZpc2lvbiIsImxvY2FsRGF0YSIsImluY29taW5nVmVyc2lvbiIsImluZm8iLCJmaWxlIiwiaW5jb21pbmdEZXByZWNhdGVkIiwiZGVwcmVjYXRlZCIsIm1vZGlmaWVkIiwiVVNFUlMiLCJyZW1vdmVUYXJiYWxsIiwiYXNzZXJ0IiwidmFsaWRhdGVOYW1lIiwiYWRkVGFyYmFsbCIsImxlbmd0aCIsInNoYU9uZUhhc2giLCJjcmVhdGVUYXJiYWxsSGFzaCIsInVwbG9hZFN0cmVhbSIsIlVwbG9hZFRhcmJhbGwiLCJfdHJhbnNmb3JtIiwiYWJvcnQiLCJkb25lIiwiYXJncyIsInVwZGF0ZSIsImFwcGxpZWREYXRhIiwiYXBwbHkiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJlbWl0IiwiZ2V0Rm9yYmlkZGVuIiwid3JpdGVTdHJlYW0iLCJ3cml0ZVRhcmJhbGwiLCJvbiIsImdldFBhY2thZ2VNZXRhZGF0YSIsIl9lcnIiLCJfcmVzIiwidXBkYXRlciIsImRpZ2VzdCIsInBpcGUiLCJnZXRUYXJiYWxsIiwiX2NyZWF0ZUZhaWx1cmVTdHJlYW1SZXNwb25zZSIsIl9zdHJlYW1TdWNjZXNzUmVhZFRhckJhbGwiLCJzdHJlYW0iLCJSZWFkVGFyYmFsbCIsInJlYWRUYXJiYWxsU3RyZWFtIiwicmVhZFRhcmJhbGwiLCJlNDA0IiwiY29udGVudCIsIl9yZWFkUGFja2FnZSIsInNlYXJjaCIsInN0YXJ0S2V5Iiwib3B0aW9ucyIsIm9iamVjdE1vZGUiLCJfc2VhcmNoRWFjaFBhY2thZ2UiLCJpdGVtIiwicGFyc2VJbnQiLCJyZXN1bHQiLCJwcmVwYXJlU2VhcmNoUGFja2FnZSIsInB1c2giLCJvbkVuZCIsImVuZCIsImdldFBhY2thZ2VTdG9yYWdlIiwiX2ludGVybmFsRXJyb3IiLCJvblBhY2thZ2UiLCJ3YXJuIiwiX2NyZWF0ZU5ld1BhY2thZ2UiLCJnZXRJbnRlcm5hbEVycm9yIiwidXBkYXRlSGFuZGxlciIsInVwZGF0ZVBhY2thZ2UiLCJiaW5kIiwianNvbiIsInNhdmVQYWNrYWdlIiwiX3NldERlZmF1bHRSZXZpc2lvbiIsIl9yZXYiLCJERUZBVUxUX1JFVklTSU9OIiwiX2RlYnVnIiwiZ2VuZXJhdGVSZXZpc2lvbiIsInVubGlua05leHQiLCJpc0VtcHR5IiwiYXR0YWNobWVudCIsInNoaWZ0IiwidXBMaW5rS2V5IiwidGFyYmFsbFVybCIsInVwbGlua1VybCIsInVwbGlua3MiLCJob3N0IiwicHJvdG9jb2wiLCJyZWdpc3RyeSIsImZvcm1hdCIsImdldFNlY3JldCIsInNlY3JldEtleSIsInNldFNlY3JldCIsImNoZWNrU2VjcmV0S2V5IiwiU3RvcmFnZSIsIl9sb2FkU3RvcmVQbHVnaW4iLCJMb2NhbERhdGFiYXNlIiwicGx1Z2luX3BhcmFtcyIsInBsdWdpbnMiLCJsb2FkUGx1Z2luIiwic3RvcmUiLCJwbHVnaW4iLCJoZWFkIiwic2F2ZVRva2VuIiwidG9rZW4iLCJpc0Z1bmN0aW9uIiwiUHJvbWlzZSIsInJlamVjdCIsImdldENvZGUiLCJTRVJWSUNFX1VOQVZBSUxBQkxFIiwiU1VQUE9SVF9FUlJPUlMiLCJQTFVHSU5fTUlTU0lOR19JTlRFUkZBQ0UiLCJkZWxldGVUb2tlbiIsInVzZXIiLCJ0b2tlbktleSIsInJlYWRUb2tlbnMiLCJmaWx0ZXIiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL2xvY2FsLXN0b3JhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IGJ1aWxEZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFVybE5vZGUgZnJvbSAndXJsJztcblxuaW1wb3J0IExvY2FsRGF0YWJhc2UgZnJvbSAnQHZlcmRhY2Npby9sb2NhbC1zdG9yYWdlJztcbmltcG9ydCB7IFJlYWRUYXJiYWxsLCBVcGxvYWRUYXJiYWxsIH0gZnJvbSAnQHZlcmRhY2Npby9zdHJlYW1zJztcbmltcG9ydCB7XG4gIEF1dGhvcixcbiAgQ2FsbGJhY2ssXG4gIENhbGxiYWNrQWN0aW9uLFxuICBDb25maWcsXG4gIERpc3RGaWxlLFxuICBJUGFja2FnZVN0b3JhZ2UsXG4gIElQbHVnaW5TdG9yYWdlLFxuICBJUmVhZFRhcmJhbGwsXG4gIElVcGxvYWRUYXJiYWxsLFxuICBMb2dnZXIsXG4gIE1lcmdlVGFncyxcbiAgUGFja2FnZSxcbiAgU3RvcmFnZVVwZGF0ZUNhbGxiYWNrLFxuICBUb2tlbixcbiAgVG9rZW5GaWx0ZXIsXG4gIFZlcnNpb24sXG4gIG9uRW5kU2VhcmNoUGFja2FnZSxcbiAgb25TZWFyY2hQYWNrYWdlLFxufSBmcm9tICdAdmVyZGFjY2lvL3R5cGVzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVRhcmJhbGxIYXNoLFxuICBnZXRMYXRlc3RWZXJzaW9uLFxuICBub3JtYWxpemVDb250cmlidXRvcnMsXG4gIHZhbGlkYXRlTmFtZSxcbn0gZnJvbSAnQHZlcmRhY2Npby91dGlscyc7XG5cbmltcG9ydCBsb2FkUGx1Z2luIGZyb20gJy4uL2xpYi9wbHVnaW4tbG9hZGVyJztcbmltcG9ydCB7IElTdG9yYWdlLCBTdHJpbmdWYWx1ZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEFQSV9FUlJPUiwgRElTVF9UQUdTLCBIVFRQX1NUQVRVUywgU1RPUkFHRSwgU1VQUE9SVF9FUlJPUlMsIFVTRVJTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtcbiAgY2xlYW5VcFJlYWRtZSxcbiAgZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUsXG4gIGdlbmVyYXRlUmV2aXNpb24sXG4gIGdldExhdGVzdFJlYWRtZSxcbiAgbm9ybWFsaXplUGFja2FnZSxcbn0gZnJvbSAnLi9zdG9yYWdlLXV0aWxzJztcbmltcG9ydCB7IHByZXBhcmVTZWFyY2hQYWNrYWdlIH0gZnJvbSAnLi9zdG9yYWdlLXV0aWxzJztcbmltcG9ydCB7IEVycm9yQ29kZSwgaXNPYmplY3QsIHRhZ1ZlcnNpb24gfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgZGVidWcgPSBidWlsRGVidWcoJ3ZlcmRhY2Npbzpsb2NhbC1zdG9yYWdlJyk7XG4vKipcbiAqIEltcGxlbWVudHMgU3RvcmFnZSBpbnRlcmZhY2UgKHNhbWUgZm9yIHN0b3JhZ2UuanMsIGxvY2FsLXN0b3JhZ2UuanMsIHVwLXN0b3JhZ2UuanMpLlxuICovXG5jbGFzcyBMb2NhbFN0b3JhZ2UgaW1wbGVtZW50cyBJU3RvcmFnZSB7XG4gIHB1YmxpYyBjb25maWc6IENvbmZpZztcbiAgcHVibGljIHN0b3JhZ2VQbHVnaW46IElQbHVnaW5TdG9yYWdlPENvbmZpZz47XG4gIHB1YmxpYyBsb2dnZXI6IExvZ2dlcjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoY29uZmlnOiBDb25maWcsIGxvZ2dlcjogTG9nZ2VyKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5zdG9yYWdlUGx1Z2luID0gdGhpcy5fbG9hZFN0b3JhZ2UoY29uZmlnLCBsb2dnZXIpO1xuICB9XG5cbiAgcHVibGljIGFkZFBhY2thZ2UobmFtZTogc3RyaW5nLCBwa2c6IFBhY2thZ2UsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIGNvbnN0IHN0b3JhZ2U6IGFueSA9IHRoaXMuX2dldExvY2FsU3RvcmFnZShuYW1lKTtcblxuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKCd0aGlzIHBhY2thZ2UgY2Fubm90IGJlIGFkZGVkJykpO1xuICAgIH1cblxuICAgIHN0b3JhZ2UuY3JlYXRlUGFja2FnZShuYW1lLCBnZW5lcmF0ZVBhY2thZ2VUZW1wbGF0ZShuYW1lKSwgKGVycikgPT4ge1xuICAgICAgLy8gRklYTUU6IGl0IHdpbGwgYmUgZml4ZWQgaGVyZSBodHRwczovL2dpdGh1Yi5jb20vdmVyZGFjY2lvL3ZlcmRhY2Npby9wdWxsLzEzNjBcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmIChcbiAgICAgICAgXy5pc051bGwoZXJyKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgKGVyci5jb2RlID09PSBTVE9SQUdFLkZJTEVfRVhJU1RfRVJST1IgfHwgZXJyLmNvZGUgPT09IEhUVFBfU1RBVFVTLkNPTkZMSUNUKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0Q29uZmxpY3QoKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhdGVzdCA9IGdldExhdGVzdFZlcnNpb24ocGtnKTtcbiAgICAgIGlmIChfLmlzTmlsKGxhdGVzdCkgPT09IGZhbHNlICYmIHBrZy52ZXJzaW9uc1tsYXRlc3RdKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBwa2cudmVyc2lvbnNbbGF0ZXN0XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBwYWNrYWdlLlxuICAgKiBAcGFyYW0geyp9IG5hbWVcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIHB1YmxpYyByZW1vdmVQYWNrYWdlKG5hbWU6IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3Qgc3RvcmFnZTogYW55ID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKG5hbWUpO1xuICAgIGRlYnVnKCdbc3RvcmFnZV0gcmVtb3ZpbmcgcGFja2FnZSAlbycsIG5hbWUpO1xuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKCkpO1xuICAgIH1cblxuICAgIHN0b3JhZ2UucmVhZFBhY2thZ2UobmFtZSwgKGVyciwgZGF0YTogUGFja2FnZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKF8uaXNOaWwoZXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBTVE9SQUdFLk5PX1NVQ0hfRklMRV9FUlJPUiB8fCBlcnIuY29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXROb3RGb3VuZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IG5vcm1hbGl6ZVBhY2thZ2UoZGF0YSk7XG5cbiAgICAgIHRoaXMuc3RvcmFnZVBsdWdpbi5yZW1vdmUobmFtZSwgKHJlbW92ZUZhaWxlZDogRXJyb3IpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHJlbW92ZUZhaWxlZCkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBoYXBwZW4gd2hlbiBkYXRhYmFzZSBpcyBsb2NrZWRcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIHsgbmFtZSB9LFxuICAgICAgICAgICAgYFtzdG9yYWdlL3JlbW92ZVBhY2thZ2VdIHRoZSBkYXRhYmFzZSBpcyBsb2NrZWQsIHJlbW92ZWQgaGFzIGZhaWxlZCBmb3IgQHtuYW1lfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0QmFkRGF0YShyZW1vdmVGYWlsZWQubWVzc2FnZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RvcmFnZS5kZWxldGVQYWNrYWdlKFNUT1JBR0UuUEFDS0FHRV9GSUxFX05BTUUsIChlcnIpOiB2b2lkID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXR0YWNobWVudHMgPSBPYmplY3Qua2V5cyhkYXRhLl9hdHRhY2htZW50cyk7XG5cbiAgICAgICAgICB0aGlzLl9kZWxldGVBdHRhY2htZW50cyhzdG9yYWdlLCBhdHRhY2htZW50cywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplIHJlbW90ZSBwYWNrYWdlIGluZm8gd2l0aCB0aGUgbG9jYWwgb25lXG4gICAqIEBwYXJhbSB7Kn0gbmFtZVxuICAgKiBAcGFyYW0geyp9IHBhY2thZ2VJbmZvXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVWZXJzaW9ucyhuYW1lOiBzdHJpbmcsIHBhY2thZ2VJbmZvOiBQYWNrYWdlLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9yZWFkQ3JlYXRlUGFja2FnZShuYW1lLCAoZXJyLCBwYWNrYWdlTG9jYWxKc29uKTogdm9pZCA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICBsZXQgY2hhbmdlID0gZmFsc2U7XG4gICAgICAvLyB1cGRhdGluZyByZWFkbWVcbiAgICAgIHBhY2thZ2VMb2NhbEpzb24ucmVhZG1lID0gZ2V0TGF0ZXN0UmVhZG1lKHBhY2thZ2VJbmZvKTtcbiAgICAgIGlmIChwYWNrYWdlSW5mby5yZWFkbWUgIT09IHBhY2thZ2VMb2NhbEpzb24ucmVhZG1lKSB7XG4gICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHZlcnNpb25JZCBpbiBwYWNrYWdlSW5mby52ZXJzaW9ucykge1xuICAgICAgICBpZiAoXy5pc05pbChwYWNrYWdlTG9jYWxKc29uLnZlcnNpb25zW3ZlcnNpb25JZF0pKSB7XG4gICAgICAgICAgbGV0IHZlcnNpb24gPSBwYWNrYWdlSW5mby52ZXJzaW9uc1t2ZXJzaW9uSWRdO1xuXG4gICAgICAgICAgLy8gd2UgZG9uJ3Qga2VlcCByZWFkbWUgZm9yIHBhY2thZ2UgdmVyc2lvbnMsXG4gICAgICAgICAgLy8gb25seSBvbmUgcmVhZG1lIHBlciBwYWNrYWdlXG4gICAgICAgICAgdmVyc2lvbiA9IGNsZWFuVXBSZWFkbWUodmVyc2lvbik7XG4gICAgICAgICAgdmVyc2lvbi5jb250cmlidXRvcnMgPSBub3JtYWxpemVDb250cmlidXRvcnModmVyc2lvbi5jb250cmlidXRvcnMgYXMgQXV0aG9yW10pO1xuXG4gICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICBwYWNrYWdlTG9jYWxKc29uLnZlcnNpb25zW3ZlcnNpb25JZF0gPSB2ZXJzaW9uO1xuXG4gICAgICAgICAgaWYgKHZlcnNpb24uZGlzdCAmJiB2ZXJzaW9uLmRpc3QudGFyYmFsbCkge1xuICAgICAgICAgICAgY29uc3QgdXJsT2JqZWN0OiBhbnkgPSBVcmxOb2RlLnBhcnNlKHZlcnNpb24uZGlzdC50YXJiYWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gdXJsT2JqZWN0LnBhdGhuYW1lLnJlcGxhY2UoL14uKlxcLy8sICcnKTtcblxuICAgICAgICAgICAgLy8gd2UgZG8gTk9UIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgcmVjb3Jkc1xuICAgICAgICAgICAgaWYgKF8uaXNOaWwocGFja2FnZUxvY2FsSnNvbi5fZGlzdGZpbGVzW2ZpbGVuYW1lXSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgaGFzaDogRGlzdEZpbGUgPSAocGFja2FnZUxvY2FsSnNvbi5fZGlzdGZpbGVzW2ZpbGVuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHZlcnNpb24uZGlzdC50YXJiYWxsLFxuICAgICAgICAgICAgICAgIHNoYTogdmVyc2lvbi5kaXN0LnNoYXN1bSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8qIGVzbGludCBzcGFjZWQtY29tbWVudDogMCAqL1xuICAgICAgICAgICAgICBjb25zdCB1cExpbms6IHN0cmluZyA9IHZlcnNpb25bU3ltYm9sLmZvcignX192ZXJkYWNjaW9fdXBsaW5rJyldO1xuXG4gICAgICAgICAgICAgIGlmIChfLmlzTmlsKHVwTGluaykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVXBsaW5rVG9SZW1vdGVQcm90b2NvbChoYXNoLCB1cExpbmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgdGFnIGluIHBhY2thZ2VJbmZvW0RJU1RfVEFHU10pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFwYWNrYWdlTG9jYWxKc29uW0RJU1RfVEFHU11bdGFnXSB8fFxuICAgICAgICAgIHBhY2thZ2VMb2NhbEpzb25bRElTVF9UQUdTXVt0YWddICE9PSBwYWNrYWdlSW5mb1tESVNUX1RBR1NdW3RhZ11cbiAgICAgICAgKSB7XG4gICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICBwYWNrYWdlTG9jYWxKc29uW0RJU1RfVEFHU11bdGFnXSA9IHBhY2thZ2VJbmZvW0RJU1RfVEFHU11bdGFnXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHVwIGluIHBhY2thZ2VJbmZvLl91cGxpbmtzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFja2FnZUluZm8uX3VwbGlua3MsIHVwKSkge1xuICAgICAgICAgIGNvbnN0IG5lZWRfY2hhbmdlID1cbiAgICAgICAgICAgICFpc09iamVjdChwYWNrYWdlTG9jYWxKc29uLl91cGxpbmtzW3VwXSkgfHxcbiAgICAgICAgICAgIHBhY2thZ2VJbmZvLl91cGxpbmtzW3VwXS5ldGFnICE9PSBwYWNrYWdlTG9jYWxKc29uLl91cGxpbmtzW3VwXS5ldGFnIHx8XG4gICAgICAgICAgICBwYWNrYWdlSW5mby5fdXBsaW5rc1t1cF0uZmV0Y2hlZCAhPT0gcGFja2FnZUxvY2FsSnNvbi5fdXBsaW5rc1t1cF0uZmV0Y2hlZDtcblxuICAgICAgICAgIGlmIChuZWVkX2NoYW5nZSkge1xuICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhY2thZ2VMb2NhbEpzb24uX3VwbGlua3NbdXBdID0gcGFja2FnZUluZm8uX3VwbGlua3NbdXBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3RpbWUnIGluIHBhY2thZ2VJbmZvICYmICFfLmlzRXF1YWwocGFja2FnZUxvY2FsSnNvbi50aW1lLCBwYWNrYWdlSW5mby50aW1lKSkge1xuICAgICAgICBwYWNrYWdlTG9jYWxKc29uLnRpbWUgPSBwYWNrYWdlSW5mby50aW1lO1xuICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgIGRlYnVnKCd1cGRhdGluZyBwYWNrYWdlICVvIGluZm8nLCBuYW1lKTtcbiAgICAgICAgdGhpcy5fd3JpdGVQYWNrYWdlKG5hbWUsIHBhY2thZ2VMb2NhbEpzb24sIGZ1bmN0aW9uIChlcnIpOiB2b2lkIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIsIHBhY2thZ2VMb2NhbEpzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHBhY2thZ2VMb2NhbEpzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyB2ZXJzaW9uIHRvIGEgcHJldmlvdXMgbG9jYWwgcGFja2FnZS5cbiAgICogQHBhcmFtIHsqfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmVyc2lvblxuICAgKiBAcGFyYW0geyp9IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7Kn0gdGFnXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBhZGRWZXJzaW9uKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICB2ZXJzaW9uOiBzdHJpbmcsXG4gICAgbWV0YWRhdGE6IFZlcnNpb24sXG4gICAgdGFnOiBTdHJpbmdWYWx1ZSxcbiAgICBjYWxsYmFjazogQ2FsbGJhY2tBY3Rpb25cbiAgKTogdm9pZCB7XG4gICAgdGhpcy5fdXBkYXRlUGFja2FnZShcbiAgICAgIG5hbWUsXG4gICAgICAoZGF0YSwgY2I6IENhbGxiYWNrKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIGtlZXAgb25seSBvbmUgcmVhZG1lIHBlciBwYWNrYWdlXG4gICAgICAgIGRhdGEucmVhZG1lID0gbWV0YWRhdGEucmVhZG1lO1xuXG4gICAgICAgIC8vIFRPRE86IGxvZGFzaCByZW1vdmVcbiAgICAgICAgbWV0YWRhdGEgPSBjbGVhblVwUmVhZG1lKG1ldGFkYXRhKTtcbiAgICAgICAgbWV0YWRhdGEuY29udHJpYnV0b3JzID0gbm9ybWFsaXplQ29udHJpYnV0b3JzKG1ldGFkYXRhLmNvbnRyaWJ1dG9ycyBhcyBBdXRob3JbXSk7XG5cbiAgICAgICAgY29uc3QgaGFzVmVyc2lvbiA9IGRhdGEudmVyc2lvbnNbdmVyc2lvbl0gIT0gbnVsbDtcbiAgICAgICAgaWYgKGhhc1ZlcnNpb24pIHtcbiAgICAgICAgICByZXR1cm4gY2IoRXJyb3JDb2RlLmdldENvbmZsaWN0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdXBsb2FkZWQgdGFyYmFsbCBoYXMgYSBkaWZmZXJlbnQgc2hhc3VtLCBpdCdzIHZlcnkgbGlrZWx5IHRoYXQgd2UgaGF2ZSBzb21lIGtpbmQgb2YgZXJyb3JcbiAgICAgICAgaWYgKGlzT2JqZWN0KG1ldGFkYXRhLmRpc3QpICYmIF8uaXNTdHJpbmcobWV0YWRhdGEuZGlzdC50YXJiYWxsKSkge1xuICAgICAgICAgIGNvbnN0IHRhcmJhbGwgPSBtZXRhZGF0YS5kaXN0LnRhcmJhbGwucmVwbGFjZSgvLipcXC8vLCAnJyk7XG5cbiAgICAgICAgICBpZiAoaXNPYmplY3QoZGF0YS5fYXR0YWNobWVudHNbdGFyYmFsbF0pKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIF8uaXNOaWwoZGF0YS5fYXR0YWNobWVudHNbdGFyYmFsbF0uc2hhc3VtKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgXy5pc05pbChtZXRhZGF0YS5kaXN0LnNoYXN1bSkgPT09IGZhbHNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGEuX2F0dGFjaG1lbnRzW3RhcmJhbGxdLnNoYXN1bSAhPSBtZXRhZGF0YS5kaXN0LnNoYXN1bSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBzaGFzdW0gZXJyb3IsICR7ZGF0YS5fYXR0YWNobWVudHNbdGFyYmFsbF0uc2hhc3VtfSAhPSAke21ldGFkYXRhLmRpc3Quc2hhc3VtfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKEVycm9yQ29kZS5nZXRCYWRSZXF1ZXN0KGVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXG4gICAgICAgICAgICAvLyBzb21lIG9sZCBzdG9yYWdlIGRvIG5vdCBoYXZlIHRoaXMgZmllbGQgIzc0MFxuICAgICAgICAgICAgaWYgKF8uaXNOaWwoZGF0YS50aW1lKSkge1xuICAgICAgICAgICAgICBkYXRhLnRpbWUgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YS50aW1lWydtb2RpZmllZCddID0gY3VycmVudERhdGU7XG5cbiAgICAgICAgICAgIGlmICgnY3JlYXRlZCcgaW4gZGF0YS50aW1lID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBkYXRhLnRpbWUuY3JlYXRlZCA9IGN1cnJlbnREYXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhLnRpbWVbdmVyc2lvbl0gPSBjdXJyZW50RGF0ZTtcbiAgICAgICAgICAgIGRhdGEuX2F0dGFjaG1lbnRzW3RhcmJhbGxdLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudmVyc2lvbnNbdmVyc2lvbl0gPSBtZXRhZGF0YTtcbiAgICAgICAgdGFnVmVyc2lvbihkYXRhLCB2ZXJzaW9uLCB0YWcpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZVBsdWdpbi5hZGQobmFtZSwgKGFkZEZhaWxlZCk6IHZvaWQgPT4ge1xuICAgICAgICAgIGlmIChhZGRGYWlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihFcnJvckNvZGUuZ2V0QmFkRGF0YShhZGRGYWlsZWQubWVzc2FnZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBhIG5ldyBsaXN0IG9mIHRhZ3MgZm9yIGEgbG9jYWwgcGFja2FnZXMgd2l0aCB0aGUgZXhpc3Rpbmcgb25lLlxuICAgKiBAcGFyYW0geyp9IHBrZ05hbWVcbiAgICogQHBhcmFtIHsqfSB0YWdzXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBtZXJnZVRhZ3MocGtnTmFtZTogc3RyaW5nLCB0YWdzOiBNZXJnZVRhZ3MsIGNhbGxiYWNrOiBDYWxsYmFja0FjdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3VwZGF0ZVBhY2thZ2UoXG4gICAgICBwa2dOYW1lLFxuICAgICAgKGRhdGEsIGNiKTogdm9pZCA9PiB7XG4gICAgICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgICAgICAgZm9yIChjb25zdCB0YWcgaW4gdGFncykge1xuICAgICAgICAgIC8vIHRoaXMgaGFuZGxlIGRpc3QtdGFnIHJtIGNvbW1hbmRcbiAgICAgICAgICBpZiAoXy5pc051bGwodGFnc1t0YWddKSkge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGFbRElTVF9UQUdTXVt0YWddO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF8uaXNOaWwoZGF0YS52ZXJzaW9uc1t0YWdzW3RhZ11dKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKHRoaXMuX2dldFZlcnNpb25Ob3RGb3VuZCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmVyc2lvbjogc3RyaW5nID0gdGFnc1t0YWddO1xuICAgICAgICAgIHRhZ1ZlcnNpb24oZGF0YSwgdmVyc2lvbiwgdGFnKTtcbiAgICAgICAgfVxuICAgICAgICBjYihudWxsKTtcbiAgICAgIH0sXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHZlcnNpb24gbm90IGZvdW5kXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX2dldFZlcnNpb25Ob3RGb3VuZCgpOiBhbnkge1xuICAgIHJldHVybiBFcnJvckNvZGUuZ2V0Tm90Rm91bmQoQVBJX0VSUk9SLlZFUlNJT05fTk9UX0VYSVNUKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gZmlsZSBubyBhdmFpbGFibGVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0RmlsZU5vdEF2YWlsYWJsZSgpOiBhbnkge1xuICAgIHJldHVybiBFcnJvckNvZGUuZ2V0Tm90Rm91bmQoJ25vIHN1Y2ggZmlsZSBhdmFpbGFibGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBhY2thZ2UgbWV0YWRhdGEsIHRhZ3MgYW5kIGF0dGFjaG1lbnRzICh0YXJiYWxscykuXG4gICAqIE5vdGU6IEN1cnJlbnRseSBzdXBwb3J0cyB1bnB1Ymxpc2hpbmcgYW5kIGRlcHJlY2F0aW9uLlxuICAgKiBAcGFyYW0geyp9IG5hbWVcbiAgICogQHBhcmFtIHsqfSBpbmNvbWluZ1BrZ1xuICAgKiBAcGFyYW0geyp9IHJldmlzaW9uXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBwdWJsaWMgY2hhbmdlUGFja2FnZShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgaW5jb21pbmdQa2c6IFBhY2thZ2UsXG4gICAgcmV2aXNpb246IHN0cmluZyB8IHZvaWQsXG4gICAgY2FsbGJhY2s6IENhbGxiYWNrXG4gICk6IHZvaWQge1xuICAgIGlmICghaXNPYmplY3QoaW5jb21pbmdQa2cudmVyc2lvbnMpIHx8ICFpc09iamVjdChpbmNvbWluZ1BrZ1tESVNUX1RBR1NdKSkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoeyBuYW1lIH0sIGBjaGFuZ2VQYWNrYWdlIGJhZCBkYXRhIGZvciBAe25hbWV9YCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldEJhZERhdGEoKSk7XG4gICAgfVxuICAgIGRlYnVnKCdjaGFuZ2VQYWNrYWdlIHVkYXB0aW5nIHBhY2thZ2UgZm9yICVvJywgbmFtZSk7XG4gICAgdGhpcy5fdXBkYXRlUGFja2FnZShcbiAgICAgIG5hbWUsXG4gICAgICAobG9jYWxEYXRhOiBQYWNrYWdlLCBjYjogQ2FsbGJhY2tBY3Rpb24pOiB2b2lkID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB2ZXJzaW9uIGluIGxvY2FsRGF0YS52ZXJzaW9ucykge1xuICAgICAgICAgIGNvbnN0IGluY29taW5nVmVyc2lvbiA9IGluY29taW5nUGtnLnZlcnNpb25zW3ZlcnNpb25dO1xuICAgICAgICAgIGlmIChfLmlzTmlsKGluY29taW5nVmVyc2lvbikpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oeyBuYW1lOiBuYW1lLCB2ZXJzaW9uOiB2ZXJzaW9uIH0sICd1bnB1Ymxpc2hpbmcgQHtuYW1lfUBAe3ZlcnNpb259Jyk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FOiBJIHByZWZlciByZXR1cm4gYSBuZXcgb2JqZWN0IHJhdGhlciBtdXRhdGUgdGhlIG1ldGFkYXRhXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxEYXRhLnZlcnNpb25zW3ZlcnNpb25dO1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsRGF0YS50aW1lIVt2ZXJzaW9uXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIGluIGxvY2FsRGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsRGF0YS5fYXR0YWNobWVudHNbZmlsZV0udmVyc2lvbiA9PT0gdmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbERhdGEuX2F0dGFjaG1lbnRzW2ZpbGVdLnZlcnNpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbmNvbWluZ1ZlcnNpb24sICdkZXByZWNhdGVkJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGluY29taW5nRGVwcmVjYXRlZCA9IGluY29taW5nVmVyc2lvbi5kZXByZWNhdGVkO1xuICAgICAgICAgICAgaWYgKGluY29taW5nRGVwcmVjYXRlZCAhPSBsb2NhbERhdGEudmVyc2lvbnNbdmVyc2lvbl0uZGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgICBpZiAoIWluY29taW5nRGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICB7IG5hbWU6IG5hbWUsIHZlcnNpb246IHZlcnNpb24gfSxcbiAgICAgICAgICAgICAgICAgICd1bmRlcHJlY2F0aW5nIEB7bmFtZX1AQHt2ZXJzaW9ufSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbERhdGEudmVyc2lvbnNbdmVyc2lvbl0uZGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgeyBuYW1lOiBuYW1lLCB2ZXJzaW9uOiB2ZXJzaW9uIH0sXG4gICAgICAgICAgICAgICAgICAnZGVwcmVjYXRpbmcgQHtuYW1lfUBAe3ZlcnNpb259J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbG9jYWxEYXRhLnZlcnNpb25zW3ZlcnNpb25dLmRlcHJlY2F0ZWQgPSBpbmNvbWluZ0RlcHJlY2F0ZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbG9jYWxEYXRhLnRpbWUhLm1vZGlmaWVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRGF0YVtVU0VSU10gPSBpbmNvbWluZ1BrZ1tVU0VSU107XG4gICAgICAgIGxvY2FsRGF0YVtESVNUX1RBR1NdID0gaW5jb21pbmdQa2dbRElTVF9UQUdTXTtcbiAgICAgICAgY2IobnVsbCk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0YXJiYWxsLlxuICAgKiBAcGFyYW0geyp9IG5hbWVcbiAgICogQHBhcmFtIHsqfSBmaWxlbmFtZVxuICAgKiBAcGFyYW0geyp9IHJldmlzaW9uXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyByZW1vdmVUYXJiYWxsKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBmaWxlbmFtZTogc3RyaW5nLFxuICAgIHJldmlzaW9uOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s6IENhbGxiYWNrQWN0aW9uXG4gICk6IHZvaWQge1xuICAgIGFzc2VydCh2YWxpZGF0ZU5hbWUoZmlsZW5hbWUpKTtcblxuICAgIHRoaXMuX3VwZGF0ZVBhY2thZ2UoXG4gICAgICBuYW1lLFxuICAgICAgKGRhdGEsIGNiKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChkYXRhLl9hdHRhY2htZW50c1tmaWxlbmFtZV0pIHtcbiAgICAgICAgICBkZWxldGUgZGF0YS5fYXR0YWNobWVudHNbZmlsZW5hbWVdO1xuICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKHRoaXMuX2dldEZpbGVOb3RBdmFpbGFibGUoKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoZXJyOiBhbnkpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLl9nZXRMb2NhbFN0b3JhZ2UobmFtZSk7XG5cbiAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICBzdG9yYWdlLmRlbGV0ZVBhY2thZ2UoZmlsZW5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgdGFyYmFsbC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHB1YmxpYyBhZGRUYXJiYWxsKG5hbWU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IElVcGxvYWRUYXJiYWxsIHtcbiAgICBhc3NlcnQodmFsaWRhdGVOYW1lKGZpbGVuYW1lKSk7XG5cbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBjb25zdCBzaGFPbmVIYXNoID0gY3JlYXRlVGFyYmFsbEhhc2goKTtcbiAgICBjb25zdCB1cGxvYWRTdHJlYW06IElVcGxvYWRUYXJiYWxsID0gbmV3IFVwbG9hZFRhcmJhbGwoe30pO1xuICAgIGNvbnN0IF90cmFuc2Zvcm0gPSB1cGxvYWRTdHJlYW0uX3RyYW5zZm9ybTtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKG5hbWUpO1xuXG4gICAgdXBsb2FkU3RyZWFtLmFib3J0ID0gZnVuY3Rpb24gKCk6IHZvaWQge307XG4gICAgdXBsb2FkU3RyZWFtLmRvbmUgPSBmdW5jdGlvbiAoKTogdm9pZCB7fTtcblxuICAgIHVwbG9hZFN0cmVhbS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIC4uLmFyZ3MpOiB2b2lkIHtcbiAgICAgIHNoYU9uZUhhc2gudXBkYXRlKGRhdGEpO1xuICAgICAgLy8gbWVhc3VyZSB0aGUgbGVuZ3RoIGZvciB2YWxpZGF0aW9uIHJlYXNvbnNcbiAgICAgIGxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgIGNvbnN0IGFwcGxpZWREYXRhID0gW2RhdGEsIC4uLmFyZ3NdO1xuICAgICAgLy8gRklYTUU6IG5vdCBzdXJlIGFib3V0IHRoaXMgYXBwcm9hY2gsIHRzYyBjb21wbGFpbnNcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIF90cmFuc2Zvcm0uYXBwbHkodXBsb2FkU3RyZWFtLCBhcHBsaWVkRGF0YSk7XG4gICAgfTtcblxuICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKTogdm9pZCA9PiB7XG4gICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdlcnJvcicsIEVycm9yQ29kZS5nZXRGb3JiaWRkZW4oKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1cGxvYWRTdHJlYW07XG4gICAgfVxuXG4gICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpOiB2b2lkID0+IHtcbiAgICAgICAgdXBsb2FkU3RyZWFtLmVtaXQoJ2Vycm9yJywgXCJjYW4ndCB1cGxvYWQgdGhpcyBwYWNrYWdlXCIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdXBsb2FkU3RyZWFtO1xuICAgIH1cblxuICAgIGNvbnN0IHdyaXRlU3RyZWFtOiBJVXBsb2FkVGFyYmFsbCA9IHN0b3JhZ2Uud3JpdGVUYXJiYWxsKGZpbGVuYW1lKTtcblxuICAgIHdyaXRlU3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gU1RPUkFHRS5GSUxFX0VYSVNUX0VSUk9SIHx8IGVyci5jb2RlID09PSBIVFRQX1NUQVRVUy5DT05GTElDVCkge1xuICAgICAgICB1cGxvYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBFcnJvckNvZGUuZ2V0Q29uZmxpY3QoKSk7XG4gICAgICAgIHVwbG9hZFN0cmVhbS5hYm9ydCgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSBTVE9SQUdFLk5PX1NVQ0hfRklMRV9FUlJPUiB8fCBlcnIuY29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHBhY2thZ2UgZXhpc3RzIHRvIHRocm93IGFuIGFwcHJvcHJpYXRlIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5nZXRQYWNrYWdlTWV0YWRhdGEobmFtZSwgZnVuY3Rpb24gKF9lcnI6IGFueSwgX3JlczogUGFja2FnZSk6IHZvaWQge1xuICAgICAgICAgIGlmIChfZXJyKSB7XG4gICAgICAgICAgICB1cGxvYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBfZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBsb2FkU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBsb2FkU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHdyaXRlU3RyZWFtLm9uKCdvcGVuJywgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgLy8gcmUtZW1pdHRpbmcgb3BlbiBiZWNhdXNlIGl0J3MgaGFuZGxlZCBpbiBzdG9yYWdlLmpzXG4gICAgICB1cGxvYWRTdHJlYW0uZW1pdCgnb3BlbicpO1xuICAgIH0pO1xuXG4gICAgd3JpdGVTdHJlYW0ub24oJ3N1Y2Nlc3MnLCAoKTogdm9pZCA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVQYWNrYWdlKFxuICAgICAgICBuYW1lLFxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVyKGRhdGEsIGNiKTogdm9pZCB7XG4gICAgICAgICAgZGF0YS5fYXR0YWNobWVudHNbZmlsZW5hbWVdID0ge1xuICAgICAgICAgICAgc2hhc3VtOiBzaGFPbmVIYXNoLmRpZ2VzdCgnaGV4JyksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYihudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdzdWNjZXNzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdXBsb2FkU3RyZWFtLmFib3J0ID0gZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgd3JpdGVTdHJlYW0uYWJvcnQoKTtcbiAgICB9O1xuXG4gICAgdXBsb2FkU3RyZWFtLmRvbmUgPSBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICB1cGxvYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBFcnJvckNvZGUuZ2V0QmFkRGF0YSgncmVmdXNpbmcgdG8gYWNjZXB0IHplcm8tbGVuZ3RoIGZpbGUnKSk7XG4gICAgICAgIHdyaXRlU3RyZWFtLmFib3J0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZVN0cmVhbS5kb25lKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHVwbG9hZFN0cmVhbS5waXBlKHdyaXRlU3RyZWFtKTtcblxuICAgIHJldHVybiB1cGxvYWRTdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdGFyYmFsbC5cbiAgICogQHBhcmFtIHsqfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gZmlsZW5hbWVcbiAgICogQHJldHVybiB7UmVhZFRhcmJhbGx9XG4gICAqL1xuICBwdWJsaWMgZ2V0VGFyYmFsbChuYW1lOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpOiBJUmVhZFRhcmJhbGwge1xuICAgIGFzc2VydCh2YWxpZGF0ZU5hbWUoZmlsZW5hbWUpKTtcblxuICAgIGNvbnN0IHN0b3JhZ2U6IElQYWNrYWdlU3RvcmFnZSA9IHRoaXMuX2dldExvY2FsU3RvcmFnZShuYW1lKTtcblxuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlRmFpbHVyZVN0cmVhbVJlc3BvbnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbVN1Y2Nlc3NSZWFkVGFyQmFsbChzdG9yYWdlLCBmaWxlbmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgc3RyZWFtIHRoYXQgZW1pdHMgYSByZWFkIGZhaWx1cmUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge1JlYWRUYXJiYWxsfVxuICAgKi9cbiAgcHJpdmF0ZSBfY3JlYXRlRmFpbHVyZVN0cmVhbVJlc3BvbnNlKCk6IElSZWFkVGFyYmFsbCB7XG4gICAgY29uc3Qgc3RyZWFtOiBJUmVhZFRhcmJhbGwgPSBuZXcgUmVhZFRhcmJhbGwoe30pO1xuXG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKTogdm9pZCA9PiB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCB0aGlzLl9nZXRGaWxlTm90QXZhaWxhYmxlKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgc3RyZWFtIHRoYXQgZW1pdHMgdGhlIHRhcmJhbGwgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RvcmFnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7UmVhZFRhcmJhbGx9XG4gICAqL1xuICBwcml2YXRlIF9zdHJlYW1TdWNjZXNzUmVhZFRhckJhbGwoc3RvcmFnZTogYW55LCBmaWxlbmFtZTogc3RyaW5nKTogSVJlYWRUYXJiYWxsIHtcbiAgICBjb25zdCBzdHJlYW06IElSZWFkVGFyYmFsbCA9IG5ldyBSZWFkVGFyYmFsbCh7fSk7XG4gICAgY29uc3QgcmVhZFRhcmJhbGxTdHJlYW0gPSBzdG9yYWdlLnJlYWRUYXJiYWxsKGZpbGVuYW1lKTtcbiAgICBjb25zdCBlNDA0ID0gRXJyb3JDb2RlLmdldE5vdEZvdW5kO1xuXG4gICAgc3RyZWFtLmFib3J0ID0gZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgaWYgKF8uaXNOaWwocmVhZFRhcmJhbGxTdHJlYW0pID09PSBmYWxzZSkge1xuICAgICAgICByZWFkVGFyYmFsbFN0cmVhbS5hYm9ydCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZWFkVGFyYmFsbFN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAoZXJyLmNvZGUgPT09IFNUT1JBR0UuTk9fU1VDSF9GSUxFX0VSUk9SIHx8IGVyci5jb2RlID09PSBIVFRQX1NUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZTQwNCgnbm8gc3VjaCBmaWxlIGF2YWlsYWJsZScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFkVGFyYmFsbFN0cmVhbS5vbignY29udGVudC1sZW5ndGgnLCBmdW5jdGlvbiAoY29udGVudCk6IHZvaWQge1xuICAgICAgc3RyZWFtLmVtaXQoJ2NvbnRlbnQtbGVuZ3RoJywgY29udGVudCk7XG4gICAgfSk7XG5cbiAgICByZWFkVGFyYmFsbFN0cmVhbS5vbignb3BlbicsIGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgIC8vIHJlLWVtaXR0aW5nIG9wZW4gYmVjYXVzZSBpdCdzIGhhbmRsZWQgaW4gc3RvcmFnZS5qc1xuICAgICAgc3RyZWFtLmVtaXQoJ29wZW4nKTtcbiAgICAgIHJlYWRUYXJiYWxsU3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBwYWNrYWdlIGJ5IG5hbWUuXG4gICAqIEBwYXJhbSB7Kn0gbmFtZVxuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgcHVibGljIGdldFBhY2thZ2VNZXRhZGF0YShuYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiBDYWxsYmFjayA9ICgpOiB2b2lkID0+IHt9KTogdm9pZCB7XG4gICAgY29uc3Qgc3RvcmFnZTogSVBhY2thZ2VTdG9yYWdlID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKG5hbWUpO1xuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKCkpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWRQYWNrYWdlKG5hbWUsIHN0b3JhZ2UsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggYSBsb2NhbCBwYWNrYWdlLlxuICAgKiBAcGFyYW0geyp9IHN0YXJ0S2V5XG4gICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIHB1YmxpYyBzZWFyY2goc3RhcnRLZXk6IHN0cmluZywgb3B0aW9uczogYW55KTogSVJlYWRUYXJiYWxsIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZFRhcmJhbGwoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gICAgdGhpcy5fc2VhcmNoRWFjaFBhY2thZ2UoXG4gICAgICAoaXRlbTogUGFja2FnZSwgY2I6IENhbGxiYWNrQWN0aW9uKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGl0ZW0udGltZSA+IHBhcnNlSW50KHN0YXJ0S2V5LCAxMCkpIHtcbiAgICAgICAgICB0aGlzLmdldFBhY2thZ2VNZXRhZGF0YShpdGVtLm5hbWUsIChlcnI6IGFueSwgZGF0YTogUGFja2FnZSk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgdGltZSA9IG5ldyBEYXRlKGl0ZW0udGltZSkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHByZXBhcmVTZWFyY2hQYWNrYWdlKGRhdGEsIHRpbWUpO1xuICAgICAgICAgICAgaWYgKF8uaXNOaWwocmVzdWx0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gb25FbmQoZXJyKTogdm9pZCB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSB3cmFwcGVyIHRoYXQgcHJvdmlkZSBhY2Nlc3MgdG8gdGhlIHBhY2thZ2UgbG9jYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwa2dOYW1lIHBhY2thZ2UgbmFtZS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0TG9jYWxTdG9yYWdlKHBrZ05hbWU6IHN0cmluZyk6IElQYWNrYWdlU3RvcmFnZSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVBsdWdpbi5nZXRQYWNrYWdlU3RvcmFnZShwa2dOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEganNvbiBmaWxlIGZyb20gc3RvcmFnZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0b3JhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHByaXZhdGUgX3JlYWRQYWNrYWdlKG5hbWU6IHN0cmluZywgc3RvcmFnZTogYW55LCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBzdG9yYWdlLnJlYWRQYWNrYWdlKG5hbWUsIChlcnIsIHJlc3VsdCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFNUT1JBR0UuTk9fU1VDSF9GSUxFX0VSUk9SIHx8IGVyci5jb2RlID09PSBIVFRQX1NUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9pbnRlcm5hbEVycm9yKGVyciwgU1RPUkFHRS5QQUNLQUdFX0ZJTEVfTkFNRSwgJ2Vycm9yIHJlYWRpbmcnKSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKGVyciwgbm9ybWFsaXplUGFja2FnZShyZXN1bHQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWxrcyB0aHJvdWdoIGVhY2ggcGFja2FnZSBhbmQgY2FsbHMgYG9uX3BhY2thZ2VgIG9uIHRoZW0uXG4gICAqIEBwYXJhbSB7Kn0gb25QYWNrYWdlXG4gICAqIEBwYXJhbSB7Kn0gb25FbmRcbiAgICovXG4gIHByaXZhdGUgX3NlYXJjaEVhY2hQYWNrYWdlKG9uUGFja2FnZTogb25TZWFyY2hQYWNrYWdlLCBvbkVuZDogb25FbmRTZWFyY2hQYWNrYWdlKTogdm9pZCB7XG4gICAgLy8gc2F2ZSB3YWl0IHdoZXRoZXIgcGx1Z2luIHN0aWxsIGRvIG5vdCBzdXBwb3J0IHNlYXJjaCBmdW5jdGlvbmFsaXR5XG4gICAgaWYgKF8uaXNOaWwodGhpcy5zdG9yYWdlUGx1Z2luLnNlYXJjaCkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ3BsdWdpbiBzZWFyY2ggbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgb25FbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9yYWdlUGx1Z2luLnNlYXJjaChvblBhY2thZ2UsIG9uRW5kLCB2YWxpZGF0ZU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBlaXRoZXIgYSBwcmV2aW91cyBjcmVhdGVkIGxvY2FsIHBhY2thZ2Ugb3IgYSBib2lsZXJwbGF0ZS5cbiAgICogQHBhcmFtIHsqfSBwa2dOYW1lXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBwcml2YXRlIF9yZWFkQ3JlYXRlUGFja2FnZShwa2dOYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIGNvbnN0IHN0b3JhZ2U6IGFueSA9IHRoaXMuX2dldExvY2FsU3RvcmFnZShwa2dOYW1lKTtcbiAgICBpZiAoXy5pc05pbChzdG9yYWdlKSkge1xuICAgICAgdGhpcy5fY3JlYXRlTmV3UGFja2FnZShwa2dOYW1lLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RvcmFnZS5yZWFkUGFja2FnZShwa2dOYW1lLCAoZXJyLCBkYXRhKTogdm9pZCA9PiB7XG4gICAgICAvLyBUT0RPOiByYWNlIGNvbmRpdGlvblxuICAgICAgaWYgKF8uaXNOaWwoZXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBTVE9SQUdFLk5PX1NVQ0hfRklMRV9FUlJPUiB8fCBlcnIuY29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgZGF0YSA9IGdlbmVyYXRlUGFja2FnZVRlbXBsYXRlKHBrZ05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9pbnRlcm5hbEVycm9yKGVyciwgU1RPUkFHRS5QQUNLQUdFX0ZJTEVfTkFNRSwgJ2Vycm9yIHJlYWRpbmcnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgbm9ybWFsaXplUGFja2FnZShkYXRhKSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9jcmVhdGVOZXdQYWNrYWdlKG5hbWU6IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrKTogQ2FsbGJhY2sge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBub3JtYWxpemVQYWNrYWdlKGdlbmVyYXRlUGFja2FnZVRlbXBsYXRlKG5hbWUpKSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGludGVybmFsIGVycm9yXG4gICAqIEBwYXJhbSB7Kn0gZXJyXG4gICAqIEBwYXJhbSB7Kn0gZmlsZVxuICAgKiBAcGFyYW0geyp9IG1lc3NhZ2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBFcnJvciBpbnN0YW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBfaW50ZXJuYWxFcnJvcihlcnI6IHN0cmluZywgZmlsZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpOiBhbnkge1xuICAgIHRoaXMubG9nZ2VyLmVycm9yKHsgZXJyOiBlcnIsIGZpbGU6IGZpbGUgfSwgYCR7bWVzc2FnZX0gIEB7ZmlsZX06IEB7IWVyci5tZXNzYWdlfWApO1xuXG4gICAgcmV0dXJuIEVycm9yQ29kZS5nZXRJbnRlcm5hbEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBuYW1lIHBhY2thZ2UgbmFtZVxuICAgKiBAcGFyYW0geyp9IHVwZGF0ZUhhbmRsZXIgZnVuY3Rpb24ocGFja2FnZSwgY2IpIC0gdXBkYXRlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2sgY2FsbGJhY2sgdGhhdCBnZXRzIGludm9rZWQgYWZ0ZXIgaXQncyBhbGwgdXBkYXRlZFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIHByaXZhdGUgX3VwZGF0ZVBhY2thZ2UoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHVwZGF0ZUhhbmRsZXI6IFN0b3JhZ2VVcGRhdGVDYWxsYmFjayxcbiAgICBjYWxsYmFjazogQ2FsbGJhY2tBY3Rpb25cbiAgKTogdm9pZCB7XG4gICAgY29uc3Qgc3RvcmFnZTogSVBhY2thZ2VTdG9yYWdlID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKG5hbWUpO1xuXG4gICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKCkpO1xuICAgIH1cblxuICAgIHN0b3JhZ2UudXBkYXRlUGFja2FnZShcbiAgICAgIG5hbWUsXG4gICAgICB1cGRhdGVIYW5kbGVyLFxuICAgICAgdGhpcy5fd3JpdGVQYWNrYWdlLmJpbmQodGhpcyksXG4gICAgICBub3JtYWxpemVQYWNrYWdlLFxuICAgICAgY2FsbGJhY2tcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcmV2aXNpb24gKF9yZXYpIHN0cmluZyBmb3IgYSBwYWNrYWdlLlxuICAgKiBAcGFyYW0geyp9IG5hbWVcbiAgICogQHBhcmFtIHsqfSBqc29uXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBwcml2YXRlIF93cml0ZVBhY2thZ2UobmFtZTogc3RyaW5nLCBqc29uOiBQYWNrYWdlLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBzdG9yYWdlOiBhbnkgPSB0aGlzLl9nZXRMb2NhbFN0b3JhZ2UobmFtZSk7XG4gICAgaWYgKF8uaXNOaWwoc3RvcmFnZSkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBzdG9yYWdlLnNhdmVQYWNrYWdlKG5hbWUsIHRoaXMuX3NldERlZmF1bHRSZXZpc2lvbihqc29uKSwgY2FsbGJhY2spO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2V0RGVmYXVsdFJldmlzaW9uKGpzb246IFBhY2thZ2UpOiBQYWNrYWdlIHtcbiAgICAvLyBjYWxjdWxhdGUgcmV2aXNpb24gZnJvbSBjb3VjaCBkYlxuICAgIGlmIChfLmlzU3RyaW5nKGpzb24uX3JldikgPT09IGZhbHNlKSB7XG4gICAgICBqc29uLl9yZXYgPSBTVE9SQUdFLkRFRkFVTFRfUkVWSVNJT047XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyBpbnRlbmRlZCBpbiBkZWJ1ZyBtb2RlIHdlIGRvIG5vdCB3YW50IG1vZGlmeSB0aGUgc3RvcmUgcmV2aXNpb25cbiAgICBpZiAoXy5pc05pbCh0aGlzLmNvbmZpZy5fZGVidWcpKSB7XG4gICAgICBqc29uLl9yZXYgPSBnZW5lcmF0ZVJldmlzaW9uKGpzb24uX3Jldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBwcml2YXRlIF9kZWxldGVBdHRhY2htZW50cyhzdG9yYWdlOiBhbnksIGF0dGFjaG1lbnRzOiBzdHJpbmdbXSwgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgZGVidWcoJ1tzdG9yYWdlL19kZWxldGVBdHRhY2htZW50c10gZGVsZXRlIGF0dGFjaG1lbnRzIHRvdGFsOiAlbycsIGF0dGFjaG1lbnRzPy5sZW5ndGgpO1xuICAgIGNvbnN0IHVubGlua05leHQgPSBmdW5jdGlvbiAoY2IpOiB2b2lkIHtcbiAgICAgIGlmIChfLmlzRW1wdHkoYXR0YWNobWVudHMpKSB7XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRhY2htZW50ID0gYXR0YWNobWVudHMuc2hpZnQoKTtcbiAgICAgIHN0b3JhZ2UuZGVsZXRlUGFja2FnZShhdHRhY2htZW50LCBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgIHVubGlua05leHQoY2IpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHVubGlua05leHQoZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgLy8gdHJ5IHRvIHVubGluayB0aGUgZGlyZWN0b3J5LCBidXQgaWdub3JlIGVycm9ycyBiZWNhdXNlIGl0IGNhbiBmYWlsXG4gICAgICBzdG9yYWdlLnJlbW92ZVBhY2thZ2UoZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIHRoZSBkaXN0IGZpbGUgcmVtYWlucyBhcyB0aGUgc2FtZSBwcm90b2NvbFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXBMaW5rS2V5IHJlZ2lzdHJ5IGtleVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfdXBkYXRlVXBsaW5rVG9SZW1vdGVQcm90b2NvbChoYXNoOiBEaXN0RmlsZSwgdXBMaW5rS2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBpZiB3ZSBnb3QgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIGEga25vd24gcmVnaXN0cnksXG4gICAgLy8gdXNlIHRoZSBzYW1lIHByb3RvY29sIGZvciB0aGUgdGFyYmFsbFxuICAgIC8vXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ybGlkd2thL3Npbm9waWEvaXNzdWVzLzE2NlxuICAgIGNvbnN0IHRhcmJhbGxVcmw6IGFueSA9IFVybE5vZGUucGFyc2UoaGFzaC51cmwpO1xuICAgIGNvbnN0IHVwbGlua1VybDogYW55ID0gVXJsTm9kZS5wYXJzZSh0aGlzLmNvbmZpZy51cGxpbmtzW3VwTGlua0tleV0udXJsKTtcblxuICAgIGlmICh1cGxpbmtVcmwuaG9zdCA9PT0gdGFyYmFsbFVybC5ob3N0KSB7XG4gICAgICB0YXJiYWxsVXJsLnByb3RvY29sID0gdXBsaW5rVXJsLnByb3RvY29sO1xuICAgICAgaGFzaC5yZWdpc3RyeSA9IHVwTGlua0tleTtcbiAgICAgIGhhc2gudXJsID0gVXJsTm9kZS5mb3JtYXQodGFyYmFsbFVybCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFNlY3JldChjb25maWc6IENvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNlY3JldEtleSA9IGF3YWl0IHRoaXMuc3RvcmFnZVBsdWdpbi5nZXRTZWNyZXQoKTtcblxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQbHVnaW4uc2V0U2VjcmV0KGNvbmZpZy5jaGVja1NlY3JldEtleShzZWNyZXRLZXkpKTtcbiAgfVxuXG4gIHByaXZhdGUgX2xvYWRTdG9yYWdlKGNvbmZpZzogQ29uZmlnLCBsb2dnZXI6IExvZ2dlcik6IElQbHVnaW5TdG9yYWdlPENvbmZpZz4ge1xuICAgIGNvbnN0IFN0b3JhZ2UgPSB0aGlzLl9sb2FkU3RvcmVQbHVnaW4oKTtcblxuICAgIGlmIChfLmlzTmlsKFN0b3JhZ2UpKSB7XG4gICAgICBhc3NlcnQodGhpcy5jb25maWcuc3RvcmFnZSwgJ0NPTkZJRzogc3RvcmFnZSBwYXRoIG5vdCBkZWZpbmVkJyk7XG4gICAgICByZXR1cm4gbmV3IExvY2FsRGF0YWJhc2UodGhpcy5jb25maWcsIGxvZ2dlcik7XG4gICAgfVxuICAgIHJldHVybiBTdG9yYWdlIGFzIElQbHVnaW5TdG9yYWdlPENvbmZpZz47XG4gIH1cblxuICBwcml2YXRlIF9sb2FkU3RvcmVQbHVnaW4oKTogSVBsdWdpblN0b3JhZ2U8Q29uZmlnPiB8IHZvaWQge1xuICAgIGNvbnN0IHBsdWdpbl9wYXJhbXMgPSB7XG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlcixcbiAgICB9O1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICBjb25zdCBwbHVnaW5zOiBJUGx1Z2luU3RvcmFnZTxDb25maWc+W10gPSBsb2FkUGx1Z2luPElQbHVnaW5TdG9yYWdlPENvbmZpZz4+KFxuICAgICAgdGhpcy5jb25maWcsXG4gICAgICB0aGlzLmNvbmZpZy5zdG9yZSxcbiAgICAgIHBsdWdpbl9wYXJhbXMsXG4gICAgICAocGx1Z2luKTogSVBsdWdpblN0b3JhZ2U8Q29uZmlnPiA9PiB7XG4gICAgICAgIHJldHVybiBwbHVnaW4uZ2V0UGFja2FnZVN0b3JhZ2U7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiBfLmhlYWQocGx1Z2lucyk7XG4gIH1cblxuICBwdWJsaWMgc2F2ZVRva2VuKHRva2VuOiBUb2tlbik6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLnN0b3JhZ2VQbHVnaW4uc2F2ZVRva2VuKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgRXJyb3JDb2RlLmdldENvZGUoSFRUUF9TVEFUVVMuU0VSVklDRV9VTkFWQUlMQUJMRSwgU1VQUE9SVF9FUlJPUlMuUExVR0lOX01JU1NJTkdfSU5URVJGQUNFKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUGx1Z2luLnNhdmVUb2tlbih0b2tlbik7XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlVG9rZW4odXNlcjogc3RyaW5nLCB0b2tlbktleTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMuc3RvcmFnZVBsdWdpbi5kZWxldGVUb2tlbikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIEVycm9yQ29kZS5nZXRDb2RlKEhUVFBfU1RBVFVTLlNFUlZJQ0VfVU5BVkFJTEFCTEUsIFNVUFBPUlRfRVJST1JTLlBMVUdJTl9NSVNTSU5HX0lOVEVSRkFDRSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVBsdWdpbi5kZWxldGVUb2tlbih1c2VyLCB0b2tlbktleSk7XG4gIH1cblxuICBwdWJsaWMgcmVhZFRva2VucyhmaWx0ZXI6IFRva2VuRmlsdGVyKTogUHJvbWlzZTxUb2tlbltdPiB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLnN0b3JhZ2VQbHVnaW4ucmVhZFRva2VucykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIEVycm9yQ29kZS5nZXRDb2RlKEhUVFBfU1RBVFVTLlNFUlZJQ0VfVU5BVkFJTEFCTEUsIFNVUFBPUlRfRVJST1JTLlBMVUdJTl9NSVNTSU5HX0lOVEVSRkFDRSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVBsdWdpbi5yZWFkVG9rZW5zKGZpbHRlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTG9jYWxTdG9yYWdlO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFxQkE7QUFPQTtBQUVBO0FBQ0E7QUFRQTtBQUEwRDtBQUFBO0FBQUE7QUFBQTtBQUUxRCxNQUFNQSxLQUFLLEdBQUcsSUFBQUMsY0FBUyxFQUFDLHlCQUF5QixDQUFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLFlBQVksQ0FBcUI7RUFLOUJDLFdBQVcsQ0FBQ0MsTUFBYyxFQUFFQyxNQUFjLEVBQUU7SUFBQTtJQUFBO0lBQUE7SUFDakQsSUFBSSxDQUFDQSxNQUFNLEdBQUdBLE1BQU07SUFDcEIsSUFBSSxDQUFDRCxNQUFNLEdBQUdBLE1BQU07SUFDcEIsSUFBSSxDQUFDRSxhQUFhLEdBQUcsSUFBSSxDQUFDQyxZQUFZLENBQUNILE1BQU0sRUFBRUMsTUFBTSxDQUFDO0VBQ3hEO0VBRU9HLFVBQVUsQ0FBQ0MsSUFBWSxFQUFFQyxHQUFZLEVBQUVDLFFBQWtCLEVBQVE7SUFDdEUsTUFBTUMsT0FBWSxHQUFHLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNKLElBQUksQ0FBQztJQUVoRCxJQUFJSyxlQUFDLENBQUNDLEtBQUssQ0FBQ0gsT0FBTyxDQUFDLEVBQUU7TUFDcEIsT0FBT0QsUUFBUSxDQUFDSyxpQkFBUyxDQUFDQyxXQUFXLENBQUMsOEJBQThCLENBQUMsQ0FBQztJQUN4RTtJQUVBTCxPQUFPLENBQUNNLGFBQWEsQ0FBQ1QsSUFBSSxFQUFFLElBQUFVLHFDQUF1QixFQUFDVixJQUFJLENBQUMsRUFBR1csR0FBRyxJQUFLO01BQ2xFO01BQ0E7TUFDQSxJQUNFTixlQUFD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