"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createServerFactory = createServerFactory;
exports.displayExperimentsInfoBox = displayExperimentsInfoBox;
exports.runServer = runServer;
var _constants = _interopRequireDefault(require("constants"));
var _debug = _interopRequireDefault(require("debug"));
var _fs = _interopRequireDefault(require("fs"));
var _http = _interopRequireDefault(require("http"));
var _https = _interopRequireDefault(require("https"));
var _lodash = _interopRequireWildcard(require("lodash"));
var _path = _interopRequireDefault(require("path"));
var _index = _interopRequireDefault(require("../api/index"));
var _utils = require("./cli/utils");
var _configPath = _interopRequireDefault(require("./config-path"));
var _constants2 = require("./constants");
var _utils2 = require("./utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const debug = (0, _debug.default)('verdaccio');
const logger = require('./logger');
function displayExperimentsInfoBox(flags) {
  if (!flags) {
    return;
  }
  const experimentList = Object.keys(flags);
  if (experimentList.length >= 1) {
    logger.warn(
    // eslint-disable-next-line max-len
    `experiments are enabled, it is recommended do not use experiments in production comment out this section to disable it`);
    experimentList.forEach(experiment => {
      // eslint-disable-next-line max-len
      logger.info(`support for experiment [${experiment}] ${flags[experiment] ? 'is enabled' : ' is disabled'}`);
    });
  }
}

/**
 * Exposes a server factory to be instantiated programmatically.
 *
    const app = await runServer(); // default configuration
    const app = await runServer('./config/config.yaml');
    const app = await runServer({ configuration });
    app.listen(4000, (event) => {
      // do something
    });
 * @param config
 */
async function runServer(config) {
  let configurationParsed;
  if (config === undefined || typeof config === 'string') {
    const configPathLocation = (0, _configPath.default)(config);
    configurationParsed = (0, _utils2.parseConfigFile)(configPathLocation);
    if (!configurationParsed.self_path) {
      configurationParsed.self_path = _path.default.resolve(configPathLocation);
    }
  } else if (_lodash.default.isObject(config)) {
    configurationParsed = config;
    if (!configurationParsed.self_path) {
      throw new Error('self_path is required, please provide a valid root path for storage');
    }
  } else {
    throw new Error(_constants2.API_ERROR.CONFIG_BAD_FORMAT);
  }
  const addresses = (0, _utils.getListListenAddresses)(undefined, configurationParsed.listen);
  if (addresses.length > 1) {
    process.emitWarning('You have specified multiple listen addresses, using this method only the first will be used');
  }
  const app = await (0, _index.default)(configurationParsed);
  return createServerFactory(configurationParsed, addresses[0], app);
}

/**
 * Return a native HTTP/HTTPS server instance
 * @param config
 * @param addr
 * @param app
 */
function createServerFactory(config, addr, app) {
  let serverFactory;
  if (addr.proto === 'https') {
    debug('https enabled');
    try {
      let httpsOptions = {
        // disable insecure SSLv2 and SSLv3
        secureOptions: _constants.default.SSL_OP_NO_SSLv2 | _constants.default.SSL_OP_NO_SSLv3
      };
      const keyCertConfig = config.https;
      const pfxConfig = config.https;

      // https must either have key and cert or a pfx and (optionally) a passphrase
      if (!(keyCertConfig.key && keyCertConfig.cert || pfxConfig.pfx)) {
        throw Error('bad format https configuration');
      }
      if (pfxConfig.pfx) {
        const {
          pfx,
          passphrase
        } = pfxConfig;
        httpsOptions = (0, _lodash.assign)(httpsOptions, {
          pfx: _fs.default.readFileSync(pfx),
          passphrase: passphrase || ''
        });
      } else {
        const {
          key,
          cert,
          ca
        } = keyCertConfig;
        httpsOptions = (0, _lodash.assign)(httpsOptions, _objectSpread({
          key: _fs.default.readFileSync(key),
          cert: _fs.default.readFileSync(cert)
        }, ca && {
          ca: _fs.default.readFileSync(ca)
        }));
      }
      // TODO: enable http2 as feature
      // if (config.server.http2) <-- check if force http2
      serverFactory = _https.default.createServer(httpsOptions, app);
    } catch (err) {
      throw new Error(`cannot create https server: ${err.message}`);
    }
  } else {
    // http
    debug('http enabled');
    serverFactory = _http.default.createServer(app);
  }
  if (config.server && typeof config.server.keepAliveTimeout !== 'undefined' &&
  // @ts-ignore
  config.server.keepAliveTimeout !== 'null') {
    // library definition for node is not up to date (doesn't contain recent 8.0 changes)
    serverFactory.keepAliveTimeout = config.server.keepAliveTimeout * 1000;
  }
  // FIXE: I could not find the reason of this code.
  unlinkAddressPath(addr);
  return serverFactory;
}
function unlinkAddressPath(addr) {
  if (addr.path && _fs.default.existsSync(addr.path)) {
    _fs.default.unlinkSync(addr.path);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWJ1ZyIsImJ1aWxkRGVidWciLCJsb2dnZXIiLCJyZXF1aXJlIiwiZGlzcGxheUV4cGVyaW1lbnRzSW5mb0JveCIsImZsYWdzIiwiZXhwZXJpbWVudExpc3QiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwid2FybiIsImZvckVhY2giLCJleHBlcmltZW50IiwiaW5mbyIsInJ1blNlcnZlciIsImNvbmZpZyIsImNvbmZpZ3VyYXRpb25QYXJzZWQiLCJ1bmRlZmluZWQiLCJjb25maWdQYXRoTG9jYXRpb24iLCJmaW5kQ29uZmlnRmlsZSIsInBhcnNlQ29uZmlnRmlsZSIsInNlbGZfcGF0aCIsInBhdGgiLCJyZXNvbHZlIiwiXyIsImlzT2JqZWN0IiwiRXJyb3IiLCJBUElfRVJST1IiLCJDT05GSUdfQkFEX0ZPUk1BVCIsImFkZHJlc3NlcyIsImdldExpc3RMaXN0ZW5BZGRyZXNzZXMiLCJsaXN0ZW4iLCJwcm9jZXNzIiwiZW1pdFdhcm5pbmciLCJhcHAiLCJlbmRQb2ludEFQSSIsImNyZWF0ZVNlcnZlckZhY3RvcnkiLCJhZGRyIiwic2VydmVyRmFjdG9yeSIsInByb3RvIiwiaHR0cHNPcHRpb25zIiwic2VjdXJlT3B0aW9ucyIsImNvbnN0YW50cyIsIlNTTF9PUF9OT19TU0x2MiIsIlNTTF9PUF9OT19TU0x2MyIsImtleUNlcnRDb25maWciLCJodHRwcyIsInBmeENvbmZpZyIsImtleSIsImNlcnQiLCJwZngiLCJwYXNzcGhyYXNlIiwiYXNzaWduIiwiZnMiLCJyZWFkRmlsZVN5bmMiLCJjYSIsImNyZWF0ZVNlcnZlciIsImVyciIsIm1lc3NhZ2UiLCJodHRwIiwic2VydmVyIiwia2VlcEFsaXZlVGltZW91dCIsInVubGlua0FkZHJlc3NQYXRoIiwiZXhpc3RzU3luYyIsInVubGlua1N5bmMiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL3J1bi1zZXJ2ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNvbnN0YW50cyBmcm9tICdjb25zdGFudHMnO1xuaW1wb3J0IGJ1aWxkRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCBfLCB7IGFzc2lnbiB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgQ29uZmlnUnVudGltZSwgSHR0cHNDb25mS2V5Q2VydCwgSHR0cHNDb25mUGZ4IH0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5cbmltcG9ydCBlbmRQb2ludEFQSSBmcm9tICcuLi9hcGkvaW5kZXgnO1xuaW1wb3J0IHsgZ2V0TGlzdExpc3RlbkFkZHJlc3NlcyB9IGZyb20gJy4vY2xpL3V0aWxzJztcbmltcG9ydCBmaW5kQ29uZmlnRmlsZSBmcm9tICcuL2NvbmZpZy1wYXRoJztcbmltcG9ydCB7IEFQSV9FUlJPUiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IHBhcnNlQ29uZmlnRmlsZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBkZWJ1ZyA9IGJ1aWxkRGVidWcoJ3ZlcmRhY2NpbycpO1xuXG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGxheUV4cGVyaW1lbnRzSW5mb0JveChmbGFncykge1xuICBpZiAoIWZsYWdzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwZXJpbWVudExpc3QgPSBPYmplY3Qua2V5cyhmbGFncyk7XG4gIGlmIChleHBlcmltZW50TGlzdC5sZW5ndGggPj0gMSkge1xuICAgIGxvZ2dlci53YXJuKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgIGBleHBlcmltZW50cyBhcmUgZW5hYmxlZCwgaXQgaXMgcmVjb21tZW5kZWQgZG8gbm90IHVzZSBleHBlcmltZW50cyBpbiBwcm9kdWN0aW9uIGNvbW1lbnQgb3V0IHRoaXMgc2VjdGlvbiB0byBkaXNhYmxlIGl0YFxuICAgICk7XG4gICAgZXhwZXJpbWVudExpc3QuZm9yRWFjaCgoZXhwZXJpbWVudCkgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICBgc3VwcG9ydCBmb3IgZXhwZXJpbWVudCBbJHtleHBlcmltZW50fV0gJHtcbiAgICAgICAgICBmbGFnc1tleHBlcmltZW50XSA/ICdpcyBlbmFibGVkJyA6ICcgaXMgZGlzYWJsZWQnXG4gICAgICAgIH1gXG4gICAgICApO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlcyBhIHNlcnZlciBmYWN0b3J5IHRvIGJlIGluc3RhbnRpYXRlZCBwcm9ncmFtbWF0aWNhbGx5LlxuICpcbiAgICBjb25zdCBhcHAgPSBhd2FpdCBydW5TZXJ2ZXIoKTsgLy8gZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgY29uc3QgYXBwID0gYXdhaXQgcnVuU2VydmVyKCcuL2NvbmZpZy9jb25maWcueWFtbCcpO1xuICAgIGNvbnN0IGFwcCA9IGF3YWl0IHJ1blNlcnZlcih7IGNvbmZpZ3VyYXRpb24gfSk7XG4gICAgYXBwLmxpc3Rlbig0MDAwLCAoZXZlbnQpID0+IHtcbiAgICAgIC8vIGRvIHNvbWV0aGluZ1xuICAgIH0pO1xuICogQHBhcmFtIGNvbmZpZ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuU2VydmVyKGNvbmZpZz86IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gIGxldCBjb25maWd1cmF0aW9uUGFyc2VkOiBDb25maWdSdW50aW1lO1xuICBpZiAoY29uZmlnID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjb25maWdQYXRoTG9jYXRpb24gPSBmaW5kQ29uZmlnRmlsZShjb25maWcpO1xuICAgIGNvbmZpZ3VyYXRpb25QYXJzZWQgPSBwYXJzZUNvbmZpZ0ZpbGUoY29uZmlnUGF0aExvY2F0aW9uKSBhcyBDb25maWdSdW50aW1lO1xuICAgIGlmICghY29uZmlndXJhdGlvblBhcnNlZC5zZWxmX3BhdGgpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb25QYXJzZWQuc2VsZl9wYXRoID0gcGF0aC5yZXNvbHZlKGNvbmZpZ1BhdGhMb2NhdGlvbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoY29uZmlnKSkge1xuICAgIGNvbmZpZ3VyYXRpb25QYXJzZWQgPSBjb25maWc7XG4gICAgaWYgKCFjb25maWd1cmF0aW9uUGFyc2VkLnNlbGZfcGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWxmX3BhdGggaXMgcmVxdWlyZWQsIHBsZWFzZSBwcm92aWRlIGEgdmFsaWQgcm9vdCBwYXRoIGZvciBzdG9yYWdlJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihBUElfRVJST1IuQ09ORklHX0JBRF9GT1JNQVQpO1xuICB9XG5cbiAgY29uc3QgYWRkcmVzc2VzID0gZ2V0TGlzdExpc3RlbkFkZHJlc3Nlcyh1bmRlZmluZWQsIGNvbmZpZ3VyYXRpb25QYXJzZWQubGlzdGVuKTtcbiAgaWYgKGFkZHJlc3Nlcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhcbiAgICAgICdZb3UgaGF2ZSBzcGVjaWZpZWQgbXVsdGlwbGUgbGlzdGVuIGFkZHJlc3NlcywgdXNpbmcgdGhpcyBtZXRob2Qgb25seSB0aGUgZmlyc3Qgd2lsbCBiZSB1c2VkJ1xuICAgICk7XG4gIH1cblxuICBjb25zdCBhcHAgPSBhd2FpdCBlbmRQb2ludEFQSShjb25maWd1cmF0aW9uUGFyc2VkKTtcbiAgcmV0dXJuIGNyZWF0ZVNlcnZlckZhY3RvcnkoY29uZmlndXJhdGlvblBhcnNlZCwgYWRkcmVzc2VzWzBdLCBhcHApO1xufVxuXG4vKipcbiAqIFJldHVybiBhIG5hdGl2ZSBIVFRQL0hUVFBTIHNlcnZlciBpbnN0YW5jZVxuICogQHBhcmFtIGNvbmZpZ1xuICogQHBhcmFtIGFkZHJcbiAqIEBwYXJhbSBhcHBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlcnZlckZhY3RvcnkoY29uZmlnOiBDb25maWdSdW50aW1lLCBhZGRyLCBhcHApIHtcbiAgbGV0IHNlcnZlckZhY3Rvcnk7XG4gIGlmIChhZGRyLnByb3RvID09PSAnaHR0cHMnKSB7XG4gICAgZGVidWcoJ2h0dHBzIGVuYWJsZWQnKTtcbiAgICB0cnkge1xuICAgICAgbGV0IGh0dHBzT3B0aW9ucyA9IHtcbiAgICAgICAgLy8gZGlzYWJsZSBpbnNlY3VyZSBTU0x2MiBhbmQgU1NMdjNcbiAgICAgICAgc2VjdXJlT3B0aW9uczogY29uc3RhbnRzLlNTTF9PUF9OT19TU0x2MiB8IGNvbnN0YW50cy5TU0xfT1BfTk9fU1NMdjMsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBrZXlDZXJ0Q29uZmlnID0gY29uZmlnLmh0dHBzIGFzIEh0dHBzQ29uZktleUNlcnQ7XG4gICAgICBjb25zdCBwZnhDb25maWcgPSBjb25maWcuaHR0cHMgYXMgSHR0cHNDb25mUGZ4O1xuXG4gICAgICAvLyBodHRwcyBtdXN0IGVpdGhlciBoYXZlIGtleSBhbmQgY2VydCBvciBhIHBmeCBhbmQgKG9wdGlvbmFsbHkpIGEgcGFzc3BocmFzZVxuICAgICAgaWYgKCEoKGtleUNlcnRDb25maWcua2V5ICYmIGtleUNlcnRDb25maWcuY2VydCkgfHwgcGZ4Q29uZmlnLnBmeCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2JhZCBmb3JtYXQgaHR0cHMgY29uZmlndXJhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGZ4Q29uZmlnLnBmeCkge1xuICAgICAgICBjb25zdCB7IHBmeCwgcGFzc3BocmFzZSB9ID0gcGZ4Q29uZmlnO1xuICAgICAgICBodHRwc09wdGlvbnMgPSBhc3NpZ24oaHR0cHNPcHRpb25zLCB7XG4gICAgICAgICAgcGZ4OiBmcy5yZWFkRmlsZVN5bmMocGZ4KSxcbiAgICAgICAgICBwYXNzcGhyYXNlOiBwYXNzcGhyYXNlIHx8ICcnLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBjZXJ0LCBjYSB9ID0ga2V5Q2VydENvbmZpZztcbiAgICAgICAgaHR0cHNPcHRpb25zID0gYXNzaWduKGh0dHBzT3B0aW9ucywge1xuICAgICAgICAgIGtleTogZnMucmVhZEZpbGVTeW5jKGtleSksXG4gICAgICAgICAgY2VydDogZnMucmVhZEZpbGVTeW5jKGNlcnQpLFxuICAgICAgICAgIC4uLihjYSAmJiB7XG4gICAgICAgICAgICBjYTogZnMucmVhZEZpbGVTeW5jKGNhKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBlbmFibGUgaHR0cDIgYXMgZmVhdHVyZVxuICAgICAgLy8gaWYgKGNvbmZpZy5zZXJ2ZXIuaHR0cDIpIDwtLSBjaGVjayBpZiBmb3JjZSBodHRwMlxuICAgICAgc2VydmVyRmFjdG9yeSA9IGh0dHBzLmNyZWF0ZVNlcnZlcihodHRwc09wdGlvbnMsIGFwcCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBjcmVhdGUgaHR0cHMgc2VydmVyOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBodHRwXG4gICAgZGVidWcoJ2h0dHAgZW5hYmxlZCcpO1xuICAgIHNlcnZlckZhY3RvcnkgPSBodHRwLmNyZWF0ZVNlcnZlcihhcHApO1xuICB9XG5cbiAgaWYgKFxuICAgIGNvbmZpZy5zZXJ2ZXIgJiZcbiAgICB0eXBlb2YgY29uZmlnLnNlcnZlci5rZWVwQWxpdmVUaW1lb3V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25maWcuc2VydmVyLmtlZXBBbGl2ZVRpbWVvdXQgIT09ICdudWxsJ1xuICApIHtcbiAgICAvLyBsaWJyYXJ5IGRlZmluaXRpb24gZm9yIG5vZGUgaXMgbm90IHVwIHRvIGRhdGUgKGRvZXNuJ3QgY29udGFpbiByZWNlbnQgOC4wIGNoYW5nZXMpXG4gICAgc2VydmVyRmFjdG9yeS5rZWVwQWxpdmVUaW1lb3V0ID0gY29uZmlnLnNlcnZlci5rZWVwQWxpdmVUaW1lb3V0ICogMTAwMDtcbiAgfVxuICAvLyBGSVhFOiBJIGNvdWxkIG5vdCBmaW5kIHRoZSByZWFzb24gb2YgdGhpcyBjb2RlLlxuICB1bmxpbmtBZGRyZXNzUGF0aChhZGRyKTtcblxuICByZXR1cm4gc2VydmVyRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gdW5saW5rQWRkcmVzc1BhdGgoYWRkcikge1xuICBpZiAoYWRkci5wYXRoICYmIGZzLmV4aXN0c1N5bmMoYWRkci5wYXRoKSkge1xuICAgIGZzLnVubGlua1N5bmMoYWRkci5wYXRoKTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUEwQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRTFDLE1BQU1BLEtBQUssR0FBRyxJQUFBQyxjQUFVLEVBQUMsV0FBVyxDQUFDO0FBRXJDLE1BQU1DLE1BQU0sR0FBR0MsT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUUzQixTQUFTQyx5QkFBeUIsQ0FBQ0MsS0FBSyxFQUFFO0VBQy9DLElBQUksQ0FBQ0EsS0FBSyxFQUFFO0lBQ1Y7RUFDRjtFQUVBLE1BQU1DLGNBQWMsR0FBR0MsTUFBTSxDQUFDQyxJQUFJLENBQUNILEtBQUssQ0FBQztFQUN6QyxJQUFJQyxjQUFjLENBQUNHLE1BQU0sSUFBSSxDQUFDLEVBQUU7SUFDOUJQLE1BQU0sQ0FBQ1EsSUFBSTtJQUNUO0lBQ0Msd0hBQXVILENBQ3pIO0lBQ0RKLGNBQWMsQ0FBQ0ssT0FBTyxDQUFFQyxVQUFVLElBQUs7TUFDckM7TUFDQVYsTUFBTSxDQUFDVyxJQUFJLENBQ1IsMkJBQTBCRCxVQUFXLEtBQ3BDUCxL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