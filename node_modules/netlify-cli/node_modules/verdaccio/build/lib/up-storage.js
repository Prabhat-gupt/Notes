"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _JSONStream = _interopRequireDefault(require("JSONStream"));
var _debug = _interopRequireDefault(require("debug"));
var _lodash = _interopRequireDefault(require("lodash"));
var _request = _interopRequireDefault(require("request"));
var _stream = _interopRequireDefault(require("stream"));
var _url = _interopRequireDefault(require("url"));
var _zlib = _interopRequireDefault(require("zlib"));
var _streams = require("@verdaccio/streams");
var _utils = require("@verdaccio/utils");
var _constants = require("./constants");
var _logger = require("./logger");
var _utils2 = require("./utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const debug = (0, _debug.default)('verdaccio:up-storage');
const encode = function (thing) {
  return encodeURIComponent(thing).replace(/^%40/, '@');
};
const jsonContentType = _constants.HEADERS.JSON;
const contentTypeAccept = `${jsonContentType};`;

/**
 * Just a helper (`config[key] || default` doesn't work because of zeroes)
 */
const setConfig = (config, key, def) => {
  return _lodash.default.isNil(config[key]) === false ? config[key] : def;
};

/**
 * Implements Storage interface
 * (same for storage.js, local-storage.js, up-storage.js)
 */
class ProxyStorage {
  // FIXME: upname is assigned to each instance
  // @ts-ignore

  // FIXME: proxy can be boolean or object, something smells here
  // @ts-ignore

  // @ts-ignore

  /**
   * Constructor
   * @param {*} config
   * @param {*} mainConfig
   */
  constructor(config, mainConfig) {
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "failed_requests", void 0);
    _defineProperty(this, "userAgent", void 0);
    _defineProperty(this, "ca", void 0);
    _defineProperty(this, "logger", void 0);
    _defineProperty(this, "server_id", void 0);
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "maxage", void 0);
    _defineProperty(this, "timeout", void 0);
    _defineProperty(this, "max_fails", void 0);
    _defineProperty(this, "fail_timeout", void 0);
    _defineProperty(this, "agent_options", void 0);
    _defineProperty(this, "upname", void 0);
    _defineProperty(this, "proxy", void 0);
    _defineProperty(this, "last_request_time", void 0);
    _defineProperty(this, "strict_ssl", void 0);
    this.config = config;
    this.failed_requests = 0;
    // @ts-ignore
    this.userAgent = mainConfig.user_agent;
    this.ca = config.ca;
    this.logger = _logger.logger;
    this.server_id = mainConfig.server_id;
    this.url = _url.default.parse(this.config.url);
    this._setupProxy(this.url.hostname, config, mainConfig, this.url.protocol === 'https:');
    this.config.url = this.config.url.replace(/\/$/, '');
    if (this.config.timeout && Number(this.config.timeout) >= 1000) {
      this.logger.warn(['Too big timeout value: ' + this.config.timeout, 'We changed time format to nginx-like one', '(see http://nginx.org/en/docs/syntax.html)', 'so please update your config accordingly'].join('\n'));
    }

    // a bunch of different configurable timers
    this.maxage = (0, _utils2.parseInterval)(setConfig(this.config, 'maxage', '2m'));
    this.timeout = (0, _utils2.parseInterval)(setConfig(this.config, 'timeout', '30s'));
    this.max_fails = Number(setConfig(this.config, 'max_fails', 2));
    this.fail_timeout = (0, _utils2.parseInterval)(setConfig(this.config, 'fail_timeout', '5m'));
    this.strict_ssl = Boolean(setConfig(this.config, 'strict_ssl', true));
    this.agent_options = setConfig(this.config, 'agent_options', {
      keepAlive: true,
      maxSockets: 40,
      maxFreeSockets: 10
    });
  }

  /**
   * Fetch an asset.
   * @param {*} options
   * @param {*} cb
   * @return {Request}
   */
  request(options, cb) {
    let json;
    if (this._statusCheck() === false) {
      const streamRead = new _stream.default.Readable();
      process.nextTick(function () {
        if (cb) {
          cb(_utils2.ErrorCode.getInternalError(_constants.API_ERROR.UPLINK_OFFLINE));
        }
        streamRead.emit('error', _utils2.ErrorCode.getInternalError(_constants.API_ERROR.UPLINK_OFFLINE));
      });
      streamRead._read = function () {};
      // preventing 'Uncaught, unspecified "error" event'
      streamRead.on('error', function () {});
      return streamRead;
    }
    const self = this;
    const headers = this._setHeaders(options);
    this._addProxyHeaders(options.req, headers);
    this._overrideWithUpLinkConfLocaligHeaders(headers);
    const method = options.method || 'GET';
    const uri = options.uri_full || this.config.url + options.uri;
    self.logger.info({
      method: method,
      headers: headers,
      uri: uri
    }, "making request: '@{method} @{uri}'");
    if ((0, _utils2.isObject)(options.json)) {
      json = JSON.stringify(options.json);
      headers['Content-Type'] = headers['Content-Type'] || _constants.HEADERS.JSON;
    }
    const requestCallback = cb ? function (err, res, body) {
      let error;
      const responseLength = err ? 0 : body.length;
      processBody();
      logActivity();
      cb(err, res, body);

      /**
       * Perform a decode.
       */
      function processBody() {
        if (err) {
          error = err.message;
          return;
        }
        if (options.json && res.statusCode < 300) {
          try {
            body = JSON.parse(body.toString(_constants.CHARACTER_ENCODING.UTF8));
          } catch (_err) {
            body = {};
            err = _err;
            error = err.message;
          }
        }
        if (!err && (0, _utils2.isObject)(body)) {
          if (_lodash.default.isString(body.error)) {
            error = body.error;
          }
        }
      }
      /**
       * Perform a log.
       */
      function logActivity() {
        let message = "@{!status}, req: '@{request.method} @{request.url}'";
        message += error ? ', error: @{!error}' : ', bytes: @{bytes.in}/@{bytes.out}';
        self.logger.http({
          err: err || undefined,
          // if error is null/false change this to undefined so it wont log
          request: {
            method: method,
            url: uri
          },
          status: res != null ? res.statusCode : 'ERR',
          error: error,
          bytes: {
            in: json ? json.length : 0,
            out: responseLength || 0
          }
        }, message);
      }
    } : undefined;
    let requestOptions = {
      url: uri,
      method: method,
      headers: headers,
      body: json,
      proxy: this.proxy,
      encoding: null,
      gzip: true,
      timeout: this.timeout,
      strictSSL: this.strict_ssl,
      agentOptions: this.agent_options
    };
    if (this.ca) {
      requestOptions = Object.assign({}, requestOptions, {
        ca: this.ca
      });
    }
    const req = (0, _request.default)(requestOptions, requestCallback);
    let statusCalled = false;
    req.on('response', function (res) {
      // FIXME: _verdaccio_aborted seems not used
      // @ts-ignore
      if (!req._verdaccio_aborted && !statusCalled) {
        statusCalled = true;
        self._statusCheck(true);
      }
      if (_lodash.default.isNil(requestCallback) === false) {
        (function do_log() {
          const message = "@{!status}, req: '@{request.method} @{request.url}' (streaming)";
          self.logger.http({
            request: {
              method: method,
              url: uri
            },
            status: _lodash.default.isNull(res) === false ? res.statusCode : 'ERR'
          }, message);
        })();
      }
    });
    req.on('error', function (_err) {
      // FIXME: _verdaccio_aborted seems not used
      // @ts-ignore
      if (!req._verdaccio_aborted && !statusCalled) {
        statusCalled = true;
        self._statusCheck(false);
      }
    });
    // @ts-ignore
    return req;
  }

  /**
   * Set default headers.
   * @param {Object} options
   * @return {Object}
   * @private
   */
  _setHeaders(options) {
    var _options$req;
    const headers = options.headers || {};
    const accept = _constants.HEADERS.ACCEPT;
    const acceptEncoding = _constants.HEADERS.ACCEPT_ENCODING;
    const userAgent = _constants.HEADERS.USER_AGENT;
    headers[accept] = headers[accept] || contentTypeAccept;
    headers[acceptEncoding] = headers[acceptEncoding] || 'gzip';
    // registry.npmjs.org will only return search result if user-agent include string 'npm'
    headers[userAgent] = this.userAgent ? `npm (${this.userAgent})` : (_options$req = options.req) === null || _options$req === void 0 ? void 0 : _options$req.get('user-agent');
    return this._setAuth(headers);
  }

  /**
   * Validate configuration auth and assign Header authorization
   * @param {Object} headers
   * @return {Object}
   * @private
   */
  _setAuth(headers) {
    const {
      auth
    } = this.config;
    if (_lodash.default.isNil(auth) || headers[_constants.HEADERS.AUTHORIZATION]) {
      return headers;
    }
    if (_lodash.default.isObject(auth) === false && _lodash.default.isObject(auth.token) === false) {
      this._throwErrorAuth('Auth invalid');
    }

    // get NPM_TOKEN http://blog.npmjs.org/post/118393368555/deploying-with-npm-private-modules
    // or get other variable export in env
    // https://github.com/verdaccio/verdaccio/releases/tag/v2.5.0
    let token;
    const tokenConf = auth;
    if (_lodash.default.isNil(tokenConf.token) === false && _lodash.default.isString(tokenConf.token)) {
      token = tokenConf.token;
    } else if (_lodash.default.isNil(tokenConf.token_env) === false) {
      if (_lodash.default.isString(tokenConf.token_env)) {
        token = process.env[tokenConf.token_env];
      } else if (_lodash.default.isBoolean(tokenConf.token_env) && tokenConf.token_env) {
        token = process.env.NPM_TOKEN;
      } else {
        this.logger.error(_constants.ERROR_CODE.token_required);
        this._throwErrorAuth(_constants.ERROR_CODE.token_required);
      }
    } else {
      token = process.env.NPM_TOKEN;
    }
    if (_lodash.default.isNil(token)) {
      this._throwErrorAuth(_constants.ERROR_CODE.token_required);
    }

    // define type Auth allow basic and bearer
    const type = tokenConf.type || _constants.TOKEN_BASIC;
    this._setHeaderAuthorization(headers, type, token);
    return headers;
  }

  /**
   * @param {string} message
   * @throws {Error}
   * @private
   */
  _throwErrorAuth(message) {
    this.logger.error(message);
    throw new Error(message);
  }

  /**
   * Assign Header authorization with type authentication
   * @param {Object} headers
   * @param {string} type
   * @param {string} token
   * @private
   */
  _setHeaderAuthorization(headers, type, token) {
    const _type = type.toLowerCase();
    if (_type !== _constants.TOKEN_BEARER.toLowerCase() && _type !== _constants.TOKEN_BASIC.toLowerCase()) {
      this._throwErrorAuth(`Auth type '${_type}' not allowed`);
    }
    type = _lodash.default.upperFirst(type);
    headers[_constants.HEADERS.AUTHORIZATION] = (0, _utils.buildToken)(type, token);
  }

  /**
   * It will add or override specified headers from config file.
   *
   * Eg:
   *
   * uplinks:
   npmjs:
   url: https://registry.npmjs.org/
   headers:
   Accept: "application/vnd.npm.install-v2+json; q=1.0"
   verdaccio-staging:
   url: https://mycompany.com/npm
   headers:
   Accept: "application/json"
   authorization: "Basic YourBase64EncodedCredentials=="
    * @param {Object} headers
   * @private
   */
  _overrideWithUpLinkConfLocaligHeaders(headers) {
    if (!this.config.headers) {
      return headers;
    }

    // add/override headers specified in the config
    /* eslint guard-for-in: 0 */
    for (const key in this.config.headers) {
      headers[key] = this.config.headers[key];
    }
  }

  /**
   * Determine whether can fetch from the provided URL
   * @param {*} url
   * @return {Boolean}
   */
  isUplinkValid(url) {
    const urlParsed = _url.default.parse(url);
    const isHTTPS = urlDomainParsed => urlDomainParsed.protocol === 'https:' && (urlParsed.port === null || urlParsed.port === '443');
    const getHost = urlDomainParsed => isHTTPS(urlDomainParsed) ? urlDomainParsed.hostname : urlDomainParsed.host;
    const isMatchProtocol = urlParsed.protocol === this.url.protocol;
    const isMatchHost = getHost(urlParsed) === getHost(this.url);
    // @ts-ignore
    const isMatchPath = urlParsed.path.indexOf(this.url.path) === 0;
    return isMatchProtocol && isMatchHost && isMatchPath;
  }

  /**
   * Get a remote package metadata
   * @param {*} name package name
   * @param {*} options request options, eg: eTag.
   * @param {*} callback
   */
  getRemoteMetadata(name, options, callback) {
    const headers = {};
    if (_lodash.default.isNil(options.etag) === false) {
      headers['If-None-Match'] = options.etag;
      headers[_constants.HEADERS.ACCEPT] = contentTypeAccept;
    }
    this.request({
      uri: `/${encode(name)}`,
      json: true,
      headers: headers,
      req: options.req
    }, (err, res, body) => {
      if (err) {
        return callback(err);
      }
      if (res.statusCode === _constants.HTTP_STATUS.NOT_FOUND) {
        return callback(_utils2.ErrorCode.getNotFound(_constants.API_ERROR.NOT_PACKAGE_UPLINK));
      }
      if (!(res.statusCode >= _constants.HTTP_STATUS.OK && res.statusCode < _constants.HTTP_STATUS.MULTIPLE_CHOICES)) {
        const error = _utils2.ErrorCode.getInternalError(`${_constants.API_ERROR.BAD_STATUS_CODE}: ${res.statusCode}`);
        error.remoteStatus = res.statusCode;
        return callback(error);
      }
      callback(null, body, res.headers.etag);
    });
  }

  /**
   * Fetch a tarball from the uplink.
   * @param {String} url
   * @return {Stream}
   */
  fetchTarball(url) {
    const stream = new _streams.ReadTarball({});
    let current_length = 0;
    let expected_length;
    stream.abort = () => {};
    const readStream = this.request({
      uri_full: url,
      encoding: null,
      headers: {
        Accept: contentTypeAccept
      }
    });
    readStream.on('response', function (res) {
      if (res.statusCode === _constants.HTTP_STATUS.NOT_FOUND) {
        return stream.emit('error', _utils2.ErrorCode.getNotFound(_constants.API_ERROR.NOT_FILE_UPLINK));
      }
      if (!(res.statusCode >= _constants.HTTP_STATUS.OK && res.statusCode < _constants.HTTP_STATUS.MULTIPLE_CHOICES)) {
        return stream.emit('error', _utils2.ErrorCode.getInternalError(`bad uplink status code: ${res.statusCode}`));
      }
      if (res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH]) {
        expected_length = res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH];
        stream.emit(_constants.HEADER_TYPE.CONTENT_LENGTH, res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH]);
      }
      readStream.pipe(stream);
    });
    readStream.on('error', function (err) {
      stream.emit('error', err);
    });
    readStream.on('data', function (data) {
      current_length += data.length;
    });
    readStream.on('end', function (data) {
      if (data) {
        current_length += data.length;
      }
      if (expected_length && current_length != expected_length) {
        stream.emit('error', _utils2.ErrorCode.getInternalError(_constants.API_ERROR.CONTENT_MISMATCH));
      }
    });
    return stream;
  }

  /**
   * Perform a stream search.
   * @param {*} options request options
   * @return {Stream}
   */
  search(options) {
    const transformStream = new _stream.default.PassThrough({
      objectMode: true
    });
    const requestStream = this.request({
      uri: options.req.url,
      req: options.req,
      headers: {
        // query for search
        referer: options.req.get('referer')
      }
    });
    const parsePackage = pkg => {
      if ((0, _utils2.isObjectOrArray)(pkg)) {
        transformStream.emit('data', pkg);
      }
    };
    requestStream.on('response', res => {
      if (!String(res.statusCode).match(/^2\d\d$/)) {
        return transformStream.emit('error', _utils2.ErrorCode.getInternalError(`bad status code ${res.statusCode} from uplink`));
      }

      // See https://github.com/request/request#requestoptions-callback
      // Request library will not decode gzip stream.
      let jsonStream;
      if (res.headers[_constants.HEADER_TYPE.CONTENT_ENCODING] === _constants.HEADERS.GZIP) {
        jsonStream = res.pipe(_zlib.default.createUnzip());
      } else {
        jsonStream = res;
      }
      jsonStream.pipe(_JSONStream.default.parse('*')).on('data', parsePackage);
      jsonStream.on('end', () => {
        transformStream.emit('end');
      });
    });
    requestStream.on('error', err => {
      transformStream.emit('error', err);
    });
    transformStream.abort = () => {
      // FIXME: this is clearly a potential issue
      // there is no abort method on Stream.Readable
      // @ts-ignore
      requestStream.abort();
      transformStream.emit('end');
    };
    return transformStream;
  }

  /**
   * Add proxy headers.
   * FIXME: object mutations, it should return an new object
   * @param {*} req the http request
   * @param {*} headers the request headers
   */
  _addProxyHeaders(req, headers) {
    if (req) {
      // Only submit X-Forwarded-For field if we don't have a proxy selected
      // in the config file.
      //
      // Otherwise misconfigured proxy could return 407:
      // https://github.com/rlidwka/sinopia/issues/254
      //
      // FIXME: proxy logic is odd, something is wrong here.
      // @ts-ignore
      if (!this.proxy) {
        headers['x-forwarded-for'] = (req.get('x-forwarded-for') ? req.get('x-forwarded-for') + ', ' : '') + req.connection.remoteAddress;
      }
    }

    // always attach Via header to avoid loops, even if we're not proxying
    headers['via'] = req && req.get('via') ? req.get('via') + ', ' : '';
    headers['via'] += '1.1 ' + this.server_id + ' (Verdaccio)';
  }

  /**
   * Check whether the remote host is available.
   * @param {*} alive
   * @return {Boolean}
   */
  _statusCheck(alive) {
    if (arguments.length === 0) {
      return this._ifRequestFailure() === false;
    }
    if (alive) {
      if (this.failed_requests >= this.max_fails) {
        this.logger.warn({
          host: this.url.host
        }, 'host @{host} is back online');
      }
      this.failed_requests = 0;
    } else {
      this.failed_requests++;
      if (this.failed_requests === this.max_fails) {
        this.logger.warn({
          host: this.url.host
        }, 'host @{host} is now offline');
      }
    }
    this.last_request_time = Date.now();
  }

  /**
   * If the request failure.
   * @return {boolean}
   * @private
   */
  _ifRequestFailure() {
    return this.failed_requests >= this.max_fails && Math.abs(Date.now() - this.last_request_time) < this.fail_timeout;
  }

  /**
   * Set up a proxy.
   * @param {*} hostname
   * @param {*} config
   * @param {*} mainconfig
   * @param {*} isHTTPS
   */
  _setupProxy(hostname, config, mainconfig, isHTTPS) {
    let noProxyList;
    const proxy_key = isHTTPS ? 'https_proxy' : 'http_proxy';

    // get http_proxy and no_proxy configs
    if (proxy_key in config) {
      this.proxy = config[proxy_key];
    } else if (proxy_key in mainconfig) {
      this.proxy = mainconfig[proxy_key];
    }
    if ('no_proxy' in config) {
      noProxyList = config.no_proxy;
    } else if ('no_proxy' in mainconfig) {
      noProxyList = mainconfig.no_proxy;
    }

    // use wget-like algorithm to determine if proxy shouldn't be used
    if (hostname[0] !== '.') {
      hostname = '.' + hostname;
    }
    if (_lodash.default.isString(noProxyList) && noProxyList.length) {
      noProxyList = noProxyList.split(',');
    }
    if (_lodash.default.isArray(noProxyList)) {
      for (let i = 0; i < noProxyList.length; i++) {
        let noProxyItem = noProxyList[i];
        if (noProxyItem[0] !== '.') {
          noProxyItem = '.' + noProxyItem;
        }
        if (hostname.lastIndexOf(noProxyItem) === hostname.length - noProxyItem.length) {
          if (this.proxy) {
            debug('not using proxy for %o, excluded by %o rule', this.url.href, noProxyItem);
            // @ts-ignore
            this.proxy = false;
          }
          break;
        }
      }
    }

    // if it's non-string (i.e. "false"), don't use it
    if (_lodash.default.isString(this.proxy) === false) {
      // @ts-ignore
      delete this.proxy;
    } else {
      debug('using proxy %o for %o', this.url.href, this.proxy);
    }
  }
}
var _default = ProxyStorage;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWJ1ZyIsImJ1aWxkRGVidWciLCJlbmNvZGUiLCJ0aGluZyIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJqc29uQ29udGVudFR5cGUiLCJIRUFERVJTIiwiSlNPTiIsImNvbnRlbnRUeXBlQWNjZXB0Iiwic2V0Q29uZmlnIiwiY29uZmlnIiwia2V5IiwiZGVmIiwiXyIsImlzTmlsIiwiUHJveHlTdG9yYWdlIiwiY29uc3RydWN0b3IiLCJtYWluQ29uZmlnIiwiZmFpbGVkX3JlcXVlc3RzIiwidXNlckFnZW50IiwidXNlcl9hZ2VudCIsImNhIiwibG9nZ2VyIiwic2VydmVyX2lkIiwidXJsIiwiVVJMIiwicGFyc2UiLCJfc2V0dXBQcm94eSIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJ0aW1lb3V0IiwiTnVtYmVyIiwid2FybiIsImpvaW4iLCJtYXhhZ2UiLCJwYXJzZUludGVydmFsIiwibWF4X2ZhaWxzIiwiZmFpbF90aW1lb3V0Iiwic3RyaWN0X3NzbCIsIkJvb2xlYW4iLCJhZ2VudF9vcHRpb25zIiwia2VlcEFsaXZlIiwibWF4U29ja2V0cyIsIm1heEZyZWVTb2NrZXRzIiwicmVxdWVzdCIsIm9wdGlvbnMiLCJjYiIsImpzb24iLCJfc3RhdHVzQ2hlY2siLCJzdHJlYW1SZWFkIiwiU3RyZWFtIiwiUmVhZGFibGUiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJFcnJvckNvZGUiLCJnZXRJbnRlcm5hbEVycm9yIiwiQVBJX0VSUk9SIiwiVVBMSU5LX09GRkxJTkUiLCJlbWl0IiwiX3JlYWQiLCJvbiIsInNlbGYiLCJoZWFkZXJzIiwiX3NldEhlYWRlcnMiLCJfYWRkUHJveHlIZWFkZXJzIiwicmVxIiwiX292ZXJyaWRlV2l0aFVwTGlua0NvbmZMb2NhbGlnSGVhZGVycyIsIm1ldGhvZCIsInVyaSIsInVyaV9mdWxsIiwiaW5mbyIsImlzT2JqZWN0Iiwic3RyaW5naWZ5IiwicmVxdWVzdENhbGxiYWNrIiwiZXJyIiwicmVzIiwiYm9keSIsImVycm9yIiwicmVzcG9uc2VMZW5ndGgiLCJsZW5ndGgiLCJwcm9jZXNzQm9keSIsImxvZ0FjdGl2aXR5IiwibWVzc2FnZSIsInN0YXR1c0NvZGUiLCJ0b1N0cmluZyIsIkNIQVJBQ1RFUl9FTkNPRElORyIsIlVURjgiLCJfZXJyIiwiaXNTdHJpbmciLCJodHRwIiwidW5kZWZpbmVkIiwic3RhdHVzIiwiYnl0ZXMiLCJpbiIsIm91dCIsInJlcXVlc3RPcHRpb25zIiwicHJveHkiLCJlbmNvZGluZyIsImd6aXAiLCJzdHJpY3RTU0wiLCJhZ2VudE9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJzdGF0dXNDYWxsZWQiLCJfdmVyZGFjY2lvX2Fib3J0ZWQiLCJkb19sb2ciLCJpc051bGwiLCJhY2NlcHQiLCJBQ0NFUFQiLCJhY2NlcHRFbmNvZGluZyIsIkFDQ0VQVF9FTkNPRElORyIsIlVTRVJfQUdFTlQiLCJnZXQiLCJfc2V0QXV0aCIsImF1dGgiLCJBVVRIT1JJWkFUSU9OIiwidG9rZW4iLCJfdGhyb3dFcnJvckF1dGgiLCJ0b2tlbkNvbmYiLCJ0b2tlbl9lbnYiLCJlbnYiLCJpc0Jvb2xlYW4iLCJOUE1fVE9LRU4iLCJFUlJPUl9DT0RFIiwidG9rZW5fcmVxdWlyZWQiLCJ0eXBlIiwiVE9LRU5fQkFTSUMiLCJfc2V0SGVhZGVyQXV0aG9yaXphdGlvbiIsIkVycm9yIiwiX3R5cGUiLCJ0b0xvd2VyQ2FzZSIsIlRPS0VOX0JFQVJFUiIsInVwcGVyRmlyc3QiLCJidWlsZFRva2VuIiwiaXNVcGxpbmtWYWxpZCIsInVybFBhcnNlZCIsImlzSFRUUFMiLCJ1cmxEb21haW5QYXJzZWQiLCJwb3J0IiwiZ2V0SG9zdCIsImhvc3QiLCJpc01hdGNoUHJvdG9jb2wiLCJpc01hdGNoSG9zdCIsImlzTWF0Y2hQYXRoIiwicGF0aCIsImluZGV4T2YiLCJnZXRSZW1vdGVNZXRhZGF0YSIsIm5hbWUiLCJjYWxsYmFjayIsImV0YWciLCJIVFRQX1NUQVRVUyIsIk5PVF9GT1VORCIsImdldE5vdEZvdW5kIiwiTk9UX1BBQ0tBR0VfVVBMSU5LIiwiT0siLCJNVUxUSVBMRV9DSE9JQ0VTIiwiQkFEX1NUQVRVU19DT0RFIiwicmVtb3RlU3RhdHVzIiwiZmV0Y2hUYXJiYWxsIiwic3RyZWFtIiwiUmVhZFRhcmJhbGwiLCJjdXJyZW50X2xlbmd0aCIsImV4cGVjdGVkX2xlbmd0aCIsImFib3J0IiwicmVhZFN0cmVhbSIsIkFjY2VwdCIsIk5PVF9GSUxFX1VQTElOSyIsIkhFQURFUl9UWVBFIiwiQ09OVEVOVF9MRU5HVEgiLCJwaXBlIiwiZGF0YSIsIkNPTlRFTlRfTUlTTUFUQ0giLCJzZWFyY2giLCJ0cmFuc2Zvcm1TdHJlYW0iLCJQYXNzVGhyb3VnaCIsIm9iamVjdE1vZGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVmZXJlciIsInBhcnNlUGFja2FnZSIsInBrZyIsImlzT2JqZWN0T3JBcnJheSIsIlN0cmluZyIsIm1hdGNoIiwianNvblN0cmVhbSIsIkNPTlRFTlRfRU5DT0RJTkciLCJHWklQIiwiemxpYiIsImNyZWF0ZVVuemlwIiwiSlNPTlN0cmVhbSIsImNvbm5lY3Rpb24iLCJyZW1vdGVBZGRyZXNzIiwiYWxpdmUiLCJhcmd1bWVudHMiLCJfaWZSZXF1ZXN0RmFpbHVyZSIsImxhc3RfcmVxdWVzdF90aW1lIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJhYnMiLCJtYWluY29uZmlnIiwibm9Qcm94eUxpc3QiLCJwcm94eV9rZXkiLCJub19wcm94eSIsInNwbGl0IiwiaXNBcnJheSIsImkiLCJub1Byb3h5SXRlbSIsImxhc3RJbmRleE9mIiwiaHJlZiJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdXAtc3RvcmFnZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSlNPTlN0cmVhbSBmcm9tICdKU09OU3RyZWFtJztcbmltcG9ydCBidWlsZERlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcmVxdWVzdCBmcm9tICdyZXF1ZXN0JztcbmltcG9ydCBTdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCBVUkwsIHsgVXJsV2l0aFN0cmluZ1F1ZXJ5IH0gZnJvbSAndXJsJztcbmltcG9ydCB6bGliIGZyb20gJ3psaWInO1xuXG5pbXBvcnQgeyBSZWFkVGFyYmFsbCB9IGZyb20gJ0B2ZXJkYWNjaW8vc3RyZWFtcyc7XG5pbXBvcnQgeyBDYWxsYmFjaywgQ29uZmlnLCBIZWFkZXJzLCBMb2dnZXIsIFBhY2thZ2UgfSBmcm9tICdAdmVyZGFjY2lvL3R5cGVzJztcbmltcG9ydCB7IGJ1aWxkVG9rZW4gfSBmcm9tICdAdmVyZGFjY2lvL3V0aWxzJztcblxuaW1wb3J0IHsgSVByb3h5LCBVcExpbmtDb25mTG9jYWwgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICBBUElfRVJST1IsXG4gIENIQVJBQ1RFUl9FTkNPRElORyxcbiAgRVJST1JfQ09ERSxcbiAgSEVBREVSUyxcbiAgSEVBREVSX1RZUEUsXG4gIEhUVFBfU1RBVFVTLFxuICBUT0tFTl9CQVNJQyxcbiAgVE9LRU5fQkVBUkVSLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvckNvZGUsIGlzT2JqZWN0LCBpc09iamVjdE9yQXJyYXksIHBhcnNlSW50ZXJ2YWwgfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgZGVidWcgPSBidWlsZERlYnVnKCd2ZXJkYWNjaW86dXAtc3RvcmFnZScpO1xuXG5jb25zdCBlbmNvZGUgPSBmdW5jdGlvbiAodGhpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRoaW5nKS5yZXBsYWNlKC9eJTQwLywgJ0AnKTtcbn07XG5cbmNvbnN0IGpzb25Db250ZW50VHlwZSA9IEhFQURFUlMuSlNPTjtcbmNvbnN0IGNvbnRlbnRUeXBlQWNjZXB0ID0gYCR7anNvbkNvbnRlbnRUeXBlfTtgO1xuXG4vKipcbiAqIEp1c3QgYSBoZWxwZXIgKGBjb25maWdba2V5XSB8fCBkZWZhdWx0YCBkb2Vzbid0IHdvcmsgYmVjYXVzZSBvZiB6ZXJvZXMpXG4gKi9cbmNvbnN0IHNldENvbmZpZyA9IChjb25maWcsIGtleSwgZGVmKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIF8uaXNOaWwoY29uZmlnW2tleV0pID09PSBmYWxzZSA/IGNvbmZpZ1trZXldIDogZGVmO1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIFN0b3JhZ2UgaW50ZXJmYWNlXG4gKiAoc2FtZSBmb3Igc3RvcmFnZS5qcywgbG9jYWwtc3RvcmFnZS5qcywgdXAtc3RvcmFnZS5qcylcbiAqL1xuY2xhc3MgUHJveHlTdG9yYWdlIGltcGxlbWVudHMgSVByb3h5IHtcbiAgcHVibGljIGNvbmZpZzogVXBMaW5rQ29uZkxvY2FsO1xuICBwdWJsaWMgZmFpbGVkX3JlcXVlc3RzOiBudW1iZXI7XG4gIHB1YmxpYyB1c2VyQWdlbnQ6IHN0cmluZztcbiAgcHVibGljIGNhOiBzdHJpbmcgfCB2b2lkO1xuICBwdWJsaWMgbG9nZ2VyOiBMb2dnZXI7XG4gIHB1YmxpYyBzZXJ2ZXJfaWQ6IHN0cmluZztcbiAgcHVibGljIHVybDogYW55O1xuICBwdWJsaWMgbWF4YWdlOiBudW1iZXI7XG4gIHB1YmxpYyB0aW1lb3V0OiBudW1iZXI7XG4gIHB1YmxpYyBtYXhfZmFpbHM6IG51bWJlcjtcbiAgcHVibGljIGZhaWxfdGltZW91dDogbnVtYmVyO1xuICBwdWJsaWMgYWdlbnRfb3B0aW9uczogYW55O1xuICAvLyBGSVhNRTogdXBuYW1lIGlzIGFzc2lnbmVkIHRvIGVhY2ggaW5zdGFuY2VcbiAgLy8gQHRzLWlnbm9yZVxuICBwdWJsaWMgdXBuYW1lOiBzdHJpbmc7XG4gIC8vIEZJWE1FOiBwcm94eSBjYW4gYmUgYm9vbGVhbiBvciBvYmplY3QsIHNvbWV0aGluZyBzbWVsbHMgaGVyZVxuICAvLyBAdHMtaWdub3JlXG4gIHB1YmxpYyBwcm94eTogc3RyaW5nIHwgdm9pZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBwdWJsaWMgbGFzdF9yZXF1ZXN0X3RpbWU6IG51bWJlciB8IG51bGw7XG4gIHB1YmxpYyBzdHJpY3Rfc3NsOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0geyp9IGNvbmZpZ1xuICAgKiBAcGFyYW0geyp9IG1haW5Db25maWdcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihjb25maWc6IFVwTGlua0NvbmZMb2NhbCwgbWFpbkNvbmZpZzogQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5mYWlsZWRfcmVxdWVzdHMgPSAwO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnVzZXJBZ2VudCA9IG1haW5Db25maWcudXNlcl9hZ2VudDtcbiAgICB0aGlzLmNhID0gY29uZmlnLmNhO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuc2VydmVyX2lkID0gbWFpbkNvbmZpZy5zZXJ2ZXJfaWQ7XG5cbiAgICB0aGlzLnVybCA9IFVSTC5wYXJzZSh0aGlzLmNvbmZpZy51cmwpO1xuXG4gICAgdGhpcy5fc2V0dXBQcm94eSh0aGlzLnVybC5ob3N0bmFtZSwgY29uZmlnLCBtYWluQ29uZmlnLCB0aGlzLnVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpO1xuXG4gICAgdGhpcy5jb25maWcudXJsID0gdGhpcy5jb25maWcudXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgICBpZiAodGhpcy5jb25maWcudGltZW91dCAmJiBOdW1iZXIodGhpcy5jb25maWcudGltZW91dCkgPj0gMTAwMCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgW1xuICAgICAgICAgICdUb28gYmlnIHRpbWVvdXQgdmFsdWU6ICcgKyB0aGlzLmNvbmZpZy50aW1lb3V0LFxuICAgICAgICAgICdXZSBjaGFuZ2VkIHRpbWUgZm9ybWF0IHRvIG5naW54LWxpa2Ugb25lJyxcbiAgICAgICAgICAnKHNlZSBodHRwOi8vbmdpbngub3JnL2VuL2RvY3Mvc3ludGF4Lmh0bWwpJyxcbiAgICAgICAgICAnc28gcGxlYXNlIHVwZGF0ZSB5b3VyIGNvbmZpZyBhY2NvcmRpbmdseScsXG4gICAgICAgIF0uam9pbignXFxuJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gYSBidW5jaCBvZiBkaWZmZXJlbnQgY29uZmlndXJhYmxlIHRpbWVyc1xuICAgIHRoaXMubWF4YWdlID0gcGFyc2VJbnRlcnZhbChzZXRDb25maWcodGhpcy5jb25maWcsICdtYXhhZ2UnLCAnMm0nKSk7XG4gICAgdGhpcy50aW1lb3V0ID0gcGFyc2VJbnRlcnZhbChzZXRDb25maWcodGhpcy5jb25maWcsICd0aW1lb3V0JywgJzMwcycpKTtcbiAgICB0aGlzLm1heF9mYWlscyA9IE51bWJlcihzZXRDb25maWcodGhpcy5jb25maWcsICdtYXhfZmFpbHMnLCAyKSk7XG4gICAgdGhpcy5mYWlsX3RpbWVvdXQgPSBwYXJzZUludGVydmFsKHNldENvbmZpZyh0aGlzLmNvbmZpZywgJ2ZhaWxfdGltZW91dCcsICc1bScpKTtcbiAgICB0aGlzLnN0cmljdF9zc2wgPSBCb29sZWFuKHNldENvbmZpZyh0aGlzLmNvbmZpZywgJ3N0cmljdF9zc2wnLCB0cnVlKSk7XG4gICAgdGhpcy5hZ2VudF9vcHRpb25zID0gc2V0Q29uZmlnKHRoaXMuY29uZmlnLCAnYWdlbnRfb3B0aW9ucycsIHtcbiAgICAgIGtlZXBBbGl2ZTogdHJ1ZSxcbiAgICAgIG1heFNvY2tldHM6IDQwLFxuICAgICAgbWF4RnJlZVNvY2tldHM6IDEwLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFuIGFzc2V0LlxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICogQHBhcmFtIHsqfSBjYlxuICAgKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICAgKi9cbiAgcHJpdmF0ZSByZXF1ZXN0KG9wdGlvbnM6IGFueSwgY2I/OiBDYWxsYmFjayk6IFN0cmVhbS5SZWFkYWJsZSB7XG4gICAgbGV0IGpzb247XG5cbiAgICBpZiAodGhpcy5fc3RhdHVzQ2hlY2soKSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHN0cmVhbVJlYWQgPSBuZXcgU3RyZWFtLlJlYWRhYmxlKCk7XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcihBUElfRVJST1IuVVBMSU5LX09GRkxJTkUpKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1SZWFkLmVtaXQoJ2Vycm9yJywgRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoQVBJX0VSUk9SLlVQTElOS19PRkZMSU5FKSk7XG4gICAgICB9KTtcblxuICAgICAgc3RyZWFtUmVhZC5fcmVhZCA9IGZ1bmN0aW9uICgpOiB2b2lkIHt9O1xuICAgICAgLy8gcHJldmVudGluZyAnVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudCdcbiAgICAgIHN0cmVhbVJlYWQub24oJ2Vycm9yJywgZnVuY3Rpb24gKCk6IHZvaWQge30pO1xuICAgICAgcmV0dXJuIHN0cmVhbVJlYWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVyczogSGVhZGVycyA9IHRoaXMuX3NldEhlYWRlcnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9hZGRQcm94eUhlYWRlcnMob3B0aW9ucy5yZXEsIGhlYWRlcnMpO1xuICAgIHRoaXMuX292ZXJyaWRlV2l0aFVwTGlua0NvbmZMb2NhbGlnSGVhZGVycyhoZWFkZXJzKTtcblxuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnO1xuICAgIGNvbnN0IHVyaSA9IG9wdGlvbnMudXJpX2Z1bGwgfHwgdGhpcy5jb25maWcudXJsICsgb3B0aW9ucy51cmk7XG5cbiAgICBzZWxmLmxvZ2dlci5pbmZvKFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgdXJpOiB1cmksXG4gICAgICB9LFxuICAgICAgXCJtYWtpbmcgcmVxdWVzdDogJ0B7bWV0aG9kfSBAe3VyaX0nXCJcbiAgICApO1xuXG4gICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMuanNvbikpIHtcbiAgICAgIGpzb24gPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pO1xuICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBoZWFkZXJzWydDb250ZW50LVR5cGUnXSB8fCBIRUFERVJTLkpTT047XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdENhbGxiYWNrID0gY2JcbiAgICAgID8gZnVuY3Rpb24gKGVyciwgcmVzLCBib2R5KTogdm9pZCB7XG4gICAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlTGVuZ3RoID0gZXJyID8gMCA6IGJvZHkubGVuZ3RoO1xuXG4gICAgICAgICAgcHJvY2Vzc0JvZHkoKTtcbiAgICAgICAgICBsb2dBY3Rpdml0eSgpO1xuXG4gICAgICAgICAgY2IoZXJyLCByZXMsIGJvZHkpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUGVyZm9ybSBhIGRlY29kZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQm9keSgpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5qc29uICYmIHJlcy5zdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keS50b1N0cmluZyhDSEFSQUNURVJfRU5DT0RJTkcuVVRGOCkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHt9O1xuICAgICAgICAgICAgICAgIGVyciA9IF9lcnI7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWVyciAmJiBpc09iamVjdChib2R5KSkge1xuICAgICAgICAgICAgICBpZiAoXy5pc1N0cmluZyhib2R5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gYm9keS5lcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBQZXJmb3JtIGEgbG9nLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIGxvZ0FjdGl2aXR5KCk6IHZvaWQge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIkB7IXN0YXR1c30sIHJlcTogJ0B7cmVxdWVzdC5tZXRob2R9IEB7cmVxdWVzdC51cmx9J1wiO1xuICAgICAgICAgICAgbWVzc2FnZSArPSBlcnJvciA/ICcsIGVycm9yOiBAeyFlcnJvcn0nIDogJywgYnl0ZXM6IEB7Ynl0ZXMuaW59L0B7Ynl0ZXMub3V0fSc7XG4gICAgICAgICAgICBzZWxmLmxvZ2dlci5odHRwKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXJyOiBlcnIgfHwgdW5kZWZpbmVkLCAvLyBpZiBlcnJvciBpcyBudWxsL2ZhbHNlIGNoYW5nZSB0aGlzIHRvIHVuZGVmaW5lZCBzbyBpdCB3b250IGxvZ1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBtZXRob2QsIHVybDogdXJpIH0sXG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXMgIT0gbnVsbCA/IHJlcy5zdGF0dXNDb2RlIDogJ0VSUicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIGJ5dGVzOiB7XG4gICAgICAgICAgICAgICAgICBpbjoganNvbiA/IGpzb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICAgICAgICAgIG91dDogcmVzcG9uc2VMZW5ndGggfHwgMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICB1cmw6IHVyaSxcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIGJvZHk6IGpzb24sXG4gICAgICBwcm94eTogdGhpcy5wcm94eSxcbiAgICAgIGVuY29kaW5nOiBudWxsLFxuICAgICAgZ3ppcDogdHJ1ZSxcbiAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dCxcbiAgICAgIHN0cmljdFNTTDogdGhpcy5zdHJpY3Rfc3NsLFxuICAgICAgYWdlbnRPcHRpb25zOiB0aGlzLmFnZW50X29wdGlvbnMsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmNhKSB7XG4gICAgICByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RPcHRpb25zLCB7XG4gICAgICAgIGNhOiB0aGlzLmNhLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxID0gcmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgcmVxdWVzdENhbGxiYWNrKTtcblxuICAgIGxldCBzdGF0dXNDYWxsZWQgPSBmYWxzZTtcbiAgICByZXEub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24gKHJlcyk6IHZvaWQge1xuICAgICAgLy8gRklYTUU6IF92ZXJkYWNjaW9fYWJvcnRlZCBzZWVtcyBub3QgdXNlZFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKCFyZXEuX3ZlcmRhY2Npb19hYm9ydGVkICYmICFzdGF0dXNDYWxsZWQpIHtcbiAgICAgICAgc3RhdHVzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5fc3RhdHVzQ2hlY2sodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzTmlsKHJlcXVlc3RDYWxsYmFjaykgPT09IGZhbHNlKSB7XG4gICAgICAgIChmdW5jdGlvbiBkb19sb2coKTogdm9pZCB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiQHshc3RhdHVzfSwgcmVxOiAnQHtyZXF1ZXN0Lm1ldGhvZH0gQHtyZXF1ZXN0LnVybH0nIChzdHJlYW1pbmcpXCI7XG4gICAgICAgICAgc2VsZi5sb2dnZXIuaHR0cChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdGF0dXM6IF8uaXNOdWxsKHJlcykgPT09IGZhbHNlID8gcmVzLnN0YXR1c0NvZGUgOiAnRVJSJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKF9lcnIpOiB2b2lkIHtcbiAgICAgIC8vIEZJWE1FOiBfdmVyZGFjY2lvX2Fib3J0ZWQgc2VlbXMgbm90IHVzZWRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICghcmVxLl92ZXJkYWNjaW9fYWJvcnRlZCAmJiAhc3RhdHVzQ2FsbGVkKSB7XG4gICAgICAgIHN0YXR1c0NhbGxlZCA9IHRydWU7XG4gICAgICAgIHNlbGYuX3N0YXR1c0NoZWNrKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHJlcTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZGVmYXVsdCBoZWFkZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9zZXRIZWFkZXJzKG9wdGlvbnM6IGFueSk6IEhlYWRlcnMge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgY29uc3QgYWNjZXB0ID0gSEVBREVSUy5BQ0NFUFQ7XG4gICAgY29uc3QgYWNjZXB0RW5jb2RpbmcgPSBIRUFERVJTLkFDQ0VQVF9FTkNPRElORztcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBIRUFERVJTLlVTRVJfQUdFTlQ7XG5cbiAgICBoZWFkZXJzW2FjY2VwdF0gPSBoZWFkZXJzW2FjY2VwdF0gfHwgY29udGVudFR5cGVBY2NlcHQ7XG4gICAgaGVhZGVyc1thY2NlcHRFbmNvZGluZ10gPSBoZWFkZXJzW2FjY2VwdEVuY29kaW5nXSB8fCAnZ3ppcCc7XG4gICAgLy8gcmVnaXN0cnkubnBtanMub3JnIHdpbGwgb25seSByZXR1cm4gc2VhcmNoIHJlc3VsdCBpZiB1c2VyLWFnZW50IGluY2x1ZGUgc3RyaW5nICducG0nXG4gICAgaGVhZGVyc1t1c2VyQWdlbnRdID0gdGhpcy51c2VyQWdlbnRcbiAgICAgID8gYG5wbSAoJHt0aGlzLnVzZXJBZ2VudH0pYFxuICAgICAgOiBvcHRpb25zLnJlcT8uZ2V0KCd1c2VyLWFnZW50Jyk7XG5cbiAgICByZXR1cm4gdGhpcy5fc2V0QXV0aChoZWFkZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBjb25maWd1cmF0aW9uIGF1dGggYW5kIGFzc2lnbiBIZWFkZXIgYXV0aG9yaXphdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9zZXRBdXRoKGhlYWRlcnM6IGFueSk6IEhlYWRlcnMge1xuICAgIGNvbnN0IHsgYXV0aCB9ID0gdGhpcy5jb25maWc7XG5cbiAgICBpZiAoXy5pc05pbChhdXRoKSB8fCBoZWFkZXJzW0hFQURFUlMuQVVUSE9SSVpBVElPTl0pIHtcbiAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cblxuICAgIGlmIChfLmlzT2JqZWN0KGF1dGgpID09PSBmYWxzZSAmJiBfLmlzT2JqZWN0KGF1dGgudG9rZW4pID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fdGhyb3dFcnJvckF1dGgoJ0F1dGggaW52YWxpZCcpO1xuICAgIH1cblxuICAgIC8vIGdldCBOUE1fVE9LRU4gaHR0cDovL2Jsb2cubnBtanMub3JnL3Bvc3QvMTE4MzkzMzY4NTU1L2RlcGxveWluZy13aXRoLW5wbS1wcml2YXRlLW1vZHVsZXNcbiAgICAvLyBvciBnZXQgb3RoZXIgdmFyaWFibGUgZXhwb3J0IGluIGVudlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJkYWNjaW8vdmVyZGFjY2lvL3JlbGVhc2VzL3RhZy92Mi41LjBcbiAgICBsZXQgdG9rZW46IGFueTtcbiAgICBjb25zdCB0b2tlbkNvbmY6IGFueSA9IGF1dGg7XG5cbiAgICBpZiAoXy5pc05pbCh0b2tlbkNvbmYudG9rZW4pID09PSBmYWxzZSAmJiBfLmlzU3RyaW5nKHRva2VuQ29uZi50b2tlbikpIHtcbiAgICAgIHRva2VuID0gdG9rZW5Db25mLnRva2VuO1xuICAgIH0gZWxzZSBpZiAoXy5pc05pbCh0b2tlbkNvbmYudG9rZW5fZW52KSA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChfLmlzU3RyaW5nKHRva2VuQ29uZi50b2tlbl9lbnYpKSB7XG4gICAgICAgIHRva2VuID0gcHJvY2Vzcy5lbnZbdG9rZW5Db25mLnRva2VuX2Vudl07XG4gICAgICB9IGVsc2UgaWYgKF8uaXNCb29sZWFuKHRva2VuQ29uZi50b2tlbl9lbnYpICYmIHRva2VuQ29uZi50b2tlbl9lbnYpIHtcbiAgICAgICAgdG9rZW4gPSBwcm9jZXNzLmVudi5OUE1fVE9LRU47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihFUlJPUl9DT0RFLnRva2VuX3JlcXVpcmVkKTtcbiAgICAgICAgdGhpcy5fdGhyb3dFcnJvckF1dGgoRVJST1JfQ09ERS50b2tlbl9yZXF1aXJlZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gcHJvY2Vzcy5lbnYuTlBNX1RPS0VOO1xuICAgIH1cblxuICAgIGlmIChfLmlzTmlsKHRva2VuKSkge1xuICAgICAgdGhpcy5fdGhyb3dFcnJvckF1dGgoRVJST1JfQ09ERS50b2tlbl9yZXF1aXJlZCk7XG4gICAgfVxuXG4gICAgLy8gZGVmaW5lIHR5cGUgQXV0aCBhbGxvdyBiYXNpYyBhbmQgYmVhcmVyXG4gICAgY29uc3QgdHlwZSA9IHRva2VuQ29uZi50eXBlIHx8IFRPS0VOX0JBU0lDO1xuICAgIHRoaXMuX3NldEhlYWRlckF1dGhvcml6YXRpb24oaGVhZGVycywgdHlwZSwgdG9rZW4pO1xuXG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF90aHJvd0Vycm9yQXV0aChtZXNzYWdlOiBzdHJpbmcpOiBFcnJvciB7XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbiBIZWFkZXIgYXV0aG9yaXphdGlvbiB3aXRoIHR5cGUgYXV0aGVudGljYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9zZXRIZWFkZXJBdXRob3JpemF0aW9uKGhlYWRlcnM6IGFueSwgdHlwZTogc3RyaW5nLCB0b2tlbjogYW55KTogdm9pZCB7XG4gICAgY29uc3QgX3R5cGU6IHN0cmluZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChfdHlwZSAhPT0gVE9LRU5fQkVBUkVSLnRvTG93ZXJDYXNlKCkgJiYgX3R5cGUgIT09IFRPS0VOX0JBU0lDLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHRoaXMuX3Rocm93RXJyb3JBdXRoKGBBdXRoIHR5cGUgJyR7X3R5cGV9JyBub3QgYWxsb3dlZGApO1xuICAgIH1cblxuICAgIHR5cGUgPSBfLnVwcGVyRmlyc3QodHlwZSk7XG4gICAgaGVhZGVyc1tIRUFERVJTLkFVVEhPUklaQVRJT05dID0gYnVpbGRUb2tlbih0eXBlLCB0b2tlbik7XG4gIH1cblxuICAvKipcbiAgICogSXQgd2lsbCBhZGQgb3Igb3ZlcnJpZGUgc3BlY2lmaWVkIGhlYWRlcnMgZnJvbSBjb25maWcgZmlsZS5cbiAgICpcbiAgICogRWc6XG4gICAqXG4gICAqIHVwbGlua3M6XG4gICBucG1qczpcbiAgIHVybDogaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvXG4gICBoZWFkZXJzOlxuICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL3ZuZC5ucG0uaW5zdGFsbC12Mitqc29uOyBxPTEuMFwiXG4gICB2ZXJkYWNjaW8tc3RhZ2luZzpcbiAgIHVybDogaHR0cHM6Ly9teWNvbXBhbnkuY29tL25wbVxuICAgaGVhZGVyczpcbiAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgIGF1dGhvcml6YXRpb246IFwiQmFzaWMgWW91ckJhc2U2NEVuY29kZWRDcmVkZW50aWFscz09XCJcblxuICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfb3ZlcnJpZGVXaXRoVXBMaW5rQ29uZkxvY2FsaWdIZWFkZXJzKGhlYWRlcnM6IEhlYWRlcnMpOiBhbnkge1xuICAgIGlmICghdGhpcy5jb25maWcuaGVhZGVycykge1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgLy8gYWRkL292ZXJyaWRlIGhlYWRlcnMgc3BlY2lmaWVkIGluIHRoZSBjb25maWdcbiAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jb25maWcuaGVhZGVycykge1xuICAgICAgaGVhZGVyc1trZXldID0gdGhpcy5jb25maWcuaGVhZGVyc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBjYW4gZmV0Y2ggZnJvbSB0aGUgcHJvdmlkZWQgVVJMXG4gICAqIEBwYXJhbSB7Kn0gdXJsXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBwdWJsaWMgaXNVcGxpbmtWYWxpZCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHVybFBhcnNlZDogVXJsV2l0aFN0cmluZ1F1ZXJ5ID0gVVJMLnBhcnNlKHVybCk7XG4gICAgY29uc3QgaXNIVFRQUyA9ICh1cmxEb21haW5QYXJzZWQ6IFVSTCk6IGJvb2xlYW4gPT5cbiAgICAgIHVybERvbWFpblBhcnNlZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgJiZcbiAgICAgICh1cmxQYXJzZWQucG9ydCA9PT0gbnVsbCB8fCB1cmxQYXJzZWQucG9ydCA9PT0gJzQ0MycpO1xuICAgIGNvbnN0IGdldEhvc3QgPSAodXJsRG9tYWluUGFyc2VkKTogYm9vbGVhbiA9PlxuICAgICAgaXNIVFRQUyh1cmxEb21haW5QYXJzZWQpID8gdXJsRG9tYWluUGFyc2VkLmhvc3RuYW1lIDogdXJsRG9tYWluUGFyc2VkLmhvc3Q7XG4gICAgY29uc3QgaXNNYXRjaFByb3RvY29sOiBib29sZWFuID0gdXJsUGFyc2VkLnByb3RvY29sID09PSB0aGlzLnVybC5wcm90b2NvbDtcbiAgICBjb25zdCBpc01hdGNoSG9zdDogYm9vbGVhbiA9IGdldEhvc3QodXJsUGFyc2VkKSA9PT0gZ2V0SG9zdCh0aGlzLnVybCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGlzTWF0Y2hQYXRoOiBib29sZWFuID0gdXJsUGFyc2VkLnBhdGguaW5kZXhPZih0aGlzLnVybC5wYXRoKSA9PT0gMDtcblxuICAgIHJldHVybiBpc01hdGNoUHJvdG9jb2wgJiYgaXNNYXRjaEhvc3QgJiYgaXNNYXRjaFBhdGg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVtb3RlIHBhY2thZ2UgbWV0YWRhdGFcbiAgICogQHBhcmFtIHsqfSBuYW1lIHBhY2thZ2UgbmFtZVxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnMgcmVxdWVzdCBvcHRpb25zLCBlZzogZVRhZy5cbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGdldFJlbW90ZU1ldGFkYXRhKG5hbWU6IHN0cmluZywgb3B0aW9uczogYW55LCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKF8uaXNOaWwob3B0aW9ucy5ldGFnKSA9PT0gZmFsc2UpIHtcbiAgICAgIGhlYWRlcnNbJ0lmLU5vbmUtTWF0Y2gnXSA9IG9wdGlvbnMuZXRhZztcbiAgICAgIGhlYWRlcnNbSEVBREVSUy5BQ0NFUFRdID0gY29udGVudFR5cGVBY2NlcHQ7XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0KFxuICAgICAge1xuICAgICAgICB1cmk6IGAvJHtlbmNvZGUobmFtZSl9YCxcbiAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgcmVxOiBvcHRpb25zLnJlcSxcbiAgICAgIH0sXG4gICAgICAoZXJyLCByZXMsIGJvZHkpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXROb3RGb3VuZChBUElfRVJST1IuTk9UX1BBQ0tBR0VfVVBMSU5LKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocmVzLnN0YXR1c0NvZGUgPj0gSFRUUF9TVEFUVVMuT0sgJiYgcmVzLnN0YXR1c0NvZGUgPCBIVFRQX1NUQVRVUy5NVUxUSVBMRV9DSE9JQ0VTKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoXG4gICAgICAgICAgICBgJHtBUElfRVJST1IuQkFEX1NUQVRVU19DT0RFfTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGVycm9yLnJlbW90ZVN0YXR1cyA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgYm9keSwgcmVzLmhlYWRlcnMuZXRhZyk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHRhcmJhbGwgZnJvbSB0aGUgdXBsaW5rLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIGZldGNoVGFyYmFsbCh1cmw6IHN0cmluZykge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkVGFyYmFsbCh7fSk7XG4gICAgbGV0IGN1cnJlbnRfbGVuZ3RoID0gMDtcbiAgICBsZXQgZXhwZWN0ZWRfbGVuZ3RoO1xuXG4gICAgc3RyZWFtLmFib3J0ID0gKCkgPT4ge307XG4gICAgY29uc3QgcmVhZFN0cmVhbSA9IHRoaXMucmVxdWVzdCh7XG4gICAgICB1cmlfZnVsbDogdXJsLFxuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEFjY2VwdDogY29udGVudFR5cGVBY2NlcHQsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmVhZFN0cmVhbS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzOiBhbnkpIHtcbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBFcnJvckNvZGUuZ2V0Tm90Rm91bmQoQVBJX0VSUk9SLk5PVF9GSUxFX1VQTElOSykpO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzLnN0YXR1c0NvZGUgPj0gSFRUUF9TVEFUVVMuT0sgJiYgcmVzLnN0YXR1c0NvZGUgPCBIVFRQX1NUQVRVUy5NVUxUSVBMRV9DSE9JQ0VTKSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLmVtaXQoXG4gICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcihgYmFkIHVwbGluayBzdGF0dXMgY29kZTogJHtyZXMuc3RhdHVzQ29kZX1gKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHJlcy5oZWFkZXJzW0hFQURFUl9UWVBFLkNPTlRFTlRfTEVOR1RIXSkge1xuICAgICAgICBleHBlY3RlZF9sZW5ndGggPSByZXMuaGVhZGVyc1tIRUFERVJfVFlQRS5DT05URU5UX0xFTkdUSF07XG4gICAgICAgIHN0cmVhbS5lbWl0KEhFQURFUl9UWVBFLkNPTlRFTlRfTEVOR1RILCByZXMuaGVhZGVyc1tIRUFERVJfVFlQRS5DT05URU5UX0xFTkdUSF0pO1xuICAgICAgfVxuXG4gICAgICByZWFkU3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICB9KTtcblxuICAgIHJlYWRTdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9KTtcbiAgICByZWFkU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGN1cnJlbnRfbGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJlYWRTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBjdXJyZW50X2xlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlY3RlZF9sZW5ndGggJiYgY3VycmVudF9sZW5ndGggIT0gZXhwZWN0ZWRfbGVuZ3RoKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIEVycm9yQ29kZS5nZXRJbnRlcm5hbEVycm9yKEFQSV9FUlJPUi5DT05URU5UX01JU01BVENIKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgc3RyZWFtIHNlYXJjaC5cbiAgICogQHBhcmFtIHsqfSBvcHRpb25zIHJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAqL1xuICBwdWJsaWMgc2VhcmNoKG9wdGlvbnM6IGFueSk6IFN0cmVhbS5SZWFkYWJsZSB7XG4gICAgY29uc3QgdHJhbnNmb3JtU3RyZWFtOiBhbnkgPSBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICBjb25zdCByZXF1ZXN0U3RyZWFtOiBTdHJlYW0uUmVhZGFibGUgPSB0aGlzLnJlcXVlc3Qoe1xuICAgICAgdXJpOiBvcHRpb25zLnJlcS51cmwsXG4gICAgICByZXE6IG9wdGlvbnMucmVxLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAvLyBxdWVyeSBmb3Igc2VhcmNoXG4gICAgICAgIHJlZmVyZXI6IG9wdGlvbnMucmVxLmdldCgncmVmZXJlcicpLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHBhcnNlUGFja2FnZSA9IChwa2c6IFBhY2thZ2UpOiB2b2lkID0+IHtcbiAgICAgIGlmIChpc09iamVjdE9yQXJyYXkocGtnKSkge1xuICAgICAgICB0cmFuc2Zvcm1TdHJlYW0uZW1pdCgnZGF0YScsIHBrZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlcXVlc3RTdHJlYW0ub24oJ3Jlc3BvbnNlJywgKHJlcyk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFTdHJpbmcocmVzLnN0YXR1c0NvZGUpLm1hdGNoKC9eMlxcZFxcZCQvKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtU3RyZWFtLmVtaXQoXG4gICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcihgYmFkIHN0YXR1cyBjb2RlICR7cmVzLnN0YXR1c0NvZGV9IGZyb20gdXBsaW5rYClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZXF1ZXN0L3JlcXVlc3QjcmVxdWVzdG9wdGlvbnMtY2FsbGJhY2tcbiAgICAgIC8vIFJlcXVlc3QgbGlicmFyeSB3aWxsIG5vdCBkZWNvZGUgZ3ppcCBzdHJlYW0uXG4gICAgICBsZXQganNvblN0cmVhbTtcbiAgICAgIGlmIChyZXMuaGVhZGVyc1tIRUFERVJfVFlQRS5DT05URU5UX0VOQ09ESU5HXSA9PT0gSEVBREVSUy5HWklQKSB7XG4gICAgICAgIGpzb25TdHJlYW0gPSByZXMucGlwZSh6bGliLmNyZWF0ZVVuemlwKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAganNvblN0cmVhbSA9IHJlcztcbiAgICAgIH1cbiAgICAgIGpzb25TdHJlYW0ucGlwZShKU09OU3RyZWFtLnBhcnNlKCcqJykpLm9uKCdkYXRhJywgcGFyc2VQYWNrYWdlKTtcbiAgICAgIGpzb25TdHJlYW0ub24oJ2VuZCcsICgpOiB2b2lkID0+IHtcbiAgICAgICAgdHJhbnNmb3JtU3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXF1ZXN0U3RyZWFtLm9uKCdlcnJvcicsIChlcnI6IEVycm9yKTogdm9pZCA9PiB7XG4gICAgICB0cmFuc2Zvcm1TdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuXG4gICAgdHJhbnNmb3JtU3RyZWFtLmFib3J0ID0gKCk6IHZvaWQgPT4ge1xuICAgICAgLy8gRklYTUU6IHRoaXMgaXMgY2xlYXJseSBhIHBvdGVudGlhbCBpc3N1ZVxuICAgICAgLy8gdGhlcmUgaXMgbm8gYWJvcnQgbWV0aG9kIG9uIFN0cmVhbS5SZWFkYWJsZVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmVxdWVzdFN0cmVhbS5hYm9ydCgpO1xuICAgICAgdHJhbnNmb3JtU3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgIH07XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtU3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBwcm94eSBoZWFkZXJzLlxuICAgKiBGSVhNRTogb2JqZWN0IG11dGF0aW9ucywgaXQgc2hvdWxkIHJldHVybiBhbiBuZXcgb2JqZWN0XG4gICAqIEBwYXJhbSB7Kn0gcmVxIHRoZSBodHRwIHJlcXVlc3RcbiAgICogQHBhcmFtIHsqfSBoZWFkZXJzIHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICovXG4gIHByaXZhdGUgX2FkZFByb3h5SGVhZGVycyhyZXE6IGFueSwgaGVhZGVyczogYW55KTogdm9pZCB7XG4gICAgaWYgKHJlcSkge1xuICAgICAgLy8gT25seSBzdWJtaXQgWC1Gb3J3YXJkZWQtRm9yIGZpZWxkIGlmIHdlIGRvbid0IGhhdmUgYSBwcm94eSBzZWxlY3RlZFxuICAgICAgLy8gaW4gdGhlIGNvbmZpZyBmaWxlLlxuICAgICAgLy9cbiAgICAgIC8vIE90aGVyd2lzZSBtaXNjb25maWd1cmVkIHByb3h5IGNvdWxkIHJldHVybiA0MDc6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmxpZHdrYS9zaW5vcGlhL2lzc3Vlcy8yNTRcbiAgICAgIC8vXG4gICAgICAvLyBGSVhNRTogcHJveHkgbG9naWMgaXMgb2RkLCBzb21ldGhpbmcgaXMgd3JvbmcgaGVyZS5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICghdGhpcy5wcm94eSkge1xuICAgICAgICBoZWFkZXJzWyd4LWZvcndhcmRlZC1mb3InXSA9XG4gICAgICAgICAgKHJlcS5nZXQoJ3gtZm9yd2FyZGVkLWZvcicpID8gcmVxLmdldCgneC1mb3J3YXJkZWQtZm9yJykgKyAnLCAnIDogJycpICtcbiAgICAgICAgICByZXEuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsd2F5cyBhdHRhY2ggVmlhIGhlYWRlciB0byBhdm9pZCBsb29wcywgZXZlbiBpZiB3ZSdyZSBub3QgcHJveHlpbmdcbiAgICBoZWFkZXJzWyd2aWEnXSA9IHJlcSAmJiByZXEuZ2V0KCd2aWEnKSA/IHJlcS5nZXQoJ3ZpYScpICsgJywgJyA6ICcnO1xuXG4gICAgaGVhZGVyc1sndmlhJ10gKz0gJzEuMSAnICsgdGhpcy5zZXJ2ZXJfaWQgKyAnIChWZXJkYWNjaW8pJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSByZW1vdGUgaG9zdCBpcyBhdmFpbGFibGUuXG4gICAqIEBwYXJhbSB7Kn0gYWxpdmVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHByaXZhdGUgX3N0YXR1c0NoZWNrKGFsaXZlPzogYm9vbGVhbik6IGJvb2xlYW4gfCB2b2lkIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lmUmVxdWVzdEZhaWx1cmUoKSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhbGl2ZSkge1xuICAgICAgaWYgKHRoaXMuZmFpbGVkX3JlcXVlc3RzID49IHRoaXMubWF4X2ZhaWxzKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdDogdGhpcy51cmwuaG9zdCxcbiAgICAgICAgICB9LFxuICAgICAgICAgICdob3N0IEB7aG9zdH0gaXMgYmFjayBvbmxpbmUnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLmZhaWxlZF9yZXF1ZXN0cyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFpbGVkX3JlcXVlc3RzKys7XG4gICAgICBpZiAodGhpcy5mYWlsZWRfcmVxdWVzdHMgPT09IHRoaXMubWF4X2ZhaWxzKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdDogdGhpcy51cmwuaG9zdCxcbiAgICAgICAgICB9LFxuICAgICAgICAgICdob3N0IEB7aG9zdH0gaXMgbm93IG9mZmxpbmUnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0X3JlcXVlc3RfdGltZSA9IERhdGUubm93KCk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHJlcXVlc3QgZmFpbHVyZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX2lmUmVxdWVzdEZhaWx1cmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZmFpbGVkX3JlcXVlc3RzID49IHRoaXMubWF4X2ZhaWxzICYmXG4gICAgICBNYXRoLmFicyhEYXRlLm5vdygpIC0gKHRoaXMubGFzdF9yZXF1ZXN0X3RpbWUgYXMgbnVtYmVyKSkgPCB0aGlzLmZhaWxfdGltZW91dFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGEgcHJveHkuXG4gICAqIEBwYXJhbSB7Kn0gaG9zdG5hbWVcbiAgICogQHBhcmFtIHsqfSBjb25maWdcbiAgICogQHBhcmFtIHsqfSBtYWluY29uZmlnXG4gICAqIEBwYXJhbSB7Kn0gaXNIVFRQU1xuICAgKi9cbiAgcHJpdmF0ZSBfc2V0dXBQcm94eShcbiAgICBob3N0bmFtZTogc3RyaW5nLFxuICAgIGNvbmZpZzogVXBMaW5rQ29uZkxvY2FsLFxuICAgIG1haW5jb25maWc6IENvbmZpZyxcbiAgICBpc0hUVFBTOiBib29sZWFuXG4gICk6IHZvaWQge1xuICAgIGxldCBub1Byb3h5TGlzdDtcbiAgICBjb25zdCBwcm94eV9rZXk6IHN0cmluZyA9IGlzSFRUUFMgPyAnaHR0cHNfcHJveHknIDogJ2h0dHBfcHJveHknO1xuXG4gICAgLy8gZ2V0IGh0dHBfcHJveHkgYW5kIG5vX3Byb3h5IGNvbmZpZ3NcbiAgICBpZiAocHJveHlfa2V5IGluIGNvbmZpZykge1xuICAgICAgdGhpcy5wcm94eSA9IGNvbmZpZ1twcm94eV9rZXldO1xuICAgIH0gZWxzZSBpZiAocHJveHlfa2V5IGluIG1haW5jb25maWcpIHtcbiAgICAgIHRoaXMucHJveHkgPSBtYWluY29uZmlnW3Byb3h5X2tleV07XG4gICAgfVxuICAgIGlmICgnbm9fcHJveHknIGluIGNvbmZpZykge1xuICAgICAgbm9Qcm94eUxpc3QgPSBjb25maWcubm9fcHJveHk7XG4gICAgfSBlbHNlIGlmICgnbm9fcHJveHknIGluIG1haW5jb25maWcpIHtcbiAgICAgIG5vUHJveHlMaXN0ID0gbWFpbmNvbmZpZy5ub19wcm94eTtcbiAgICB9XG5cbiAgICAvLyB1c2Ugd2dldC1saWtlIGFsZ29yaXRobSB0byBkZXRlcm1pbmUgaWYgcHJveHkgc2hvdWxkbid0IGJlIHVzZWRcbiAgICBpZiAoaG9zdG5hbWVbMF0gIT09ICcuJykge1xuICAgICAgaG9zdG5hbWUgPSAnLicgKyBob3N0bmFtZTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1N0cmluZyhub1Byb3h5TGlzdCkgJiYgbm9Qcm94eUxpc3QubGVuZ3RoKSB7XG4gICAgICBub1Byb3h5TGlzdCA9IG5vUHJveHlMaXN0LnNwbGl0KCcsJyk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNBcnJheShub1Byb3h5TGlzdCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9Qcm94eUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vUHJveHlJdGVtID0gbm9Qcm94eUxpc3RbaV07XG4gICAgICAgIGlmIChub1Byb3h5SXRlbVswXSAhPT0gJy4nKSB7XG4gICAgICAgICAgbm9Qcm94eUl0ZW0gPSAnLicgKyBub1Byb3h5SXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdG5hbWUubGFzdEluZGV4T2Yobm9Qcm94eUl0ZW0pID09PSBob3N0bmFtZS5sZW5ndGggLSBub1Byb3h5SXRlbS5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAodGhpcy5wcm94eSkge1xuICAgICAgICAgICAgZGVidWcoJ25vdCB1c2luZyBwcm94eSBmb3IgJW8sIGV4Y2x1ZGVkIGJ5ICVvIHJ1bGUnLCB0aGlzLnVybC5ocmVmLCBub1Byb3h5SXRlbSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnByb3h5ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgaXQncyBub24tc3RyaW5nIChpLmUuIFwiZmFsc2VcIiksIGRvbid0IHVzZSBpdFxuICAgIGlmIChfLmlzU3RyaW5nKHRoaXMucHJveHkpID09PSBmYWxzZSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZGVsZXRlIHRoaXMucHJveHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCd1c2luZyBwcm94eSAlbyBmb3IgJW8nLCB0aGlzLnVybC5ocmVmLCB0aGlzLnByb3h5KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJveHlTdG9yYWdlO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQVVBO0FBQ0E7QUFBOEU7QUFBQTtBQUFBO0FBQUE7QUFFOUUsTUFBTUEsS0FBSyxHQUFHLElBQUFDLGNBQVUsRUFBQyxzQkFBc0IsQ0FBQztBQUVoRCxNQUFNQyxNQUFNLEdBQUcsVUFBVUMsS0FBSyxFQUFVO0VBQ3RDLE9BQU9DLGtCQUFrQixDQUFDRCxLQUFLLENBQUMsQ0FBQ0UsT0FBTyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUM7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