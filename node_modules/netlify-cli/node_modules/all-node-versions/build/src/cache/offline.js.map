{"version":3,"sources":["../../../src/cache/offline.js"],"names":["readCachedVersions","handleOfflineError","error","isOfflineError","cachedVersions","undefined","message","OFFLINE_ERROR_MESSAGES","some","offlineErrorMessage","includes"],"mappings":"AAAA,OAASA,kBAAT,KAAmC,WAAnC;;;;AAIA,MAAO,MAAMC,CAAAA,kBAAkB,CAAG,eAAgBC,KAAhB,CAAuB;AACvD,GAAI,CAACC,cAAc,CAACD,KAAD,CAAnB,CAA4B;AAC1B,KAAMA,CAAAA,KAAN;AACD;;AAED,KAAME,CAAAA,cAAc,CAAG,KAAMJ,CAAAA,kBAAkB,CAAC,KAAD,CAA/C;;AAEA,GAAII,cAAc,GAAKC,SAAvB,CAAkC;AAChC,KAAMH,CAAAA,KAAN;AACD;;AAED,MAAOE,CAAAA,cAAP;AACD,CAZM;;;;;AAiBP,KAAMD,CAAAA,cAAc,CAAG,SAAU,CAAEG,OAAF,CAAV,CAAuB;AAC5C,MAAOC,CAAAA,sBAAsB,CAACC,IAAvB,CAA4B,CAACC,mBAAD;AACjCH,OAAO,CAACI,QAAR,CAAiBD,mBAAjB,CADK,CAAP;;AAGD,CAJD;;AAMA,KAAMF,CAAAA,sBAAsB,CAAG,CAAC,aAAD,CAAgB,sBAAhB,CAA/B","sourcesContent":["import { readCachedVersions } from './read.js'\n\n// When offline, we try to reuse cached versions if any is available.\n// We do this even if `fetch` option is `true`.\nexport const handleOfflineError = async function (error) {\n  if (!isOfflineError(error)) {\n    throw error\n  }\n\n  const cachedVersions = await readCachedVersions(false)\n\n  if (cachedVersions === undefined) {\n    throw error\n  }\n\n  return cachedVersions\n}\n\n// On Windows, offline errors are the same as wrong `mirror` option errors.\n// Since we cannot distinguish them, we also use offline cache when `mirror`\n// option is invalid.\nconst isOfflineError = function ({ message }) {\n  return OFFLINE_ERROR_MESSAGES.some((offlineErrorMessage) =>\n    message.includes(offlineErrorMessage),\n  )\n}\n\nconst OFFLINE_ERROR_MESSAGES = ['getaddrinfo', 'connect ECONNREFUSED']\n"],"file":"src/cache/offline.js"}