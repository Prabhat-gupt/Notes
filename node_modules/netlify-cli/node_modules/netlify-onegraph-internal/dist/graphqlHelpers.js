"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPersistableOperation = exports.gatherHardcodedValues = exports.normalizeOperationsDoc = exports.formElComponent = exports.remixFormInput = exports.formInput = exports.patchSubscriptionWebhookSecretField = exports.patchSubscriptionWebhookField = exports.typeScriptTypeNameForOperation = exports.typeScriptSignatureForFragment = exports.typeScriptDefinitionObjectForFragment = exports.typeScriptSignatureForOperation = exports.typeScriptDefinitionObjectForOperation = exports.listCount = exports.typeScriptSignatureForOperationVariables = exports.guessVariableDescriptions = exports.typeScriptForGraphQLType = exports.gatherVariableDefinitions = exports.gatherAllReferencedTypes = void 0;
var internalConsole_1 = require("./internalConsole");
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
exports.default = capitalizeFirstLetter;
var scalarMap = {
    ID: { kind: "scalar", type: "string" },
    Int: { kind: "scalar", type: "number" },
    Float: { kind: "scalar", type: "number" },
    String: { kind: "scalar", type: "string" },
    Boolean: { kind: "scalar", type: "boolean" },
    JSON: { kind: "scalar", type: "unknown" },
    JSONObject: { kind: "scalar", type: "Record<string, unknown>" },
    GitHubGitObjectID: { kind: "scalar", type: "string" },
    GitHubURI: { kind: "scalar", type: "string" },
};
function gatherAllReferencedTypes(GraphQL, schema, query) {
    var getNamedType = GraphQL.getNamedType, TypeInfo = GraphQL.TypeInfo, visit = GraphQL.visit, visitWithTypeInfo = GraphQL.visitWithTypeInfo;
    var types = new Set([]);
    var typeInfo = new TypeInfo(schema);
    visit(query, visitWithTypeInfo(typeInfo, {
        enter: function () {
            var fullType = typeInfo.getType();
            if (!!fullType) {
                var typ = getNamedType(fullType);
                if (typ)
                    types.add(typ.name.toLocaleLowerCase().replace("oneme", ""));
            }
        },
    }));
    var result = Array.from(types);
    return result;
}
exports.gatherAllReferencedTypes = gatherAllReferencedTypes;
function unwrapOutputType(GraphQL, outputType) {
    var isWrappingType = GraphQL.isWrappingType;
    var unwrappedType = outputType;
    while (isWrappingType(unwrappedType)) {
        unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
}
function gatherVariableDefinitions(GraphQL, definition) {
    var _a;
    var print = GraphQL.print;
    var extract = function (varDef) { return [
        varDef.variable.name.value,
        print(varDef.type),
    ]; };
    return (((_a = definition === null || definition === void 0 ? void 0 : definition.variableDefinitions) === null || _a === void 0 ? void 0 : _a.map(extract)) || []).sort(function (_a, _b) {
        var a = _a[0];
        var b = _b[0];
        return a.localeCompare(b);
    });
}
exports.gatherVariableDefinitions = gatherVariableDefinitions;
function typeScriptForGraphQLType(GraphQL, schema, gqlType) {
    var getNamedType = GraphQL.getNamedType, isEnumType = GraphQL.isEnumType, isInputObjectType = GraphQL.isInputObjectType, isListType = GraphQL.isListType, isNonNullType = GraphQL.isNonNullType, isObjectType = GraphQL.isObjectType, isWrappingType = GraphQL.isWrappingType;
    var scalarMap = {
        String: "string",
        ID: "string",
        Int: "number",
        Float: "number",
        Boolean: "boolean",
        GitHubURI: "string",
        GitHubTimestamp: "string",
        JSONObject: "Record<string, unknown>",
    };
    if (isListType(gqlType)) {
        var subType = typeScriptForGraphQLType(GraphQL, schema, gqlType.ofType);
        return "Array<" + subType + ">";
    }
    else if (isObjectType(gqlType) || isInputObjectType(gqlType)) {
        var fields = Object.values(gqlType.getFields()).map(function (field) {
            var nullable = !isNonNullType(field.type);
            var type = typeScriptForGraphQLType(GraphQL, schema, field.type);
            var description = !!field.description
                ? "/**\n  * " + field.description + "\n  */\n  "
                : "";
            return description + "\"" + field.name + "\"" + (nullable ? "?" : "") + ": " + type;
        });
        if (fields.length > 0) {
            return "{" + fields.join("; ") + "}";
        }
        else {
            return "Record<string, unknown> /* No fields found */";
        }
    }
    else if (isWrappingType(gqlType)) {
        return typeScriptForGraphQLType(GraphQL, schema, gqlType.ofType);
    }
    else if (isEnumType(gqlType)) {
        var values = gqlType.getValues();
        var enums = values.map(function (enumValue) { return "\"" + enumValue.value + "\""; });
        return enums.join(" | ");
    }
    else {
        var namedType = getNamedType(gqlType);
        var basicType = scalarMap[namedType === null || namedType === void 0 ? void 0 : namedType.name] || "unknown";
        return basicType;
    }
}
exports.typeScriptForGraphQLType = typeScriptForGraphQLType;
var guessVariableDescriptions = function (GraphQL, schema, operationDefinition, variableNames) {
    var getNamedType = GraphQL.getNamedType, isInputObjectType = GraphQL.isInputObjectType, Kind = GraphQL.Kind, TypeInfo = GraphQL.TypeInfo, visit = GraphQL.visit, visitWithTypeInfo = GraphQL.visitWithTypeInfo;
    var variableRecords = {};
    for (var _i = 0, variableNames_1 = variableNames; _i < variableNames_1.length; _i++) {
        var variableName = variableNames_1[_i];
        variableRecords[variableName] = {
            usageCount: 0,
            descriptions: new Set(),
        };
    }
    var typeInfo = new TypeInfo(schema);
    var argHandler = function (node) {
        var _a;
        if (node.value && node.value.kind === Kind.VARIABLE) {
            var argument = typeInfo.getArgument();
            var existingRecord = variableRecords[node.value.name.value];
            var existingDescription = existingRecord === null || existingRecord === void 0 ? void 0 : existingRecord.descriptions;
            if (existingDescription && (argument === null || argument === void 0 ? void 0 : argument.description)) {
                existingDescription.add(argument.description);
            }
            if (!existingRecord) {
                internalConsole_1.internalConsole.warn("Undefined variable $" + node.value.name.value + " found in operation " + ((_a = operationDefinition.name) === null || _a === void 0 ? void 0 : _a.value));
                return node;
            }
            variableRecords[node.value.name.value] = __assign(__assign({}, existingRecord), { usageCount: (existingRecord === null || existingRecord === void 0 ? void 0 : existingRecord.usageCount) + 1 });
        }
        return node;
    };
    var objectFieldHandler = function (node) {
        var _a;
        if (node.value && node.value.kind === Kind.VARIABLE) {
            var parentType = typeInfo.getParentInputType();
            var namedParentType = getNamedType(parentType);
            var field = void 0;
            if (isInputObjectType(namedParentType)) {
                field = namedParentType === null || namedParentType === void 0 ? void 0 : namedParentType.getFields()[node.name.value];
                var existingRecord = variableRecords[node.value.name.value];
                var existingDescription = existingRecord === null || existingRecord === void 0 ? void 0 : existingRecord.descriptions;
                if (existingDescription && (field === null || field === void 0 ? void 0 : field.description)) {
                    existingDescription.add(field.description);
                }
                if (!existingRecord) {
                    internalConsole_1.internalConsole.warn("Undefined variable $" + node.value.name.value + " found in operation " + ((_a = operationDefinition.name) === null || _a === void 0 ? void 0 : _a.value));
                    return node;
                }
                variableRecords[node.value.name.value] = __assign(__assign({}, existingRecord), { usageCount: existingRecord.usageCount + 1 });
            }
            return node;
        }
    };
    visit(operationDefinition, visitWithTypeInfo(typeInfo, {
        Argument: argHandler,
        ObjectField: objectFieldHandler,
    }));
    return variableRecords;
};
exports.guessVariableDescriptions = guessVariableDescriptions;
function typeScriptSignatureForOperationVariables(GraphQL, variableNames, schema, operationDefinition) {
    var print = GraphQL.print, parseType = GraphQL.parseType, typeFromAST = GraphQL.typeFromAST, isNonNullType = GraphQL.isNonNullType;
    var helper = function (variableDefinition) {
        var variableName = variableDefinition.variable.name.value;
        var result = [
            variableName,
            variableDefinition,
        ];
        return result;
    };
    var variables = (operationDefinition.variableDefinitions || [])
        .map(helper)
        .filter(function (_a) {
        var variableName = _a[0];
        return variableNames.includes(variableName);
    });
    var variableUsageInfo = (0, exports.guessVariableDescriptions)(GraphQL, schema, operationDefinition, variableNames);
    var typesObject = variables
        .map(function (_a) {
        var varName = _a[0], varDef = _a[1];
        var printedType = print(varDef.type);
        var parsedType = parseType(printedType);
        var gqlType = typeFromAST(schema, parsedType);
        if (!gqlType) {
            return;
        }
        var isRequired = isNonNullType(gqlType);
        var tsType = typeScriptForGraphQLType(GraphQL, schema, gqlType);
        return [varName, tsType, isRequired];
    })
        .filter(Boolean);
    var typeFields = typesObject
        .map(function (_a) {
        var name = _a[0], tsType = _a[1], isRequired = _a[2];
        var usageCount = variableUsageInfo[name].usageCount;
        var descriptions = variableUsageInfo[name].descriptions;
        var description = "";
        if (usageCount > 0 && (descriptions === null || descriptions === void 0 ? void 0 : descriptions.size) === 1) {
            description = " /**\n * " + Array.from(descriptions)[0] + "\n */\n ";
        }
        var optionalMark = isRequired ? "" : "?";
        return description + "\"" + name + "\"" + optionalMark + ": " + tsType;
    })
        .join(";  \n");
    var formattedTypeFields = typeFields.trim() === ""
        ? ""
        : "\n " + typeFields + "\n";
    var types = "{" + formattedTypeFields + "}";
    return types === "" ? "null" : types;
}
exports.typeScriptSignatureForOperationVariables = typeScriptSignatureForOperationVariables;
function listCount(GraphQL, gqlType) {
    var isListType = GraphQL.isListType, isWrappingType = GraphQL.isWrappingType;
    var inspectedType = gqlType;
    var listCount = 0;
    var totalCount = 0;
    while (isWrappingType(inspectedType)) {
        if (isListType(inspectedType)) {
            listCount = listCount + 1;
        }
        totalCount = totalCount + 1;
        if (totalCount > 30) {
            internalConsole_1.internalConsole.warn("Bailing on potential infinite recursion");
            return -99;
        }
        inspectedType = inspectedType.ofType;
    }
    return listCount;
}
exports.listCount = listCount;
var unknownScalar = { kind: "scalar", type: "unknown" };
var dummyOut = {
    kind: "object",
    namedFragments: [],
    inlineFragments: [],
    selections: {
        data: {
            kind: "selection_field",
            name: "data",
            description: "Any data retrieved by the function will be returned here [Placeholder]",
            isNullable: false,
            type: {
                kind: "scalar",
                type: "Record<string, unknown> /** Unable to find types for operation */",
            },
        },
        errors: {
            kind: "selection_field",
            name: "errors",
            description: "Any errors in the function will be returned here [Placeholder]",
            isNullable: true,
            type: {
                kind: "array",
                type: {
                    kind: "scalar",
                    type: "GraphQLError",
                },
            },
        },
    },
};
function typeScriptDefinitionObjectForOperation(GraphQL, schema, operationDefinition, fragmentDefinitions) {
    var getNamedType = GraphQL.getNamedType, isEnumType = GraphQL.isEnumType, isInterfaceType = GraphQL.isInterfaceType, isUnionType = GraphQL.isUnionType, isListType = GraphQL.isListType, isNonNullType = GraphQL.isNonNullType, isNullableType = GraphQL.isNullableType, isObjectType = GraphQL.isObjectType, isScalarType = GraphQL.isScalarType, isWrappingType = GraphQL.isWrappingType, Kind = GraphQL.Kind, typeFromAST = GraphQL.typeFromAST;
    var unionHelper = function (type, selectionSet) {
        var objects = [];
        var namedFragments = [];
        var typenameFields = [];
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (selection.kind === Kind.FRAGMENT_SPREAD) {
                var fragmentName = selection.name.value;
                var definedFragment = fragmentDefinitions[fragmentName];
                if (definedFragment) {
                    namedFragments.push({
                        name: fragmentName,
                        typeCondition: definedFragment.typeCondition.name.value,
                    });
                }
            }
            else if (selection.kind === Kind.INLINE_FRAGMENT) {
                var typeCondition = selection.typeCondition;
                if (!typeCondition) {
                    return;
                }
                var typeConditionName = typeCondition.name.value;
                var fragmentGqlType = typeFromAST(schema, typeCondition);
                if (!fragmentGqlType || !isObjectType(fragmentGqlType)) {
                    return;
                }
                var fragmentSelectionAsObject = objectHelper(fragmentGqlType, selection.selectionSet);
                if (!fragmentSelectionAsObject) {
                    return;
                }
                objects.push(__assign(__assign({}, fragmentSelectionAsObject), { __typename: typeConditionName }));
            }
            else if (selection.kind === Kind.FIELD) {
                var alias = (_a = selection.alias) === null || _a === void 0 ? void 0 : _a.value;
                var name_1 = selection.name.value;
                var displayedName = alias || name_1;
                if (name_1 === "__typename") {
                    typenameFields.push(displayedName);
                }
            }
            else {
                internalConsole_1.internalConsole.warn("unionHelper got a non-field selection: " + selection);
            }
        });
        var final = {
            kind: "union",
            description: type.description,
            objects: objects,
            namedFragments: namedFragments,
            typenameFields: typenameFields,
            typename: type.name,
        };
        return final;
    };
    var interfaceHelper = function (type, selectionSet) {
        var inlineFragments = [];
        var namedFragments = [];
        var selections = {};
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (selection.kind === Kind.FRAGMENT_SPREAD) {
                var fragmentName = selection.name.value;
                var definedFragment = fragmentDefinitions[fragmentName];
                if (definedFragment) {
                    namedFragments.push({
                        name: fragmentName,
                        typeCondition: definedFragment.typeCondition.name.value,
                    });
                }
            }
            else if (selection.kind === Kind.INLINE_FRAGMENT) {
                var typeCondition = selection.typeCondition;
                if (!typeCondition) {
                    return;
                }
                var typeConditionName = typeCondition.name.value;
                var fragmentGqlType = typeFromAST(schema, typeCondition);
                if (!fragmentGqlType || !isObjectType(fragmentGqlType)) {
                    return;
                }
                var fragmentSelectionAsObject = objectHelper(fragmentGqlType, selection.selectionSet);
                if (!fragmentSelectionAsObject) {
                    return;
                }
                var fragmentSelections = fragmentSelectionAsObject.selections;
                var inlineFragment = {
                    kind: "inlineFragment",
                    typeCondition: typeConditionName,
                    selections: fragmentSelections,
                };
                inlineFragments.push(inlineFragment);
            }
            else if (selection.kind === Kind.FIELD) {
                var parentNamedType = getNamedType(type);
                var alias = (_a = selection.alias) === null || _a === void 0 ? void 0 : _a.value;
                var name_2 = selection.name.value;
                var displayedName = alias || name_2;
                var field = (isObjectType(parentNamedType) || isInterfaceType(parentNamedType)) &&
                    parentNamedType.getFields()[name_2];
                if (name_2 === "__typename") {
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        isNullable: true,
                        type: {
                            kind: "scalar",
                            type: "string",
                        },
                    };
                    return;
                }
                if (name_2.startsWith("__")) {
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        isNullable: false,
                        type: {
                            kind: "scalar",
                            description: "Internal GraphQL field",
                            type: "unknown",
                        },
                    };
                    return;
                }
                if (!field) {
                    internalConsole_1.internalConsole.warn("Could not find field " + name_2 + " on " + parentNamedType.name + " among " + 
                    // @ts-ignore
                    Object.keys(parentNamedType.getFields()));
                    return;
                }
                var gqlType = field.type;
                var namedType = getNamedType(gqlType);
                var isNullable = isNullableType(gqlType);
                var subSelectionSet = selection.selectionSet;
                if (isWrappingType(gqlType)) {
                    var value = helper(gqlType, subSelectionSet || {
                        kind: Kind.SELECTION_SET,
                        selections: [],
                    });
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            isNullable: isNullable,
                            description: field.description,
                        };
                    }
                }
                else if (isScalarType(namedType)) {
                    var scalar = scalarHelper(namedType);
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        type: scalar,
                        isNullable: isNullable,
                        description: field.description,
                    };
                }
                else if (isEnumType(namedType)) {
                    var dummySelectionSet = {
                        kind: Kind.SELECTION_SET,
                        selections: [],
                    };
                    var value = helper(gqlType, dummySelectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            isNullable: isNullable,
                            description: field.description,
                        };
                    }
                }
                else if (subSelectionSet) {
                    var value = helper(gqlType, selection.selectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            isNullable: isNullable,
                            description: field.description,
                        };
                    }
                }
            }
            else {
                internalConsole_1.internalConsole.warn("interfaceHelper got a non-field selection " + selection);
            }
        });
        var final = {
            kind: "interface",
            namedFragments: namedFragments,
            inlineFragments: inlineFragments,
            selections: selections,
        };
        return final;
    };
    var objectHelper = function (type, selectionSet) {
        var inlineFragments = [];
        var namedFragments = [];
        var selections = {};
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (selection.kind === Kind.FRAGMENT_SPREAD) {
                var fragmentName = selection.name.value;
                var definedFragment = fragmentDefinitions[fragmentName];
                if (definedFragment) {
                    namedFragments.push({
                        name: fragmentName,
                        typeCondition: definedFragment.typeCondition.name.value,
                    });
                }
            }
            else if (selection.kind === Kind.INLINE_FRAGMENT) {
                var typeCondition = selection.typeCondition;
                if (!typeCondition) {
                    return;
                }
                var typeConditionName = typeCondition.name.value;
                var fragmentGqlType = typeFromAST(schema, typeCondition);
                if (!fragmentGqlType || !isObjectType(fragmentGqlType)) {
                    return;
                }
                var fragmentSelectionAsObject = objectHelper(fragmentGqlType, selection.selectionSet);
                if (!fragmentSelectionAsObject) {
                    return;
                }
                var fragmentSelections = fragmentSelectionAsObject.selections;
                var inlineFragment = {
                    kind: "inlineFragment",
                    typeCondition: typeConditionName,
                    selections: fragmentSelections,
                };
                inlineFragments.push(inlineFragment);
            }
            else if (selection.kind === Kind.FIELD) {
                var parentNamedType = getNamedType(type);
                var alias = (_a = selection.alias) === null || _a === void 0 ? void 0 : _a.value;
                var name_3 = selection.name.value;
                var displayedName = alias || name_3;
                if (name_3 === "__typename") {
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        isNullable: true,
                        type: {
                            kind: "scalar",
                            type: "string",
                        },
                    };
                }
                if (name_3.startsWith("__")) {
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        isNullable: false,
                        type: {
                            kind: "scalar",
                            description: "Internal GraphQL field",
                            type: "unknown",
                        },
                    };
                }
                var field = (isObjectType(parentNamedType) || isInterfaceType(parentNamedType)) &&
                    parentNamedType.getFields()[name_3];
                if (!field) {
                    internalConsole_1.internalConsole.warn("Could not find field " + name_3 + " in " + 
                    // @ts-ignore
                    Object.keys(parentNamedType.getFields()));
                    return;
                }
                var gqlType = field.type;
                var namedType = getNamedType(gqlType);
                var isNullable = isNullableType(gqlType);
                var subSelectionSet = selection.selectionSet;
                if (isWrappingType(gqlType)) {
                    var value = helper(gqlType, subSelectionSet || {
                        kind: Kind.SELECTION_SET,
                        selections: [],
                    });
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            description: field.description,
                            isNullable: isNullable,
                            type: value,
                        };
                    }
                }
                else if (isScalarType(namedType)) {
                    var scalar = scalarHelper(namedType);
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        description: field.description,
                        isNullable: isNullable,
                        type: scalar,
                    };
                }
                else if (isEnumType(namedType)) {
                    var dummySelectionSet = {
                        kind: Kind.SELECTION_SET,
                        selections: [],
                    };
                    var value = helper(gqlType, dummySelectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            description: field.description,
                            isNullable: isNullable,
                            type: value,
                        };
                    }
                }
                else if (subSelectionSet) {
                    var value = helper(gqlType, selection.selectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            description: field.description,
                            isNullable: isNullable,
                            type: value,
                        };
                    }
                }
            }
            else {
                internalConsole_1.internalConsole.warn("objectHelper got a non-field selection " + selection);
            }
        });
        var final = {
            kind: "object",
            namedFragments: namedFragments,
            inlineFragments: inlineFragments,
            selections: selections,
        };
        return final;
    };
    var arrayHelper = function (type, selectionSet) {
        var parentType = isListType(type) && type.ofType;
        if (!parentType) {
            return;
        }
        var subType = helper(parentType, selectionSet);
        if (!subType) {
            return;
        }
        var final = {
            kind: "array",
            type: subType,
        };
        return final;
    };
    var scalarHelper = function (parentGqlType) {
        var scalarType = parentGqlType;
        var scalarName = scalarType.name;
        var scalar = scalarMap[scalarName];
        if (!scalar) {
            scalar = unknownScalar;
        }
        return scalar;
    };
    var helper = function (parentGqlType, selectionSet) {
        if (isListType(parentGqlType)) {
            return arrayHelper(parentGqlType, selectionSet);
        }
        else if (isWrappingType(parentGqlType) && isNonNullType(parentGqlType)) {
            return helper(parentGqlType.ofType, selectionSet);
        }
        else if (isObjectType(parentGqlType)) {
            return objectHelper(parentGqlType, selectionSet);
        }
        else if (isInterfaceType(parentGqlType)) {
            return interfaceHelper(parentGqlType, selectionSet);
        }
        else if (isUnionType(parentGqlType)) {
            return unionHelper(parentGqlType, selectionSet);
        }
        else if (isScalarType(parentGqlType)) {
            return scalarHelper(parentGqlType);
        }
        else if (isEnumType(parentGqlType)) {
            var values = parentGqlType
                .getValues()
                .map(function (enumValue) { return "\"" + enumValue.value + "\""; });
            var outEnum = {
                kind: "enum",
                values: values,
            };
            return outEnum;
        }
        else {
            internalConsole_1.internalConsole.warn("Unrecognized type in operation " + parentGqlType);
        }
    };
    var baseGqlType = (operationDefinition.kind === Kind.OPERATION_DEFINITION
        ? operationDefinition.operation === "query"
            ? schema.getQueryType()
            : operationDefinition.operation === "mutation"
                ? schema.getMutationType()
                : operationDefinition.operation === "subscription"
                    ? schema.getSubscriptionType()
                    : null
        : operationDefinition.kind === Kind.FRAGMENT_DEFINITION
            ? schema.getType(operationDefinition.typeCondition.name.value)
            : null);
    var selections = operationDefinition.selectionSet;
    var sub;
    if (baseGqlType) {
        sub = helper(baseGqlType, selections);
    }
    else {
        return dummyOut;
    }
    if (sub && sub.kind === "object") {
        var result = {
            kind: "object",
            namedFragments: [],
            inlineFragments: [],
            selections: {
                data: {
                    kind: "selection_field",
                    name: "data",
                    description: "Any data from the function will be returned here",
                    isNullable: false,
                    type: sub,
                },
                errors: {
                    kind: "selection_field",
                    name: "errors",
                    description: "Any errors from the function will be returned here",
                    isNullable: true,
                    type: {
                        kind: "array",
                        type: {
                            kind: "scalar",
                            type: "GraphQLError",
                        },
                    },
                },
            },
        };
        return result;
    }
    else {
        return dummyOut;
    }
}
exports.typeScriptDefinitionObjectForOperation = typeScriptDefinitionObjectForOperation;
var printObject = function (obj) {
    var fieldSelections = obj.selections;
    var fieldSelectionCount = Object.keys(obj.selections).length;
    var fields = Object.values(fieldSelections)
        .map(function (fieldSelection) {
        var fields = printOut(fieldSelection.type);
        var value = fields;
        var description = !!fieldSelection.description
            ? "/**\n  * " + fieldSelection.description + "\n  */\n"
            : "";
        return "" + description + fieldSelection.name + (fieldSelection.isNullable ? "?" : "") + ": " + value + ";";
    })
        .join("\n  ");
    var value;
    var modifiedInlineFragments = obj.inlineFragments.map(function (inlineFragment) {
        var typenameSelection = {
            kind: "selection_field",
            name: "__typename",
            isNullable: true,
            type: {
                kind: "scalar",
                type: "\"" + inlineFragment.typeCondition + "\"",
            },
            description: "Used to tell what type of object was returned for the selection",
        };
        return __assign(__assign({}, inlineFragment), { selections: __assign(__assign({}, inlineFragment.selections), { __typename: typenameSelection }) });
    });
    var printedInlineFragmentsBody = modifiedInlineFragments
        .map(function (inlineFragment) {
        var fields = Object.values(inlineFragment.selections)
            .map(function (fieldSelection) {
            var fields = printOut(fieldSelection.type);
            var value = fields;
            var description = !!fieldSelection.description
                ? "/**\n    * " + fieldSelection.description + "\n    */\n  "
                : "";
            return "" + description + fieldSelection.name + (fieldSelection.isNullable ? "?" : "") + ": " + value + ";";
        })
            .join("\n  ");
        return "{" + fields + "}";
    })
        .join(" | ");
    var printedInlineFragments = modifiedInlineFragments.length === 0
        ? ""
        : " | (" + printedInlineFragmentsBody + ")";
    if (fieldSelectionCount === 0 &&
        obj.namedFragments.length === 0 &&
        obj.inlineFragments.length === 0) {
        value =
            "/** No fields, named fragments, or inline fragments found */ Record<string, unknown>";
    }
    else if (obj.namedFragments.length === 0 &&
        obj.inlineFragments.length === 0) {
        value = "{\n  " + fields + "\n}";
    }
    else if (fieldSelectionCount === 0) {
        value = obj.namedFragments
            .map(function (_a) {
            var name = _a.name;
            return name;
        })
            .join(" & ") + " " + printedInlineFragments;
    }
    else {
        var subFields = fieldSelectionCount > 0
            ? "& {\n  " + fields + "\n}"
            : "";
        value = obj.namedFragments
            .map(function (_a) {
            var name = _a.name;
            return name;
        })
            .join(" & ") + " " + subFields + " " + printedInlineFragments;
    }
    return value;
};
var printInterface = function (obj) {
    var fieldSelections = obj.selections;
    var fieldSelectionCount = Object.keys(obj.selections).length;
    var fields = Object.values(fieldSelections)
        .map(function (fieldSelection) {
        var fields = printOut(fieldSelection.type);
        var value = fields;
        var description = !!fieldSelection.description
            ? "/**\n  * " + fieldSelection.description + "\n  */\n"
            : "";
        return "" + description + fieldSelection.name + (fieldSelection.isNullable ? "?" : "") + ": " + value + ";";
    })
        .join("\n  ");
    var value;
    var modifiedInlineFragments = obj.inlineFragments.map(function (inlineFragment) {
        var typenameSelection = {
            kind: "selection_field",
            name: "__typename",
            isNullable: true,
            type: {
                kind: "scalar",
                type: "\"" + inlineFragment.typeCondition + "\"",
            },
            description: "Used to tell what type of object was returned for the selection",
        };
        return __assign(__assign({}, inlineFragment), { selections: __assign(__assign({}, inlineFragment.selections), { __typename: typenameSelection }) });
    });
    var unusedNamedFragments = new Set(__spreadArray([], obj.namedFragments.map(function (_a) {
        var name = _a.name;
        return name;
    }), true));
    var printedInlineFragmentsBody = modifiedInlineFragments
        .map(function (inlineFragment) {
        var inlineFragmentTypeCondition = inlineFragment.typeCondition;
        var fields = Object.values(inlineFragment.selections)
            .map(function (fieldSelection) {
            var fields = printOut(fieldSelection.type);
            var value = fields;
            var description = !!fieldSelection.description
                ? "/**\n    * " + fieldSelection.description + "\n    */\n  "
                : "";
            return "" + description + fieldSelection.name + (fieldSelection.isNullable ? "?" : "") + ": " + value + ";";
        })
            .join("\n  ");
        var matchingFragmentTypeConditions = obj.namedFragments
            .filter(function (_a) {
            var typeCondition = _a.typeCondition;
            return typeCondition === inlineFragmentTypeCondition;
        })
            .map(function (_a) {
            var name = _a.name;
            return name;
        });
        matchingFragmentTypeConditions.forEach(function (name) {
            return unusedNamedFragments.delete(name);
        });
        var baseObject = "{" + fields + "}";
        return matchingFragmentTypeConditions.length === 0
            ? baseObject
            : baseObject + " & " + matchingFragmentTypeConditions.join(" & ");
    })
        .join(" | ");
    var printedInlineFragments = modifiedInlineFragments.length === 0
        ? ""
        : " & (" + printedInlineFragmentsBody + ")";
    if (fieldSelectionCount === 0 &&
        obj.namedFragments.length === 0 &&
        obj.inlineFragments.length === 0) {
        value =
            "/** No fields, named fragments, or inline fragments found */ Record<string, unknown>";
    }
    else if (obj.namedFragments.length === 0 &&
        obj.inlineFragments.length === 0) {
        value = "{\n  " + fields + "\n}";
    }
    else if (fieldSelectionCount === 0) {
        value = (Array.from(unusedNamedFragments)
            .map(function (name) { return name; })
            .join(" & ") + " " + printedInlineFragments).trim();
    }
    else {
        var subFields = fieldSelectionCount > 0
            ? "& {\n  " + fields + "\n}"
            : "";
        value = (Array.from(unusedNamedFragments)
            .map(function (name) { return name; })
            .join(" & ") + " " + subFields + " " + printedInlineFragments).trim();
    }
    return value;
};
var printArray = function (out) {
    var value = printOut(out.type);
    if (value === "()") {
        internalConsole_1.internalConsole.warn("Empty array found during type generation: " + JSON.stringify(out, null, 2));
    }
    return "Array<" + value + ">";
};
var printUnion = function (out) {
    var modifiedObjects = out.objects.map(function (object) {
        var typenameSelections = out.typenameFields.reduce(function (acc, next) {
            var typenameSelection = {
                kind: "selection_field",
                name: next,
                isNullable: true,
                type: {
                    kind: "scalar",
                    type: "\"" + object.__typename + "\"",
                },
                description: "Used to tell what type of object was returned for the selection",
            };
            acc[next] = typenameSelection;
            return acc;
        }, {});
        return __assign(__assign({}, object), { selections: __assign(__assign({}, object.selections), typenameSelections) });
    });
    var unusedNamedFragments = new Set(out.namedFragments);
    var printed = modifiedObjects.map(function (object) {
        var baseObject = printObject(object);
        var matchingFragmentTypeConditions = out.namedFragments
            .filter(function (namedFragment) {
            var typeCondition = namedFragment.typeCondition;
            var matches = typeCondition === object.__typename;
            if (matches) {
                unusedNamedFragments.delete(namedFragment);
            }
            return matches;
        })
            .map(function (_a) {
            var name = _a.name;
            return name;
        });
        var objectWithMatchingNamedFragments = matchingFragmentTypeConditions.length === 0
            ? baseObject
            : baseObject + " & " + matchingFragmentTypeConditions.join(" & ");
        return objectWithMatchingNamedFragments;
    });
    var namedFragments = Array.from(unusedNamedFragments)
        .map(function (namedFragment) {
        return namedFragment.name;
    })
        .join(" & ");
    var unionJoins = printed.length === 0 ? "{}" : printed.join(" | ");
    return namedFragments + " & (" + unionJoins + ")";
};
var printOut = function (out) {
    if (out.kind === "scalar") {
        return out.type;
    }
    else if (out.kind === "object") {
        return printObject(out);
    }
    else if (out.kind === "array") {
        return printArray(out);
    }
    else if (out.kind === "enum") {
        return out.values.join(" | ");
    }
    else if (out.kind === "interface") {
        return printInterface(out);
    }
    else if (out.kind === "union") {
        return printUnion(out);
    }
    return "whoops";
};
function typeScriptSignatureForOperation(GraphQL, schema, operationDefinition, fragmentDefinitions) {
    var typeMap = typeScriptDefinitionObjectForOperation(GraphQL, schema, operationDefinition, fragmentDefinitions);
    var typeScript = printObject(typeMap);
    return typeScript;
}
exports.typeScriptSignatureForOperation = typeScriptSignatureForOperation;
function typeScriptDefinitionObjectForFragment(GraphQL, schema, fragmentDefinition, fragmentDefinitions) {
    var getNamedType = GraphQL.getNamedType, isEnumType = GraphQL.isEnumType, isInterfaceType = GraphQL.isInterfaceType, isListType = GraphQL.isListType, isNonNullType = GraphQL.isNonNullType, isNullableType = GraphQL.isNullableType, isObjectType = GraphQL.isObjectType, isScalarType = GraphQL.isScalarType, isUnionType = GraphQL.isUnionType, isWrappingType = GraphQL.isWrappingType, Kind = GraphQL.Kind, typeFromAST = GraphQL.typeFromAST;
    var dummyOut = {
        kind: "scalar",
        type: "Record<string, unknown> /** Scalar output not found */",
        description: "Fragment data unavailable when generating types",
    };
    var objectHelper = function (type, selectionSet) {
        var inlineFragments = [];
        var namedFragments = [];
        var selections = {};
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (selection.kind === Kind.FRAGMENT_SPREAD) {
                var fragmentName = selection.name.value;
                var definedFragment = fragmentDefinitions[fragmentName];
                if (definedFragment) {
                    namedFragments.push({
                        name: fragmentName,
                        typeCondition: definedFragment.typeCondition.name.value,
                    });
                }
                else {
                    internalConsole_1.internalConsole.warn("Could not find fragment " + fragmentName + " (referenced in " + fragmentDefinition.name.value + ") among defined fragments: " + Object.values(fragmentDefinitions)
                        .map(function (def) { var _a; return "\"" + ((_a = def.name) === null || _a === void 0 ? void 0 : _a.value) + "\""; })
                        .join(", "));
                }
            }
            else if (selection.kind === Kind.INLINE_FRAGMENT) {
                var typeCondition = selection.typeCondition;
                if (!typeCondition) {
                    return;
                }
                var typeConditionName = typeCondition.name.value;
                var fragmentGqlType = typeFromAST(schema, typeCondition);
                if (!fragmentGqlType || !isObjectType(fragmentGqlType)) {
                    return;
                }
                var fragmentSelectionAsObject = objectHelper(fragmentGqlType, selection.selectionSet);
                if (!fragmentSelectionAsObject) {
                    return;
                }
                var fragmentSelections = fragmentSelectionAsObject.selections;
                var inlineFragment = {
                    kind: "inlineFragment",
                    typeCondition: typeConditionName,
                    selections: fragmentSelections,
                };
                inlineFragments.push(inlineFragment);
            }
            else if (selection.kind === Kind.FIELD) {
                var parentNamedType = getNamedType(type);
                var alias = (_a = selection.alias) === null || _a === void 0 ? void 0 : _a.value;
                var name_4 = selection.name.value;
                var displayedName = alias || name_4;
                var field = (isObjectType(parentNamedType) || isInterfaceType(parentNamedType)) &&
                    parentNamedType.getFields()[name_4];
                if (name_4 === "__typename") {
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        isNullable: true,
                        type: {
                            kind: "scalar",
                            type: "\"" + parentNamedType.name + "\"",
                        },
                    };
                    return;
                }
                if (name_4.startsWith("__")) {
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        isNullable: false,
                        type: {
                            kind: "scalar",
                            description: "Internal GraphQL field",
                            type: "unknown",
                        },
                    };
                    return;
                }
                if (!field) {
                    internalConsole_1.internalConsole.warn("Could not find field " + name_4 + " on " + parentNamedType.name + " among " + 
                    // @ts-ignore
                    Object.keys(parentNamedType.getFields()));
                    return;
                }
                var gqlType = field.type;
                var namedType = getNamedType(gqlType);
                var isNullable = isNullableType(gqlType);
                var subSelectionSet = selection.selectionSet;
                if (isWrappingType(gqlType)) {
                    var value = helper(gqlType, selection.selectionSet || {
                        kind: Kind.SELECTION_SET,
                        selections: [],
                    });
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            isNullable: isNullable,
                            description: field.description,
                        };
                    }
                }
                else if (isScalarType(namedType)) {
                    var scalar = scalarHelper(namedType);
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        type: scalar,
                        isNullable: isNullable,
                        description: field.description,
                    };
                }
                else if (isEnumType(namedType)) {
                    var dummySelectionSet = {
                        kind: Kind.SELECTION_SET,
                        selections: [],
                    };
                    var value = helper(gqlType, dummySelectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            isNullable: isNullable,
                            description: field.description,
                        };
                    }
                }
                else if (subSelectionSet) {
                    var value = helper(gqlType, selection.selectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            isNullable: isNullable,
                            description: field.description,
                        };
                    }
                }
            }
            else {
                internalConsole_1.internalConsole.warn("objectHelper got a non-field selection " + selection);
            }
        });
        var final = {
            kind: "object",
            namedFragments: namedFragments,
            inlineFragments: inlineFragments,
            selections: selections,
        };
        return final;
    };
    var arrayHelper = function (type, selectionSet) {
        var parentGqlType = isListType(type) && type.ofType;
        if (!parentGqlType) {
            return;
        }
        var subType = helper(parentGqlType, selectionSet);
        if (!subType) {
            return;
        }
        var final = {
            kind: "array",
            type: subType,
        };
        return final;
    };
    var scalarHelper = function (parentGqlType) {
        var scalarType = parentGqlType;
        var scalarName = scalarType.name;
        var scalar = scalarMap[scalarName];
        if (!scalar) {
            scalar = unknownScalar;
        }
        return scalar;
    };
    var interfaceHelper = function (type, selectionSet) {
        var inlineFragments = [];
        var namedFragments = [];
        var selections = {};
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (selection.kind === Kind.FRAGMENT_SPREAD) {
                var fragmentName = selection.name.value;
                var definedFragment = fragmentDefinitions[fragmentName];
                if (definedFragment) {
                    namedFragments.push({
                        name: fragmentName,
                        typeCondition: definedFragment.typeCondition.name.value,
                    });
                }
            }
            else if (selection.kind === Kind.INLINE_FRAGMENT) {
                var typeCondition = selection.typeCondition;
                if (!typeCondition) {
                    return;
                }
                var typeConditionName = typeCondition.name.value;
                var fragmentGqlType = typeFromAST(schema, typeCondition);
                if (!fragmentGqlType || !isObjectType(fragmentGqlType)) {
                    return;
                }
                var fragmentSelectionAsObject = objectHelper(fragmentGqlType, selection.selectionSet);
                if (!fragmentSelectionAsObject) {
                    return;
                }
                var fragmentSelections = fragmentSelectionAsObject.selections;
                var inlineFragment = {
                    kind: "inlineFragment",
                    typeCondition: typeConditionName,
                    selections: fragmentSelections,
                };
                inlineFragments.push(inlineFragment);
            }
            else if (selection.kind === Kind.FIELD) {
                var parentNamedType = getNamedType(type);
                var alias = (_a = selection.alias) === null || _a === void 0 ? void 0 : _a.value;
                var name_5 = selection.name.value;
                var displayedName = alias || name_5;
                var field = (isObjectType(parentNamedType) || isInterfaceType(parentNamedType)) &&
                    parentNamedType.getFields()[name_5];
                if (name_5 === "__typename") {
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        isNullable: true,
                        type: {
                            kind: "scalar",
                            type: "string",
                        },
                    };
                    return;
                }
                if (name_5.startsWith("__")) {
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        isNullable: false,
                        type: {
                            kind: "scalar",
                            description: "Internal GraphQL field",
                            type: "unknown",
                        },
                    };
                    return;
                }
                if (!field) {
                    internalConsole_1.internalConsole.warn("Could not find field " + name_5 + " on " + parentNamedType.name + " among " + 
                    // @ts-ignore
                    Object.keys(parentNamedType.getFields()));
                    return;
                }
                var gqlType = field.type;
                var namedType = getNamedType(gqlType);
                var isNullable = isNullableType(gqlType);
                var subSelectionSet = selection.selectionSet;
                if (isWrappingType(gqlType)) {
                    var value = helper(gqlType, subSelectionSet || {
                        kind: Kind.SELECTION_SET,
                        selections: [],
                    });
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            isNullable: isNullable,
                            description: field.description,
                        };
                    }
                }
                else if (isScalarType(namedType)) {
                    var scalar = scalarHelper(namedType);
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        type: scalar,
                        isNullable: isNullable,
                        description: field.description,
                    };
                }
                else if (isEnumType(namedType)) {
                    var dummySelectionSet = {
                        kind: Kind.SELECTION_SET,
                        selections: [],
                    };
                    var value = helper(gqlType, dummySelectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            isNullable: isNullable,
                            description: field.description,
                        };
                    }
                }
                else if (subSelectionSet) {
                    var value = helper(gqlType, selection.selectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            isNullable: isNullable,
                            description: field.description,
                        };
                    }
                }
            }
            else {
                internalConsole_1.internalConsole.warn("interfaceHelper got a non-field selection " + selection);
            }
        });
        var final = {
            kind: "interface",
            namedFragments: namedFragments,
            inlineFragments: inlineFragments,
            selections: selections,
        };
        return final;
    };
    var unionHelper = function (type, selectionSet) {
        var objects = [];
        var namedFragments = [];
        var typenameFields = [];
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (selection.kind === Kind.FRAGMENT_SPREAD) {
                var fragmentName = selection.name.value;
                var definedFragment = fragmentDefinitions[fragmentName];
                if (definedFragment) {
                    namedFragments.push({
                        name: fragmentName,
                        typeCondition: definedFragment.typeCondition.name.value,
                    });
                }
            }
            else if (selection.kind === Kind.INLINE_FRAGMENT) {
                var typeCondition = selection.typeCondition;
                if (!typeCondition) {
                    return;
                }
                var typeConditionName = typeCondition.name.value;
                var fragmentGqlType = typeFromAST(schema, typeCondition);
                if (!fragmentGqlType || !isObjectType(fragmentGqlType)) {
                    return;
                }
                var fragmentSelectionAsObject = objectHelper(fragmentGqlType, selection.selectionSet);
                if (!fragmentSelectionAsObject) {
                    return;
                }
                objects.push(__assign(__assign({}, fragmentSelectionAsObject), { __typename: typeConditionName }));
            }
            else if (selection.kind === Kind.FIELD) {
                var alias = (_a = selection.alias) === null || _a === void 0 ? void 0 : _a.value;
                var name_6 = selection.name.value;
                var displayedName = alias || name_6;
                if (name_6 === "__typename") {
                    typenameFields.push(displayedName);
                }
            }
            else {
                internalConsole_1.internalConsole.warn("unionHelper got a non-field selection: " + selection);
            }
        });
        var final = {
            kind: "union",
            description: type.description,
            objects: objects,
            namedFragments: namedFragments,
            typenameFields: typenameFields,
            typename: type.name,
        };
        return final;
    };
    var helper = function (parentGqlType, selectionSet) {
        if (isListType(parentGqlType)) {
            return arrayHelper(parentGqlType, selectionSet);
        }
        else if (isWrappingType(parentGqlType) && isNonNullType(parentGqlType)) {
            return helper(parentGqlType.ofType, selectionSet);
        }
        else if (isObjectType(parentGqlType)) {
            return objectHelper(parentGqlType, selectionSet);
        }
        else if (isInterfaceType(parentGqlType)) {
            return interfaceHelper(parentGqlType, selectionSet);
        }
        else if (isUnionType(parentGqlType)) {
            return unionHelper(parentGqlType, selectionSet);
        }
        else if (isScalarType(parentGqlType)) {
            return scalarHelper(parentGqlType);
        }
        else if (isEnumType(parentGqlType)) {
            var values = parentGqlType
                .getValues()
                .map(function (enumValue) { return "\"" + enumValue.value + "\""; });
            var outEnum = {
                kind: "enum",
                values: values,
            };
            return outEnum;
        }
        else {
            internalConsole_1.internalConsole.warn("Unrecognized type in fragment " + parentGqlType);
        }
    };
    var baseGqlType = schema.getType(fragmentDefinition.typeCondition.name.value);
    var selections = fragmentDefinition.selectionSet;
    var sub;
    if (baseGqlType) {
        sub = helper(baseGqlType, selections);
    }
    else {
        return dummyOut;
    }
    if (sub && sub.kind === "object") {
        var result = sub;
        return result;
    }
    else if (sub && sub.kind === "union") {
        var result = sub;
        return result;
    }
    else if (sub && sub.kind === "interface") {
        var result = sub;
        return result;
    }
    else {
        internalConsole_1.internalConsole.warn("Unable to determine fragment output type");
        return dummyOut;
    }
}
exports.typeScriptDefinitionObjectForFragment = typeScriptDefinitionObjectForFragment;
function typeScriptSignatureForFragment(GraphQL, schema, fragmentDefinition, fragmentDefinitions) {
    var typeMap = typeScriptDefinitionObjectForFragment(GraphQL, schema, fragmentDefinition, fragmentDefinitions);
    var typeScript = printOut(typeMap);
    return typeScript;
}
exports.typeScriptSignatureForFragment = typeScriptSignatureForFragment;
function typeScriptTypeNameForOperation(name) {
    return capitalizeFirstLetter(name) + "Payload";
}
exports.typeScriptTypeNameForOperation = typeScriptTypeNameForOperation;
/**
 * Doesn't patch e.g. fragments
 */
function patchSubscriptionWebhookField(_a) {
    var _b;
    var GraphQL = _a.GraphQL, schema = _a.schema, definition = _a.definition;
    var Kind = GraphQL.Kind;
    if (definition.operation !== "subscription") {
        return definition;
    }
    var subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
        return definition;
    }
    var newSelections = definition.selectionSet.selections.map(function (selection) {
        var _a;
        if (selection.kind !== "Field")
            return selection;
        var field = subscriptionType.getFields()[selection.name.value];
        if (!field) {
            return selection;
        }
        var fieldHasWebhookUrlArg = field.args.some(function (arg) { return arg.name === "webhookUrl"; });
        var selectionHasWebhookUrlArg = (_a = selection.arguments) === null || _a === void 0 ? void 0 : _a.some(function (arg) { return arg.name.value === "webhookUrl"; });
        if (fieldHasWebhookUrlArg && !selectionHasWebhookUrlArg) {
            return __assign(__assign({}, selection), { arguments: __spreadArray(__spreadArray([], (selection.arguments || []), true), [
                    {
                        kind: Kind.ARGUMENT,
                        name: {
                            kind: Kind.NAME,
                            value: "webhookUrl",
                        },
                        value: {
                            kind: Kind.VARIABLE,
                            name: {
                                kind: Kind.NAME,
                                value: "netlifyGraphWebhookUrl",
                            },
                        },
                    },
                ], false) });
        }
        return selection;
    });
    var hasWebhookVariableDefinition = (_b = definition.variableDefinitions) === null || _b === void 0 ? void 0 : _b.find(function (varDef) { return varDef.variable.name.value === "netlifyGraphWebhookUrl"; });
    var netlifyGraphWebhookUrlVariable = {
        kind: Kind.VARIABLE_DEFINITION,
        type: {
            kind: Kind.NON_NULL_TYPE,
            type: {
                kind: Kind.NAMED_TYPE,
                name: {
                    kind: Kind.NAME,
                    value: "String",
                },
            },
        },
        variable: {
            kind: Kind.VARIABLE,
            name: {
                kind: Kind.NAME,
                value: "netlifyGraphWebhookUrl",
            },
        },
    };
    var variableDefinitions = !!hasWebhookVariableDefinition
        ? definition.variableDefinitions
        : __spreadArray(__spreadArray([], (definition.variableDefinitions || []), true), [
            netlifyGraphWebhookUrlVariable,
        ], false);
    return __assign(__assign({}, definition), { variableDefinitions: variableDefinitions, selectionSet: __assign(__assign({}, definition.selectionSet), { selections: newSelections }) });
}
exports.patchSubscriptionWebhookField = patchSubscriptionWebhookField;
function patchSubscriptionWebhookSecretField(_a) {
    var _b;
    var GraphQL = _a.GraphQL, schema = _a.schema, definition = _a.definition;
    var Kind = GraphQL.Kind;
    if (definition.operation !== "subscription") {
        return definition;
    }
    var subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
        return definition;
    }
    var newSelections = definition.selectionSet.selections.map(function (selection) {
        var _a;
        if (selection.kind !== "Field")
            return selection;
        var field = subscriptionType.getFields()[selection.name.value];
        if (!field) {
            return selection;
        }
        var fieldHasWebhookSecretArg = field.args.some(function (arg) { return arg.name === "secret"; });
        var selectionHasWebhookSecretArg = (_a = selection.arguments) === null || _a === void 0 ? void 0 : _a.some(function (arg) { return arg.name.value === "secret"; });
        if (fieldHasWebhookSecretArg && !selectionHasWebhookSecretArg) {
            return __assign(__assign({}, selection), { arguments: __spreadArray(__spreadArray([], (selection.arguments || []), true), [
                    {
                        kind: Kind.ARGUMENT,
                        name: {
                            kind: Kind.NAME,
                            value: "secret",
                        },
                        value: {
                            kind: Kind.VARIABLE,
                            name: {
                                kind: Kind.NAME,
                                value: "netlifyGraphWebhookSecret",
                            },
                        },
                    },
                ], false) });
        }
        return selection;
    });
    var hasWebhookVariableDefinition = (_b = definition.variableDefinitions) === null || _b === void 0 ? void 0 : _b.find(function (varDef) { return varDef.variable.name.value === "netlifyGraphWebhookSecret"; });
    var netlifyGraphWebhookUrlVariable = {
        kind: Kind.VARIABLE_DEFINITION,
        type: {
            kind: Kind.NON_NULL_TYPE,
            type: {
                kind: Kind.NAMED_TYPE,
                name: {
                    kind: Kind.NAME,
                    value: "OneGraphSubscriptionSecretInput",
                },
            },
        },
        variable: {
            kind: Kind.VARIABLE,
            name: {
                kind: Kind.NAME,
                value: "netlifyGraphWebhookSecret",
            },
        },
    };
    var variableDefinitions = !!hasWebhookVariableDefinition
        ? definition.variableDefinitions
        : __spreadArray(__spreadArray([], (definition.variableDefinitions || []), true), [
            netlifyGraphWebhookUrlVariable,
        ], false);
    return __assign(__assign({}, definition), { variableDefinitions: variableDefinitions, selectionSet: __assign(__assign({}, definition.selectionSet), { selections: newSelections }) });
}
exports.patchSubscriptionWebhookSecretField = patchSubscriptionWebhookSecretField;
var addLeftWhitespace = function (string, padding) {
    var paddingString = " ".repeat(padding);
    return string
        .split("\n")
        .map(function (line) { return paddingString + line; })
        .join("\n");
};
var formInput = function (GraphQL, schema, def) {
    var getNamedType = GraphQL.getNamedType, isEnumType = GraphQL.isEnumType, isInputObjectType = GraphQL.isInputObjectType, isListType = GraphQL.isListType, isScalarType = GraphQL.isScalarType, typeFromAST = GraphQL.typeFromAST;
    var name = def.variable.name.value;
    function helper(path, type, subfield) {
        var isList = isListType(type);
        var namedType = getNamedType(type);
        var isEnum = isEnumType(namedType);
        var isObject = isInputObjectType(namedType);
        var isScalar = isScalarType(namedType);
        var subfieldName = subfield && subfield.name;
        var subDataEl;
        if (isList) {
            return helper(__spreadArray(__spreadArray([], path, true), [0], false), namedType, undefined);
        }
        else if (isObject) {
            // $FlowFixMe: we check this with `isObject` already
            var subFields_1 = namedType.getFields();
            if (!subFields_1) {
                return "MISSING_SUBFIELDS";
            }
            var subFieldEls = Object.keys(subFields_1)
                .map(function (fieldName) {
                var currentField = subFields_1[fieldName];
                var subPath = __spreadArray(__spreadArray([], path, true), [fieldName], false);
                var currentFieldInput = helper(subPath, currentField.type, currentField);
                return currentFieldInput;
            })
                .join("\n");
            return "<label>" + def.variable.name.value + "</label>\n  <fieldset>\n  " + addLeftWhitespace(subFieldEls, 2) + "\n  </fieldset>";
        }
        else if (isScalar) {
            var coerceFn = void 0;
            var inputAttrs = void 0;
            // $FlowFixMe: we check this with `isScalar` already
            switch (namedType.name) {
                case "String":
                    coerceFn = "(value) => value";
                    inputAttrs = [["type", "text"]];
                    break;
                case "Float":
                    coerceFn =
                        "(value) => try {return parseFloat(value)} catch (e) { return 0.0 }";
                    inputAttrs = [
                        ["type", "number"],
                        ["step", "0.1"],
                    ];
                    break;
                case "Int":
                    coerceFn =
                        "(value) => {try {return parseInt(value, 10)} catch (e) { return 0 }}";
                    inputAttrs = [["type", "number"]];
                    break;
                case "Boolean":
                    coerceFn = '(value) => value === "true"';
                    inputAttrs = [["type", "text"]];
                    break;
                default:
                    coerceFn = "(value) => value";
                    inputAttrs = [["type", "text"]];
                    break;
            }
            var updateFunction = "updateFormVariables(setFormVariables, " + JSON.stringify(path) + ", " + coerceFn + ")";
            subDataEl = "<label htmlFor=\"" + path.join("-") + "\">" + (subfieldName || def.variable.name.value) + "</label><input id=\"" + path.join("-") + "\" " + inputAttrs
                .map(function (_a) {
                var key = _a[0], value = _a[1];
                return key + "=\"" + value + "\"";
            })
                .join(" ") + " onChange={" + updateFunction + "} />";
        }
        else if (isEnum) {
            var updateFunction = "updateFormVariables(setFormVariables, " + JSON.stringify(path) + ", (value) => value)";
            var selectOptions = namedType
                // $FlowFixMe: we check this with `isEnum` already
                .getValues()
                .map(function (gqlEnum) {
                var enumValue = gqlEnum.value;
                var enumDescription = !!gqlEnum.description
                    ? ": " + gqlEnum.description
                    : "";
                return "<option value=\"" + enumValue + "\">" + gqlEnum.name + enumDescription + "</option>";
            })
                .join(" ");
            subDataEl = "<label htmlFor=\"" + path.join("-") + "\">" + def.variable.name.value + "</label><select id=\"" + path.join("-") + "\" onChange={" + updateFunction + "}> " + selectOptions + " </select>";
        }
        else {
            return "UNKNOWN_GRAPHQL_TYPE_FOR_INPUT";
        }
        return subDataEl;
    }
    var hydratedType = typeFromAST(schema, def.type);
    if (!hydratedType) {
        internalConsole_1.internalConsole.warn("\tCould not hydrate type for " + def.type);
        return null;
    }
    // const required = isNonNullType(hydratedType);
    var formEl = helper([name], hydratedType, undefined);
    return "" + formEl;
};
exports.formInput = formInput;
var remixFormInput = function (GraphQL, schema, def, path) {
    if (path === void 0) { path = []; }
    var getNamedType = GraphQL.getNamedType, isEnumType = GraphQL.isEnumType, isInputObjectType = GraphQL.isInputObjectType, isListType = GraphQL.isListType, isScalarType = GraphQL.isScalarType, typeFromAST = GraphQL.typeFromAST;
    var name = def.variable.name.value;
    function helper(path, type, subfield) {
        var isList = isListType(type);
        var namedType = getNamedType(type);
        var isEnum = isEnumType(namedType);
        var isObject = isInputObjectType(namedType);
        var isScalar = isScalarType(namedType);
        var subfieldName = subfield && subfield.name;
        var subDataEl;
        if (isList) {
            return helper(__spreadArray(__spreadArray([], path, true), [0], false), namedType, undefined);
        }
        else if (isObject) {
            // $FlowFixMe: we check this with `isObject` already
            var subFields_2 = namedType.getFields();
            if (!subFields_2) {
                return "MISSING_SUBFIELDS";
            }
            var subFieldEls = Object.keys(subFields_2)
                .map(function (fieldName) {
                var currentField = subFields_2[fieldName];
                var subPath = __spreadArray(__spreadArray([], path, true), [fieldName], false);
                var currentFieldInput = helper(subPath, currentField.type, currentField);
                return currentFieldInput;
            })
                .join("\n");
            return "<label>" + def.variable.name.value + "</label>\n  <fieldset>\n  " + addLeftWhitespace(subFieldEls, 2) + "\n  </fieldset>";
        }
        else if (isScalar) {
            var coerceFn = void 0;
            var inputAttrs = void 0;
            switch (namedType.name) {
                case "String":
                    coerceFn = "(value) => value";
                    inputAttrs = [["type", "text"]];
                    break;
                case "Float":
                    coerceFn =
                        "(value) => try {return parseFloat(value)} catch (e) { return 0.0 }";
                    inputAttrs = [
                        ["type", "number"],
                        ["step", "0.1"],
                    ];
                    break;
                case "Int":
                    coerceFn =
                        "(value) => {try {return parseInt(value, 10)} catch (e) { return 0 }}";
                    inputAttrs = [["type", "number"]];
                    break;
                case "Boolean":
                    coerceFn = '(value) => value === "true"';
                    inputAttrs = [["type", "text"]];
                    break;
                default:
                    coerceFn = "(value) => value";
                    inputAttrs = [["type", "text"]];
                    break;
            }
            subDataEl = "<label htmlFor=\"" + path.join("-") + "\">" + (subfieldName || def.variable.name.value) + "</label><input id=\"" + path.join("-") + "\" name=\"" + path.join("-") + "\" " + inputAttrs
                .map(function (_a) {
                var key = _a[0], value = _a[1];
                return key + "=\"" + value + "\"";
            })
                .join(" ") + " />";
        }
        else if (isEnum) {
            var selectOptions = namedType
                .getValues()
                .map(function (gqlEnum) {
                var enumValue = gqlEnum.value;
                var enumDescription = !!gqlEnum.description
                    ? ": " + gqlEnum.description
                    : "";
                return "<option value=\"" + enumValue + "\">" + gqlEnum.name + enumDescription + "</option>";
            })
                .join(" ");
            subDataEl = "<label htmlFor=\"" + path.join("-") + "\">" + def.variable.name.value + "</label><select id=\"" + path.join("-") + "\" name=\"" + path.join("-") + "\"> " + selectOptions + " </select>";
        }
        else {
            return "UNKNOWN_GRAPHQL_TYPE_FOR_INPUT";
        }
        return subDataEl;
    }
    var hydratedType = typeFromAST(schema, def.type);
    if (!hydratedType) {
        internalConsole_1.internalConsole.warn("\tCould not hydrate type for " + def.type);
        return null;
    }
    // const required = isNonNullType(hydratedType);
    var formEl = helper([name], hydratedType, undefined);
    return "" + formEl;
};
exports.remixFormInput = remixFormInput;
var formElComponent = function (_a) {
    var GraphQL = _a.GraphQL, operationData = _a.operationData, schema = _a.schema, callFn = _a.callFn;
    if (!schema) {
        return {
            formHelpers: "const [formVariables, setFormVariables] = React.useState({});",
            formEl: "<pre>You must pass in a schema to generate forms for your GraphQL operation</pre>",
        };
    }
    var els = (operationData.operationDefinition.variableDefinitions || []).map(function (def) {
        var genInput = (0, exports.formInput)(GraphQL, schema, def);
        var input = genInput || "UNABLE_TO_GENERATE_FORM_INPUT_FOR_GRAPHQL_TYPE(" + def + ")";
        return "" + input;
    });
    return {
        formHelpers: "const [formVariables, setFormVariables] = React.useState({});",
        formEl: "<form onSubmit={event => { event.preventDefault(); " + callFn + " }}>\n  " + addLeftWhitespace(els.join("\n"), 2) + "\n    <input type=\"submit\" />\n  </form>",
    };
};
exports.formElComponent = formElComponent;
var normalizeOperationsDoc = function (GraphQL, operationsDoc) {
    var Kind = GraphQL.Kind, parse = GraphQL.parse, print = GraphQL.print, visit = GraphQL.visit;
    var parsedOperations = parse(operationsDoc);
    var fragments = [];
    var operations = [];
    var sortedDefinitions = __spreadArray([], parsedOperations.definitions, true).sort(function (a, b) {
        var _a, _b;
        var aName = (a.kind === Kind.OPERATION_DEFINITION
            ? (_a = a.name) === null || _a === void 0 ? void 0 : _a.value
            : a.kind === Kind.FRAGMENT_DEFINITION
                ? a.name.value
                : null) || "__unknownDefinition";
        var bName = (b.kind === Kind.OPERATION_DEFINITION
            ? (_b = b.name) === null || _b === void 0 ? void 0 : _b.value
            : b.kind === Kind.FRAGMENT_DEFINITION
                ? b.name.value
                : null) || "__unknownDefinition";
        return aName.localeCompare(bName);
    });
    for (var _i = 0, sortedDefinitions_1 = sortedDefinitions; _i < sortedDefinitions_1.length; _i++) {
        var definition = sortedDefinitions_1[_i];
        var definitionWithNormalizedStrings = visit(definition, {
            StringValue: {
                enter: function (node) {
                    var hasNewlines = node.value.match(/\n/);
                    return __assign(__assign({}, node), { block: hasNewlines ? true : node.block });
                },
            },
        });
        if (definitionWithNormalizedStrings.kind === Kind.OPERATION_DEFINITION) {
            operations.push(definitionWithNormalizedStrings);
        }
        else if (definitionWithNormalizedStrings.kind === Kind.FRAGMENT_DEFINITION) {
            fragments.push(definitionWithNormalizedStrings);
        }
    }
    var fragmentStrings = fragments.map(function (fragment) {
        return print(fragment);
    });
    var operationStrings = operations.map(function (operation) {
        return print(operation);
    });
    var fullDoc = __spreadArray(__spreadArray([], fragmentStrings, true), operationStrings, true).join("\n\n") + "\n";
    return fullDoc;
};
exports.normalizeOperationsDoc = normalizeOperationsDoc;
var gatherHardcodedValues = function (GraphQL, query) {
    var Kind = GraphQL.Kind, parse = GraphQL.parse, visit = GraphQL.visit;
    var parsedQuery;
    try {
        parsedQuery = parse(query);
        // [fieldName, value]
        var hardCodedValues_1 = [];
        var isHardcodedValueNode_1 = function (node) {
            var isHardcodedValue = node.value &&
                (node.value.kind === Kind.STRING ||
                    node.value.kind === Kind.INT ||
                    node.value.kind === Kind.FLOAT);
            return isHardcodedValue;
        };
        var hardCodedValueExtractor = function (node) {
            var isHardcodedValue = isHardcodedValueNode_1(node);
            if (isHardcodedValue) {
                var nodeName = node.name.value;
                var nodeValue = null;
                if (node.value.kind === Kind.STRING) {
                    nodeValue = node.value.value;
                }
                else if (node.value.kind === Kind.INT) {
                    nodeValue = node.value.value;
                }
                else if (node.value.kind === Kind.FLOAT) {
                    nodeValue = node.value.value;
                }
                if (nodeValue) {
                    hardCodedValues_1.push([nodeName, nodeValue]);
                }
            }
            return node;
        };
        visit(parsedQuery, {
            Argument: hardCodedValueExtractor,
            ObjectField: hardCodedValueExtractor,
        });
        return hardCodedValues_1;
    }
    catch (e) {
        internalConsole_1.internalConsole.warn("Error parsing query: " + e);
        return [];
    }
};
exports.gatherHardcodedValues = gatherHardcodedValues;
var extractPersistableOperation = function (GraphQL, doc, operationDefinition) {
    var Kind = GraphQL.Kind, print = GraphQL.print, visit = GraphQL.visit;
    // Visit the operationDefinition and find all fragments referenced, and include them all in a single printed document
    var fragments = new Set();
    var visitedFragmentNames = new Set();
    var fragmentExtractor = function (node) {
        var fragmentName = node.name.value;
        // Find the fragment definition in the document
        var fragmentDefinition = doc.definitions.find(function (def) {
            return def.kind === Kind.FRAGMENT_DEFINITION && def.name.value === fragmentName;
        });
        if (fragmentDefinition) {
            fragments.add(fragmentDefinition);
            visit(fragmentDefinition, {
                FragmentSpread: { enter: fragmentExtractor },
            });
        }
        else {
            internalConsole_1.internalConsole.warn("Could not find fragment definition for referenced fragment: " + fragmentName);
        }
        return node;
    };
    var newOperation = visit(operationDefinition, {
        FragmentSpread: { enter: fragmentExtractor },
        Directive: {
            enter: function (node) {
                if (["netlify", "netlifyCacheControl"].includes(node.name.value)) {
                    return null;
                }
            },
        },
    });
    var fragmentStrings = Array.from(fragments)
        .sort(function (a, b) {
        return a.name.value.localeCompare(b.name.value);
    })
        .map(function (fragment) {
        return print(fragment);
    });
    // Put the operation in the top to help a human looking at the doc identify the purpose quickly
    var fullDoc = __spreadArray([print(newOperation)], fragmentStrings, true).join("\n\n");
    return {
        fragmentDependencies: Array.from(fragments),
        persistableOperationString: fullDoc,
    };
};
exports.extractPersistableOperation = extractPersistableOperation;
//# sourceMappingURL=graphqlHelpers.js.map