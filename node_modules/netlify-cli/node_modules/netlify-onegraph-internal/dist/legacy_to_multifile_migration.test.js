"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var graphql_1 = require("graphql");
var path = require("path/posix");
var GraphQL = require("graphql");
var index_1 = require("./index");
var writeFileSync = fs.writeFileSync, readFileSync = fs.readFileSync;
var cleanDirectory = function (directory) {
    fs.readdirSync(directory).forEach(function (filename) {
        return fs.rmSync(path.resolve(directory, filename));
    });
};
var test = function () { return __awaiter(void 0, void 0, void 0, function () {
    var inputNetlifyGraphConfig, sourceGraphQLFilename, sourceGraphQLDirectory, schemaGraphQLFilename, schemaGraphQLFile, schema, legacySourceGraphQLFile, operationsPath, legacyParsedDoc, _a, legacyFunctions, legacyFragments, operationFiles, dirCont, emptyDocDefinitionNode, parsedDoc, _b, functions, fragments, outputNetlifyGraphConfig;
    return __generator(this, function (_c) {
        inputNetlifyGraphConfig = {
            netlifyGraphPath: ["functions", "netlifyGraph"],
            graphQLConfigJsonFilename: [".graphqlrc.json"],
            framework: "custom",
            webhookBasePath: "/api",
            functionsPath: ["pages", "api"],
            graphQLOperationsSourceDirectory: ["tests", "assets", "operations"],
            graphQLOperationsSourceFilename: [
                "tests",
                "assets",
                "netlifyGraphOperationsLibrary2.graphql",
            ],
            graphQLSchemaFilename: ["tests", "assets", "netlifyGraphSchema.graphql"],
            netlifyGraphImplementationFilename: [
                "functions",
                "netlifyGraph",
                "index.js",
            ],
            netlifyGraphTypeDefinitionsFilename: [
                "functions",
                "netlifyGraph",
                "index.d.ts",
            ],
            netlifyGraphRequirePath: ["functions", "netlifyGraph"],
            extension: "ts",
            moduleType: "esm",
            language: "typescript",
            runtimeTargetEnv: "node",
        };
        sourceGraphQLFilename = inputNetlifyGraphConfig.graphQLOperationsSourceFilename &&
            path.resolve(path.join.apply(path, inputNetlifyGraphConfig.graphQLOperationsSourceFilename));
        sourceGraphQLDirectory = path.resolve.apply(path, inputNetlifyGraphConfig.graphQLOperationsSourceDirectory);
        schemaGraphQLFilename = path.resolve.apply(path, inputNetlifyGraphConfig.graphQLSchemaFilename);
        schemaGraphQLFile = readFileSync(schemaGraphQLFilename, "utf8");
        schema = (0, graphql_1.buildASTSchema)((0, graphql_1.parse)(schemaGraphQLFile));
        legacySourceGraphQLFile = sourceGraphQLFilename &&
            fs.existsSync(sourceGraphQLFilename) &&
            readFileSync(sourceGraphQLFilename, "utf8");
        operationsPath = path.resolve(sourceGraphQLDirectory);
        fs.mkdirSync(operationsPath, { recursive: true });
        if (legacySourceGraphQLFile) {
            legacyParsedDoc = (0, graphql_1.parse)(legacySourceGraphQLFile);
            _a = index_1.NetlifyGraph.extractFunctionsFromOperationDoc(GraphQL, legacyParsedDoc), legacyFunctions = _a.functions, legacyFragments = _a.fragments;
            console.log("Legacy operations file found, migrating...");
            console.log("Migrating functions...");
            Object.values(legacyFunctions).forEach(function (fn) {
                var filename = path.resolve.apply(path, __spreadArray(__spreadArray([], inputNetlifyGraphConfig.graphQLOperationsSourceDirectory, true), [
                    fn.operationName + ".graphql",
                ], false));
                console.log("Migrating " + fn.operationName + " to " + filename + "...");
                fs.writeFileSync(filename, fn.operationString, "utf8");
            });
            console.log("Migrating fragments...");
            Object.values(legacyFragments).forEach(function (fn) {
                var filename = path.resolve.apply(path, __spreadArray(__spreadArray([], inputNetlifyGraphConfig.graphQLOperationsSourceDirectory, true), [
                    fn.fragmentName + ".graphql",
                ], false));
                console.log("Migrating " + fn.fragmentName + " to " + filename + "...");
                fs.writeFileSync(filename, fn.operationString, "utf8");
            });
            console.log("Deleting legacy operations file...");
            // fs.unlinkSync(sourceGraphQLFilename);
            console.log("(skipping for test)");
        }
        operationFiles = [];
        dirCont = fs.readdirSync(operationsPath);
        dirCont.forEach(function (filename) {
            if (filename.match(/.*\.(graphql?)/gi)) {
                var content = fs.readFileSync(path.resolve(operationsPath, filename), "utf8");
                var file = {
                    name: filename,
                    path: path.resolve(operationsPath, filename),
                    content: content,
                    parsedOperation: (0, graphql_1.parse)(content),
                };
                operationFiles.push(file);
            }
        });
        emptyDocDefinitionNode = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: [],
        };
        parsedDoc = operationFiles.reduce(function (acc, file) {
            var parsedOperation = file.parsedOperation;
            var definitions = parsedOperation.definitions;
            return {
                kind: graphql_1.Kind.DOCUMENT,
                definitions: __spreadArray(__spreadArray([], acc.definitions, true), definitions, true),
            };
        }, emptyDocDefinitionNode);
        _b = index_1.NetlifyGraph.extractFunctionsFromOperationDoc(GraphQL, parsedDoc), functions = _b.functions, fragments = _b.fragments;
        cleanDirectory(sourceGraphQLDirectory);
        console.log("Writing functions...");
        Object.values(functions).forEach(function (fn) {
            var filename = path.resolve.apply(path, __spreadArray(__spreadArray([], inputNetlifyGraphConfig.graphQLOperationsSourceDirectory, true), [
                fn.operationName + ".graphql",
            ], false));
            console.log("Writing " + fn.operationName + " to " + filename + "...");
            fs.writeFileSync(filename, fn.operationString, "utf8");
        });
        console.log("Writing fragments...");
        Object.values(fragments).forEach(function (fn) {
            var filename = path.resolve.apply(path, __spreadArray(__spreadArray([], inputNetlifyGraphConfig.graphQLOperationsSourceDirectory, true), [
                fn.fragmentName + ".graphql",
            ], false));
            console.log("Writing " + fn.fragmentName + " to " + filename + "...");
            fs.writeFileSync(filename, fn.operationString, "utf8");
        });
        outputNetlifyGraphConfig = __assign({}, inputNetlifyGraphConfig);
        return [2 /*return*/];
    });
}); };
test();
//# sourceMappingURL=legacy_to_multifile_migration.test.js.map