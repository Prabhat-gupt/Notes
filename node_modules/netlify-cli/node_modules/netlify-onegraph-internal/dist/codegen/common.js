"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRuntime = exports.generateTypeScriptDefinitions = exports.generateSubscriptionFunction = exports.generateSubscriptionFunctionTypeDefinition = exports.generateFragmentTypeScriptDefinition = void 0;
var graphql_1 = require("graphql");
var graphqlHelpers_1 = require("../graphqlHelpers");
var __1 = require("..");
var generateFragmentTypeScriptDefinition = function (_a) {
    var fragment = _a.fragment;
    var jsDoc = replaceAll(fragment.description || "", "*/", "")
        .split("\n")
        .join("\n* ");
    var baseName = fragment.fragmentName;
    var returnSignatureName = capitalizeFirstLetter(baseName);
    return "/**\n    * " + jsDoc + "\n    */\n    export type " + returnSignatureName + " = " + fragment.returnSignature + ";\n    ";
};
exports.generateFragmentTypeScriptDefinition = generateFragmentTypeScriptDefinition;
var subscriptionParserReturnName = function (fn) {
    return fn.operationName + "Event";
};
var subscriptionParserName = function (fn) {
    return "parseAndVerify" + fn.operationName + "Event";
};
var subscriptionFunctionName = function (fn) {
    return "subscribeTo" + fn.operationName;
};
var generateSubscriptionFunctionTypeDefinition = function (GraphQL, schema, fn, fragments) {
    var fragmentDefinitions = Object.entries(fragments).reduce(function (acc, _a) {
        var _b;
        var fragmentName = _a[0], fragment = _a[1];
        return __assign(__assign({}, acc), (_b = {}, _b[fragmentName] = fragment.parsedOperation, _b));
    }, {});
    var parsingFunctionReturnSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperation)(GraphQL, schema, fn.parsedOperation, fragmentDefinitions);
    var variableNames = (fn.parsedOperation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(GraphQL, variableNames, schema, fn.parsedOperation);
    var jsDoc = replaceAll(fn.description || "", "*/", "!")
        .split("\n")
        .join("\n* ");
    return "/**\n  * " + jsDoc + "\n  */\n  export function " + subscriptionFunctionName(fn) + "(\n    /**\n     * This will be available in your webhook handler as a query parameter.\n     * Use this to keep track of which subscription you're receiving\n     * events for.\n     */\n    variables: " + (variableSignature === "{}" ? "Record<string, never>" : variableSignature) + ",\n    options?: {\n      /**\n       * The accessToken to use for the lifetime of the subscription.\n       */\n      accessToken?: string | null | undefined;\n      /**\n       * A string id that will be passed to your webhook handler as a query parameter\n       * along with each event.\n       * This can be used to keep track of which subscription you're receiving\n       */\n      netlifyGraphWebhookId?: string | null | undefined;\n      /**\n       * The absolute URL of your webhook handler to handle events from this subscription.\n       */\n      webhookUrl?: string | null | undefined;\n      /**\n       * The secret to use when signing the webhook request. Use this to verify\n       * that the webhook payload is coming from Netlify Graph. Defaults to the\n       * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.\n       */\n      webhookSecret?: string | null | undefined;\n    }) : void\n  \n  export type " + subscriptionParserReturnName(fn) + " = " + parsingFunctionReturnSignature + "\n  \n  /**\n   * Verify the " + fn.operationName + " event body is signed securely, and then parse the result.\n   */\n  export function " + subscriptionParserName(fn) + " (/** A Netlify Handler Event */ event : WebhookEvent) : null | " + subscriptionParserReturnName(fn) + "\n  ";
};
exports.generateSubscriptionFunctionTypeDefinition = generateSubscriptionFunctionTypeDefinition;
// TODO: Handle fragments
var generateSubscriptionFunction = function (GraphQL, schema, fn, fragments, netlifyGraphConfig) {
    var _a;
    var patchedWithWebhookUrl = (0, graphqlHelpers_1.patchSubscriptionWebhookField)({
        GraphQL: GraphQL,
        schema: schema,
        definition: fn.parsedOperation,
    });
    var patched = (0, graphqlHelpers_1.patchSubscriptionWebhookSecretField)({
        GraphQL: GraphQL,
        schema: schema,
        definition: patchedWithWebhookUrl,
    });
    // TODO: Don't allow unnamed operations as subscription
    var filename = (patched.name && patched.name.value) || "Unknown";
    var body = (0, graphql_1.print)(patched);
    var safeBody = replaceAll(body, "${", "\\${");
    return "const " + subscriptionFunctionName(fn) + " = (\n    variables,\n    rawOptions\n    ) => {\n      const options = rawOptions || {};\n      const netlifyGraphWebhookId = options.netlifyGraphWebhookId;\n      const netlifyGraphWebhookUrl = options.webhookUrl || `${process.env.DEPLOY_URL}" + netlifyGraphConfig.webhookBasePath + "/" + filename + "?netlifyGraphWebhookId=${netlifyGraphWebhookId}`;\n      const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET\n      const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}\n  \n      const subscriptionOperationDoc = `" + safeBody + "`;\n  \n      fetchNetlifyGraph({\n        query: subscriptionOperationDoc,\n        operationName: \"" + fn.operationName + "\",\n        variables: fullVariables,\n        options: options,\n        fetchStrategy: \"" + (fn.executionStrategy === "PERSISTED" &&
        (((_a = fn.cacheStrategy) === null || _a === void 0 ? void 0 : _a.timeToLiveSeconds) || 0) > 0
        ? "GET"
        : "POST") + "\",\n    })\n  }\n  \n  const " + subscriptionParserName(fn) + " = (event, options) => {\n    if (!verifyRequestSignature({ event: event }, options)) {\n      console.warn(\"Unable to verify signature for " + filename + "\")\n      return null\n    }\n  \n    return JSON.parse(event.body || '{}')\n  }";
};
exports.generateSubscriptionFunction = generateSubscriptionFunction;
var generateTypeScriptDefinitions = function (_a) {
    var GraphQL = _a.GraphQL, netlifyGraphConfig = _a.netlifyGraphConfig, schema = _a.schema, functionDefinitions = _a.functionDefinitions, fragments = _a.fragments;
    var fragmentDecls = Object.values(fragments)
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fragment) {
        return (0, exports.generateFragmentTypeScriptDefinition)({
            fragment: fragment,
        });
    });
    var functionDecls = functionDefinitions
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            return (0, exports.generateSubscriptionFunctionTypeDefinition)(GraphQL, schema, fn, fragments);
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        var baseName = fn.operationName;
        var returnSignatureName = capitalizeFirstLetter(baseName);
        var inputSignatureName = capitalizeFirstLetter(baseName) + "Input";
        var shouldExportInputSignature = fn.variableSignature !== "{}";
        var emptyVariablesGuideDocString = fn.variableSignature === "{}"
            ? "/**\n      * Pass `{}` as no variables are defined for this function.\n      */\n      "
            : "";
        var inputSignatureExport = shouldExportInputSignature
            ? "export type " + inputSignatureName + " = " + fn.variableSignature + ";\n    "
            : "";
        return inputSignatureExport + "\n    export type " + returnSignatureName + " = " + fn.returnSignature + ";\n    \n    /**\n     * " + jsDoc + "\n     */\n    export function " + fn.fnName + "(\n      " + emptyVariablesGuideDocString + "variables: " + (shouldExportInputSignature
            ? inputSignatureName
            : "Record<string, never>") + ",\n      options?: NetlifyGraphFunctionOptions\n    ): Promise<" + returnSignatureName + ">;";
    });
    var exportedFunctionsObjectProperties = functionDefinitions
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            if (netlifyGraphConfig.runtimeTargetEnv === "node") {
                var subscriptionFnName = subscriptionFunctionName(fn);
                var parserFnName = subscriptionParserName(fn);
                var jsDoc_1 = replaceAll(fn.description || "", "*/", "")
                    .split("\n")
                    .join("\n* ");
                return "/**\n    * " + jsDoc_1 + "\n    */\n    " + subscriptionFnName + ":" + subscriptionFnName + ",\n    /**\n     * Verify the event body is signed securely, and then parse the result.\n     */\n    " + parserFnName + ": typeof " + parserFnName;
            }
            else {
                return "/** unexpected branch */";
            }
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        return "/**\n    * " + jsDoc + "\n    */\n    " + fn.fnName + ": typeof " + fn.fnName;
    })
        .filter(Boolean)
        .join(",\n  ");
    var source = "/* eslint-disable */\n    // @ts-nocheck\n    // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!\n    \n    export type NetlifyGraphFunctionOptions = {\n      /**\n       * The accessToken to use for the request\n       */\n      accessToken?: string;\n      /**\n       * The siteId to use for the request\n       * @default process.env.SITE_ID\n       */\n      siteId?: string;\n    }\n    \n    export type WebhookEvent = {\n      body: string;\n      headers: Record<string, string | null | undefined>;\n    };\n    \n    export type GraphQLError = {\n      \"path\": Array<string | number>;\n      \"message\": string;\n      \"extensions\": Record<string, unknown>;\n    };\n    \n    " + fragmentDecls.join("\n\n") + "\n    \n    " + functionDecls.join("\n\n") + "\n    \n    export interface Functions {\n      " + (exportedFunctionsObjectProperties === ""
        ? "Record<string, never>"
        : exportedFunctionsObjectProperties) + "\n    }\n    \n    export const functions: Functions;\n    \n    export default functions;\n    ";
    var defaultRuntimePath = [
        "./",
        "netlify",
        "functions",
        "netlifyGraph",
        "index.js",
    ];
    var filename = netlifyGraphConfig.netlifyGraphImplementationFilename ||
        defaultRuntimePath;
    var typeDefinitionsFilename = __spreadArray(__spreadArray([], filename.slice(0, -1), true), [
        "" + (filename.slice(-1)[0].split(".").slice(0, -1).join(".") + ".d.ts"),
    ], false);
    return [
        {
            kind: "NamedExportedFile",
            name: typeDefinitionsFilename,
            content: source,
            language: "typescript",
        },
    ];
};
exports.generateTypeScriptDefinitions = generateTypeScriptDefinitions;
var capitalizeFirstLetter = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
var replaceAll = function (target, search, replace) {
    var simpleString = search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return target.replace(new RegExp(simpleString, "g"), replace);
};
var lruCacheImplementation = "// Basic LRU cache implementation\n  const makeLRUCache = (max) => {\n    return { max: max, cache: new Map() };\n  };\n  \n  const oldestCacheKey = (lru) => {\n    return lru.keys().next().value\n  }\n  \n  // Depend on Map keeping track of insertion order\n  const getFromCache = (lru, key) => {\n    const item = lru.cache.get(key);\n    if (item) {\n      // Delete key and re-insert so key is now at the end,\n      // and now the last to be gc'd.\n      lru.cache.delete(key);\n      lru.cache.set(key, item);\n    }\n    return item;\n  };\n  \n  const setInCache = (lru, key, value) => {\n    if (lru.cache.has(key)) {\n      lru.cache.delete(key);\n    }\n    if (lru.cache.size == lru.max) {\n      const cacheKey = oldestCacheKey(lru);\n  \n      if (cacheKey) {\n        lru.cache.delete(cacheKey);\n      }\n    }\n  \n    lru.cache.set(key, value);\n  };\n  \n  // Cache the results of the Netlify Graph API for conditional requests\n  const cache = makeLRUCache(100);\n  \n  const calculateCacheKey = (payload) => {\n    return JSON.stringify(payload);\n  };";
var generateRuntime = function (opts) {
    var netlifyGraphConfig = opts.netlifyGraphConfig, schema = opts.schema, schemaId = opts.schemaId;
    var export_ = function (netlifyGraphConfig, envs, name, value) {
        if (!envs.includes(netlifyGraphConfig.runtimeTargetEnv)) {
            return "";
        }
        if (netlifyGraphConfig.moduleType === "commonjs") {
            return "exports." + name + " = " + value;
        }
        return "export const " + name + " = " + value;
    };
    var import_ = function (netlifyGraphConfig, envs, name, packageName) {
        if (!envs.includes(netlifyGraphConfig.runtimeTargetEnv)) {
            return "";
        }
        if (netlifyGraphConfig.moduleType === "commonjs") {
            return "const " + name + " = require(\"" + packageName + "\")";
        }
        return "import " + name + " from \"" + packageName + "\"";
    };
    var defaultRuntimePath = [
        "./",
        "netlify",
        "functions",
        "netlifyGraph",
        "index.js",
    ];
    var filename = opts.netlifyGraphConfig.netlifyGraphImplementationFilename ||
        defaultRuntimePath;
    var exportedFunctionsObjectProperties = opts.functionDefinitions
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            if (netlifyGraphConfig.runtimeTargetEnv === "node") {
                var subscriptionFnName = subscriptionFunctionName(fn);
                var parserFnName = subscriptionParserName(fn);
                var jsDoc_2 = replaceAll(fn.description || "", "*/", "")
                    .split("\n")
                    .join("\n* ");
                return "/**\n  * " + jsDoc_2 + "\n  */\n  " + subscriptionFnName + ":" + subscriptionFnName + ",\n  /**\n   * Verify the event body is signed securely, and then parse the result.\n   */\n  " + parserFnName + ": " + parserFnName;
            }
            else {
                return "/** unexpected branch 2 */";
            }
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        return "/**\n  * " + jsDoc + "\n  */\n  " + fn.fnName + ": " + (netlifyGraphConfig.moduleType === "commonjs" ? "exports." : "") + fn.fnName;
    })
        .filter(Boolean)
        .join(",\n  ");
    var fnNames = opts.operationDataList.map(function (op) { return op.displayName; });
    var functionDecls = opts.functionDefinitions
        .sort(function (a, b) {
        return a.id.localeCompare(b.id);
    })
        .map(function (fn) {
        var _a, _b;
        if (fn.kind === "subscription") {
            var fragments = [];
            return (0, exports.generateSubscriptionFunction)(__1.GraphQL, schema, fn, fragments, netlifyGraphConfig);
        }
        var dynamicFunction = export_(netlifyGraphConfig, ["browser", "node"], fn.fnName, "(\n      variables,\n      options\n      ) => {\n      return fetchNetlifyGraph({\n        query: `" + fn.persistableOperationString + "`,\n        operationName: \"" + fn.operationName + "\",\n        variables: variables,\n        options: options,\n        fetchStrategy: \"" + (fn.executionStrategy === "PERSISTED" &&
            (((_a = fn.cacheStrategy) === null || _a === void 0 ? void 0 : _a.timeToLiveSeconds) || 0) > 0
            ? "GET"
            : "POST") + "\",\n      })\n    }") + "\n  ";
        var staticFunction = "" + export_(netlifyGraphConfig, ["browser", "node"], fn.fnName, "(\n      variables,\n      options\n    ) => {\n      return fetchNetlifyGraph({\n        query: `" + fn.persistableOperationString + "`,\n        operationName: \"" + fn.operationName + "\",\n        variables: variables,\n        options: options,\n        fetchStrategy: \"" + (fn.executionStrategy === "PERSISTED" &&
            (((_b = fn.cacheStrategy) === null || _b === void 0 ? void 0 : _b.timeToLiveSeconds) || 0) > 0
            ? "GET"
            : "POST") + "\",\n      });\n    }\n  ");
        return fn.id ? staticFunction : dynamicFunction;
    });
    var runtime = "/* eslint-disable */\n  // @ts-nocheck\n  // GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!\n  \n  " + lruCacheImplementation + "\n\n  const schemaId = '" + schemaId + "';\n\n  const netlifyGraphHostWithProtocol =\n    process.env.NETLIFY_GRAPH_HOST_WITH_PROTOCOL || 'https://graph.netlify.com';\n\n  const makeNetlifyGraphUrl = ({ operationName, siteId }) => {\n    return (\n      netlifyGraphHostWithProtocol +\n      '/graphql?app_id=' +\n      siteId +\n      '&operationName=' +\n      operationName +\n      '&schema_id=' +\n      schemaId\n    );\n  };\n\n  const httpFetch = (operationName, options) => {\n    const reqBody = options.body || null;\n    const userHeaders = options.headers || {};\n    const headers = {\n      ...userHeaders,\n      'Content-Type': 'application/json',\n    };\n\n    const timeoutMs = 30_000;\n\n    const reqOptions = {\n      method: 'POST',\n      headers: headers,\n      timeout: timeoutMs,\n      body: reqBody,\n    };\n\n    const siteId = options.siteId || process.env.SITE_ID;\n    const netlifyGraphUrl = makeNetlifyGraphUrl({ operationName: operationName, siteId: siteId });\n\n    return fetch(netlifyGraphUrl, reqOptions).then((body) => {\n      return body.text().then((bodyString) => {\n        const headers = {};\n        body.headers.forEach((k, v) => (headers[k] = v));\n  \n        return {\n          body: bodyString,\n          headers: headers,\n          status: body.status,\n        };\n      });\n    });\n  };\n \n  const fetchNetlifyGraph = function fetchNetlifyGraph(input) {\n    const query = input.query;\n    const docId = input.doc_id;\n    const operationName = input.operationName;\n    const variables = input.variables;\n  \n    const options = input.options || {};\n    const accessToken = options.accessToken;\n  \n    const payload = {\n      query: query,\n      doc_id: docId,\n      variables: variables,\n      operationName: operationName,\n    };\n  \n    let cachedOrLiveValue = new Promise((resolve) => {\n      const cacheKey = calculateCacheKey(payload);\n  \n      // Check the cache for a previous result\n      const cachedResultPair = getFromCache(cache, cacheKey);\n  \n      let conditionalHeaders = {\n        'If-None-Match': '',\n      };\n      let cachedResultValue;\n  \n      if (cachedResultPair) {\n        const [etag, previousResult] = cachedResultPair;\n        conditionalHeaders = {\n          'If-None-Match': etag,\n        };\n        cachedResultValue = previousResult;\n      }\n  \n      const response = httpFetch(operationName, {\n        ...options,\n        method: 'POST',\n        headers: {\n          ...conditionalHeaders,\n          Authorization: accessToken ? 'Bearer ' + accessToken : '',\n        },\n        body: JSON.stringify(payload),\n      });\n  \n      response.then((result) => {\n        // Check response headers for a 304 Not Modified\n        if (result.status === 304) {\n          // Return the cached result\n          resolve(cachedResultValue);\n        } else if (result.status === 200) {\n          // Update the cache with the new etag and result\n          const etag = result.headers['etag'];\n          const resultJson = JSON.parse(result.body);\n          if (etag) {\n            // Make a note of the new etag for the given payload\n            setInCache(cache, cacheKey, [etag, resultJson]);\n          }\n          resolve(resultJson);\n        } else {\n          return result.json().then((json) => {\n            resolve(json);\n          });\n        }\n      });\n    });\n  \n    return cachedOrLiveValue;\n  };\n\n  " + functionDecls.join("\n\n") + "\n  \n  /**\n   * The generated NetlifyGraph library with your operations\n   */\n  const functions = {\n    " + exportedFunctionsObjectProperties + "\n  }\n  \n  " + (netlifyGraphConfig.moduleType === "commonjs"
        ? "exports.default = functions"
        : "export default functions");
    var typeDefinitions = (0, exports.generateTypeScriptDefinitions)(opts);
    return __spreadArray([
        {
            kind: "NamedExportedFile",
            name: filename,
            content: runtime,
            language: "javascript",
        }
    ], typeDefinitions, true);
};
exports.generateRuntime = generateRuntime;
//# sourceMappingURL=common.js.map