"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.codegenModule = exports.generators = exports.version = exports.id = exports.remixFunctionSnippet = exports.computeOperationDataList = exports.formElComponent = void 0;
var codegenHelpers_1 = require("./codegenHelpers");
var internalConsole_1 = require("../internalConsole");
var graphqlHelpers_1 = require("../graphqlHelpers");
var __1 = require("..");
var common_1 = require("./common");
var operationNodesMemo = [null, null];
var formUpdateHandler = "const updateFormVariables = (setFormVariables, path, coerce) => {\n  const setIn = (object, path, value) => {\n    if (path.length === 1) {\n      if (value === null) {\n        delete object[path[0]];\n      } else {\n        object[path[0]] = value;\n      }\n    } else {\n      if ([undefined, null].indexOf(object[path[0]]) > -1) {\n        object[path[0]] = typeof path[1] === \"number\" ?  [] : {};\n      }\n      setIn(object[path[0]], path.slice(1), value);\n    }\n    return object;\n  };\n\n  const formInputHandler = (event) => {\n    // We parse the form input, coerce it to the correct type, and then update the form variables\n    const rawValue = event.target.value;\n    // We take a blank input to mean `null`\n    const value = rawValue === \"\" ? null : rawValue;\n    setFormVariables((oldFormVariables) => {\n      const newValue = setIn(oldFormVariables, path, coerce(value));\n      return { ...newValue };\n    });\n  };\n\n  return formInputHandler;\n};";
var formElComponent = function (_a) {
    var GraphQL = _a.GraphQL, operationData = _a.operationData, schema = _a.schema, callFn = _a.callFn;
    if (!schema) {
        return {
            formHelpers: "const [formVariables, setFormVariables] = React.useState({});",
            formEl: "<pre>You must pass in a schema to generate forms for your GraphQL operation</pre>",
        };
    }
    var els = (operationData.operationDefinition.variableDefinitions || []).map(function (def) {
        var genInput = (0, graphqlHelpers_1.remixFormInput)(GraphQL, schema, def, []);
        var input = genInput || "UNABLE_TO_GENERATE_FORM_INPUT_FOR_GRAPHQL_TYPE(" + def + ")";
        return "<p>" + input + "</p>";
    });
    return {
        formHelpers: "const [formVariables, setFormVariables] = React.useState({});",
        formEl: addLeftWhitespace(els.join("\n"), 2) + "\n  <p>\n    <button type=\"submit\">\n      {transition.submission\n        ? \"Submitting...\"\n        : \"Run " + operationData.displayName + "\"}\n    </button>\n  </p>\n",
    };
};
exports.formElComponent = formElComponent;
var generateRoute = function (opts) {
    var form = (0, exports.formElComponent)({
        GraphQL: opts.GraphQL,
        operationData: opts.operationData,
        schema: opts.schema,
        callFn: "submitForm()",
    });
    var netlifyGraphConfig = opts.netlifyGraphConfig;
    var fetcherInvocation = asyncFetcherInvocation(__1.GraphQL, opts.netlifyGraphConfig, [opts.operationData], "get");
    return {
        kind: "NamedExportedFile",
        language: opts.netlifyGraphConfig.language,
        name: [
            "app",
            "routes",
            opts.operationData.displayName + "." + (opts.netlifyGraphConfig.language === "typescript" ? "tsx" : "js"),
        ],
        content: "import { " + ts(netlifyGraphConfig, "ActionFunction, ") + "json, Form, useActionData, useTransition } from \"remix\";\nimport NetlifyGraph from \"" + netlifyGraphConfig.netlifyGraphRequirePath + "\";" + ts(netlifyGraphConfig, "\nimport invariant from \"tiny-invariant\";") + "\n\n" + exp(netlifyGraphConfig, "action") + ts(netlifyGraphConfig, ": ActionFunction") + " = async ({ context, request }) => {\n  const formData = await request.formData();\n\n  // By default, all API calls use no authentication\n  let accessToken;\n\n  //// If you want to use the API with your own access token:\n  // accessToken = context.netlifyGraphToken;\n\n  " + fetcherInvocation + "\n\n  return json({ data, errors });\n};\n\nexport default function handler() {\n  const results = useActionData();\n  const transition = useTransition();\n\n  const errors = results?.errors;\n  const data" + ts(netlifyGraphConfig, ": NetlifyGraph." + capitalizeFirstLetter(opts.operationData.name) + "[\"data\"]") + " = results?.data;\n\n\n  return (\n    <Form method=\"post\">\n     " + form.formEl + "\n     {errors ? (<pre className=\"error\">{JSON.stringify(errors, null, 2)}</pre>) : null}\n     {data ? (<pre>{JSON.stringify(data, null, 2)}</pre>) : null}\n    </Form>\n  );\n}\n",
    };
};
var getOperationNodes = function (GraphQL, query) {
    var parse = GraphQL.parse;
    if (operationNodesMemo[0] === query && operationNodesMemo[1]) {
        return operationNodesMemo[1];
    }
    var operationDefinitions = [];
    try {
        parse(query).definitions.forEach(function (def) {
            if (def.kind === "FragmentDefinition" ||
                def.kind === "OperationDefinition") {
                operationDefinitions.push(def);
            }
        });
    }
    catch (parseError) {
        // ignore
    }
    operationNodesMemo = [query, operationDefinitions];
    return operationDefinitions;
};
var getOperationName = function (operationDefinition) {
    return operationDefinition.name
        ? operationDefinition.name.value
        : operationDefinition.operation;
};
var getOperationDisplayName = function (operationDefinition) {
    return operationDefinition.name
        ? operationDefinition.name.value
        : "<Unnamed:" + operationDefinition.operation + ">";
};
var formatVariableName = function (name) {
    var uppercasePattern = /[A-Z]/g;
    return (name.charAt(0).toUpperCase() +
        name.slice(1).replace(uppercasePattern, "_$&").toUpperCase());
};
var getUsedVariables = function (variables, operationDefinition) {
    return (operationDefinition.variableDefinitions || []).reduce(function (usedVariables, variable) {
        var variableName = variable.variable.name.value;
        if (variables[variableName]) {
            usedVariables[variableName] = variables[variableName];
        }
        return usedVariables;
    }, {});
};
var findFragmentDependencies = function (operationDefinitions, definition) {
    var fragmentByName = function (name) {
        return operationDefinitions.find(function (def) { return def.name.value === name; });
    };
    var findReferencedFragments = function (selectionSet) {
        var selections = selectionSet.selections;
        var namedFragments = selections
            .map(function (selection) {
            if (selection.kind === "FragmentSpread") {
                return fragmentByName(selection.name.value);
            }
            return null;
        })
            .filter(Boolean);
        var nestedNamedFragments = selections.reduce(function (acc, selection) {
            if ((selection.kind === "Field" ||
                selection.kind === "SelectionNode" ||
                selection.kind === "InlineFragment") &&
                selection.selectionSet !== undefined) {
                return __spreadArray(__spreadArray([], acc, true), findReferencedFragments(selection.selectionSet), true);
            }
            return acc;
        }, []);
        return __spreadArray(__spreadArray([], namedFragments, true), nestedNamedFragments, true);
    };
    var selectionSet = definition.selectionSet;
    return findReferencedFragments(selectionSet);
};
var operationDataByName = function (graph, name) {
    return graph.find(function (operationData) { return operationData.name === name; });
};
var topologicalSortHelper = function (_a, result) {
    var graph = _a.graph, node = _a.node, temp = _a.temp, visited = _a.visited;
    temp[node.name] = true;
    var neighbors = node.fragmentDependencies;
    neighbors.forEach(function (fragmentDependency) {
        var fragmentOperationData = operationDataByName(graph, fragmentDependency.name.value);
        if (!fragmentOperationData) {
            return;
        }
        if (temp[fragmentOperationData.name]) {
            internalConsole_1.internalConsole.error("The operation graph has a cycle");
            return;
        }
        if (!visited[fragmentOperationData.name]) {
            topologicalSortHelper({
                node: fragmentOperationData,
                visited: visited,
                temp: temp,
                graph: graph,
            }, result);
        }
    });
    temp[node.name] = false;
    visited[node.name] = true;
    result.push(node);
};
var toposort = function (graph) {
    var result = [];
    var visited = {};
    var temp = {};
    graph.forEach(function (node) {
        if (!visited[node.name] && !temp[node.name]) {
            topologicalSortHelper({ node: node, visited: visited, temp: temp, graph: graph }, result);
        }
    });
    return result;
};
var computeOperationDataList = function (_a) {
    var GraphQL = _a.GraphQL, parsedDoc = _a.parsedDoc, query = _a.query, variables = _a.variables, fragmentDefinitions = _a.fragmentDefinitions;
    var Kind = GraphQL.Kind, print = GraphQL.print;
    var operationDefinitions = getOperationNodes(GraphQL, query);
    operationDefinitions.forEach(function (operationDefinition) {
        if (operationDefinition.kind === Kind.FRAGMENT_DEFINITION) {
            fragmentDefinitions.push(operationDefinition);
        }
    });
    var rawOperationDataList = operationDefinitions.map(function (operationDefinition) {
        var _a, _b;
        var persistableOperationString = operationDefinition.kind === Kind.OPERATION_DEFINITION
            ? (_b = (_a = (0, graphqlHelpers_1.extractPersistableOperation)(GraphQL, parsedDoc, operationDefinition)) === null || _a === void 0 ? void 0 : _a.persistableOperationString) !== null && _b !== void 0 ? _b : null
            : null;
        return {
            query: print(operationDefinition),
            name: getOperationName(operationDefinition),
            displayName: getOperationDisplayName(operationDefinition),
            type: operationDefinition.kind === Kind.OPERATION_DEFINITION
                ? operationDefinition.operation
                : Kind.FRAGMENT_DEFINITION,
            variableName: formatVariableName(getOperationName(operationDefinition)),
            variables: getUsedVariables(variables, operationDefinition),
            operationDefinition: operationDefinition,
            fragmentDependencies: findFragmentDependencies(fragmentDefinitions, operationDefinition),
            persistableOperationString: persistableOperationString,
        };
    });
    var operationDataList = toposort(rawOperationDataList);
    return {
        operationDefinitions: operationDefinitions,
        fragmentDefinitions: fragmentDefinitions,
        rawOperationDataList: rawOperationDataList,
        operationDataList: operationDataList,
    };
};
exports.computeOperationDataList = computeOperationDataList;
var capitalizeFirstLetter = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
var unnamedSymbols = new Set(["query", "mutation", "subscription"]);
var isOperationNamed = function (operationData) {
    return !unnamedSymbols.has(operationData.name.trim());
};
var addLeftWhitespace = function (string, padding) {
    var paddingString = " ".repeat(padding);
    return string
        .split("\n")
        .map(function (line) { return paddingString + line; })
        .join("\n");
};
var collapseExtraNewlines = function (string) { return string.replace(/\n{2,}/g, "\n\n"); };
var snippetOptions = {
    inputTypename: "Options",
    schemaSdl: "\n  enum HttpMethod {\n    POST\n    GET\n  }\n\ninput Options {\n    \"\"\"\n    Make call over POST\n    \"\"\"\n    postHttpMethod: HttpMethod\n    \"\"\"\n    Use user's OAuth token\n    \"\"\"\n    useClientAuth: Boolean!\n}\n    ",
};
var operationFunctionName = function (operationData) {
    var type = operationData.type;
    var prefix = "unknown";
    switch (type) {
        case "query":
            prefix = "fetch";
            break;
        case "mutation":
            prefix = "execute";
            break;
        case "subscription":
            prefix = "subscribeTo";
            break;
        default:
            break;
    }
    var fnName = prefix +
        (prefix.length === 0
            ? operationData.name
            : capitalizeFirstLetter(operationData.name));
    return fnName;
};
var coercerFor = function (GraphQL, type, name) {
    var print = GraphQL.print;
    var typeName = print(type).replace(/\W+/gi, "").toLocaleLowerCase();
    switch (typeName) {
        case "string":
            return "" + name;
        case "int":
            return "parseInt(" + name + ")";
        case "float":
            return "parseFloat(" + name + ")";
        case "boolean":
            return name + " === 'true'";
        default:
            return "" + name;
    }
};
var asyncFetcherInvocation = function (GraphQL, netlifyGraphConfig, operationDataList, pluckerStyle) {
    var print = GraphQL.print;
    var invocations = operationDataList
        .filter(function (operationData) {
        return ["query", "mutation", "subscription"].includes(operationData.type);
    })
        .map(function (namedOperationData) {
        var _a, _b, _c, _d, _e;
        var params = (namedOperationData.operationDefinition.variableDefinitions || []).map(function (def) { return def.variable.name.value; });
        var invocationParams = params.map(function (param) { return param + ": " + (0, codegenHelpers_1.munge)(param); });
        var pluckers = {
            get: ((_b = (_a = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _a === void 0 ? void 0 : _a.variableDefinitions) === null || _b === void 0 ? void 0 : _b.map(function (def) {
                var name = def.variable.name.value;
                var withCoercer = coercerFor(GraphQL, def.type, (0, codegenHelpers_1.munge)(name) + "FormValue");
                return "const " + (0, codegenHelpers_1.munge)(name) + "FormValue = formData.get(\"" + name + "\");" + ts(netlifyGraphConfig, "\ninvariant(typeof " + (0, codegenHelpers_1.munge)(name) + "FormValue === \"string\");") + "\nconst " + (0, codegenHelpers_1.munge)(name) + " = " + withCoercer + ";\n";
            }).join("\n  ")) || "",
            post: ((_d = (_c = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _c === void 0 ? void 0 : _c.variableDefinitions) === null || _d === void 0 ? void 0 : _d.map(function (def) {
                var name = def.variable.name.value;
                return "const " + (0, codegenHelpers_1.munge)(name) + " = eventBodyJson?." + name + ";";
            }).join("\n  ")) || "",
        };
        var variableValidation = "";
        var requiredVariableCount = 0;
        if ((((_e = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _e === void 0 ? void 0 : _e.variableDefinitions) || [])
            .length !== 0 ||
            0) {
            var requiredVariableNames = namedOperationData.operationDefinition.variableDefinitions
                .map(function (def) {
                return print(def.type).endsWith("!") ? def.variable.name.value : null;
            })
                .filter(Boolean);
            requiredVariableCount = requiredVariableNames.length;
            // TODO: Filter nullable variables
            var condition = requiredVariableNames
                .map(function (name) { return (0, codegenHelpers_1.munge)(name) + " === undefined || " + (0, codegenHelpers_1.munge)(name) + " === null"; })
                .join(" || ");
            var message = requiredVariableNames
                .map(function (name) { return "`" + name + "`"; })
                .join(", ");
            variableValidation = "  if (" + condition + ") {\n    return json(\n      {\n        errors: [\"You must supply parameters for: " + message + "\"],\n      },\n      { status: 422 }\n    );\n  }";
        }
        return (pluckerStyle === "get" ? pluckers.get : pluckers.post) + "\n\n" + (requiredVariableCount > 0 ? variableValidation : "") + "\n\n  const { errors, data } = await NetlifyGraph." + operationFunctionName(namedOperationData) + "({ " + invocationParams.join(", ") + " }, {accessToken: accessToken});\n\n  if (errors) {\n    console.error(JSON.stringify(errors, null, 2));\n  }\n\n  console.log(JSON.stringify(data, null, 2));";
    })
        .join("\n\n");
    return invocations;
};
var clientSideInvocations = function (operationDataList, pluckerStyle, useClientAuth) {
    var invocations = operationDataList
        .filter(function (operationData) {
        return ["query", "mutation", "subscription"].includes(operationData.type);
    })
        .map(function (namedOperationData) {
        var _a, _b;
        var whitespace = 8;
        var params = (namedOperationData.operationDefinition.variableDefinitions || []).map(function (def) { return def.variable.name.value; });
        var bodyPayload = "";
        if (((_b = (_a = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _a === void 0 ? void 0 : _a.variableDefinitions) === null || _b === void 0 ? void 0 : _b.length) ||
            0 > 0) {
            var variableNames = namedOperationData.operationDefinition.variableDefinitions.map(function (def) { return def.variable.name.value; });
            var variables = variableNames
                .map(function (name) { return "\"" + name + "\": " + name; })
                .join(",\n");
            bodyPayload = "\n" + variables + "\n";
        }
        var clientAuth = useClientAuth
            ? ",\n    ...netlifyGraphAuth?.authHeaders()"
            : "";
        var headers = "headers: {\n      \"Content-Type\": \"application/json\"" + clientAuth + "\n    },";
        return "async function " + operationFunctionName(namedOperationData) + "(" + (useClientAuth ? "netlifyGraphAuth, " : "") + "params) {\n  const {" + params.join(", ") + "} = params || {};\n  const resp = await fetch(`/" + namedOperationData.name + (pluckerStyle === "get"
            ? "?" + params.map(function (param) { return param + "=${" + param + "}"; }).join("&")
            : "") + "`, {\n    method: \"" + pluckerStyle.toLocaleUpperCase() + "\"" + (pluckerStyle === "get"
            ? ""
            : ",\n    " + headers + "\n    body: JSON.stringify({" + addLeftWhitespace(bodyPayload, whitespace).trim() + "})") + "\n  });\n\n  const text = await resp.text();\n\n  return JSON.parse(text);\n}";
    })
        .join("\n\n");
    return invocations;
};
var ts = function (netlifyGraphConfig, string) {
    return netlifyGraphConfig.language === "typescript" ? string : "";
};
var subscriptionHandler = function (_a) {
    var netlifyGraphConfig = _a.netlifyGraphConfig, operationData = _a.operationData;
    return {
        kind: "NamedExportedFile",
        language: netlifyGraphConfig.language,
        name: [
            "app",
            "routes",
            "webhooks",
            operationData.displayName + "." + (netlifyGraphConfig.language === "typescript" ? "tsx" : "js"),
        ],
        content: "import { " + ts(netlifyGraphConfig, "ActionFunction, ") + "json } from \"remix\";\nimport NetlifyGraph from \"../" + netlifyGraphConfig.netlifyGraphRequirePath + "\";\n\n" + exp(netlifyGraphConfig, "action") + ts(netlifyGraphConfig, ": ActionFunction") + " = async ({ context, request }) => {\n  const reqBody = await request.text();\n\n  const payload = NetlifyGraph.parseAndVerify" + operationData.name + "Event({\n    body: reqBody,\n    headers: {\n      'x-netlify-graph-signature': context.netlifyGraphSignature\n    },\n  });\n\n  if (!payload) {\n    return json({\n      success: false,\n      error: 'Unable to verify payload signature',\n    }, { status: 422 });\n  }\n\n  const { errors, data } = payload;\n\n  if (errors) {\n    console.error(errors);\n  }\n\n  console.log(data);\n\n  /**\n   * If you want to unsubscribe from this webhook\n   * in order to stop receiving new events,\n   * simply return status 410, e.g.:\n   *\n   * return json({}, { status: 410 });\n   */\n\n  return json({\n    successfullyProcessedIncomingWebhook: true,\n  });\n};\n",
    };
};
var imp = function (netlifyGraphConfig, name, packageName) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "const " + name + " = require(\"" + packageName.join("/") + "\")";
    }
    return "import " + name + " from \"" + packageName.join("/") + "\"";
};
var exp = function (netlifyGraphConfig, name) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "exports." + name;
    }
    return "export const " + name;
};
var expDefault = function (netlifyGraphConfig, name) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "exports.default = " + name;
    }
    return "export default " + name;
};
// Snippet generation!
exports.remixFunctionSnippet = {
    name: "Remix Function",
    generateHandlerOptions: snippetOptions,
    supportedDefinitionTypes: [],
    id: "netlify-graph-codegen/remix",
    version: "0.0.1",
    generateHandler: function (opts) { return __awaiter(void 0, void 0, void 0, function () {
        var netlifyGraphConfig, options, operationDataList, firstOperation, filename, isSubscription, result, passThroughResults, clientSideCalls, whitespace, snippet, route;
        return __generator(this, function (_a) {
            netlifyGraphConfig = opts.netlifyGraphConfig, options = opts.options;
            operationDataList = opts.operationDataList.map(function (operationData, idx) {
                if (!isOperationNamed(operationData)) {
                    return __assign(__assign({}, operationData), { name: ("unnamed" + capitalizeFirstLetter(operationData.type) + (idx + 1)).trim(), query: "# Consider giving this " + operationData.type + " a unique, descriptive\n# name in your application as a best practice\n" + operationData.type + " unnamed" + capitalizeFirstLetter(operationData.type) + (idx + 1) + " " + operationData.query
                            .trim()
                            .replace(/^(query|mutation|subscription) /i, "") });
                }
                return operationData;
            });
            firstOperation = operationDataList.find(function (operation) {
                return operation.operationDefinition.kind === "OperationDefinition";
            });
            if (!firstOperation) {
                return [2 /*return*/, {
                        exportedFiles: [
                            {
                                kind: "UnnamedExportedFile",
                                content: "// No operation found",
                                language: "javascript",
                            },
                        ],
                    }];
            }
            filename = firstOperation.name + "." + netlifyGraphConfig.extension;
            isSubscription = firstOperation.type === "subscription";
            if (isSubscription) {
                result = subscriptionHandler({
                    netlifyGraphConfig: netlifyGraphConfig,
                    operationData: firstOperation,
                });
                return [2 /*return*/, {
                        exportedFiles: [result],
                    }];
            }
            passThroughResults = operationDataList.length === 1
                ? "errors, data"
                : operationDataList
                    .filter(function (operationData) {
                    return ["query", "mutation", "subscription"].includes(operationData.type);
                })
                    .map(function (_operationData) { return "errors,\ndata"; })
                    .join(",\n");
            clientSideCalls = clientSideInvocations(operationDataList, options.postHttpMethod === true ? "post" : "get", options.useClientAuth);
            whitespace = 4;
            snippet = ts(netlifyGraphConfig, 'import type { NextApiRequest, NextApiResponse } from "next";') + "\n" + imp(netlifyGraphConfig, "NetlifyGraph", netlifyGraphConfig.netlifyGraphRequirePath) + ";\n\n/**\n * Client-side invocations:\n * Call your Netlify function from the browser with this helper:\n */\n\n/**\n" + clientSideCalls + "\n*/";
            route = generateRoute({
                GraphQL: opts.GraphQL,
                netlifyGraphConfig: netlifyGraphConfig,
                operationData: firstOperation,
                schema: opts.schema,
                route: "/" + firstOperation.displayName,
            });
            return [2 /*return*/, {
                    language: "javascript",
                    exportedFiles: [route],
                }];
        });
    }); },
};
exports.id = "netlify-builtin:remix";
exports.version = "0.0.1";
exports.generators = [exports.remixFunctionSnippet];
exports.codegenModule = {
    id: exports.id,
    version: exports.version,
    generators: exports.generators,
    generateRuntime: common_1.generateRuntime,
    sigil: "netlify-builtin:remix",
};
//# sourceMappingURL=remixExporter.js.map