"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.codegenModule = exports.generators = exports.version = exports.id = exports.netlifyFunctionSnippet = exports.computeOperationDataList = void 0;
var graphql_1 = require("graphql");
var codegenHelpers_1 = require("./codegenHelpers");
var internalConsole_1 = require("../internalConsole");
var common_1 = require("./common");
var graphqlHelpers_1 = require("../graphqlHelpers");
var operationNodesMemo = [null, null];
var getOperationNodes = function (query) {
    if (operationNodesMemo[0] === query && operationNodesMemo[1]) {
        return operationNodesMemo[1];
    }
    var operationDefinitions = [];
    try {
        (0, graphql_1.parse)(query).definitions.forEach(function (def) {
            if (def.kind === "FragmentDefinition" ||
                def.kind === "OperationDefinition") {
                operationDefinitions.push(def);
            }
        });
    }
    catch (parseError) {
        // ignore
    }
    operationNodesMemo = [query, operationDefinitions];
    return operationDefinitions;
};
var getOperationName = function (operationDefinition) {
    return operationDefinition.name
        ? operationDefinition.name.value
        : operationDefinition.operation;
};
var getOperationDisplayName = function (operationDefinition) {
    return operationDefinition.name
        ? operationDefinition.name.value
        : "<Unnamed:" + operationDefinition.operation + ">";
};
var formatVariableName = function (name) {
    var uppercasePattern = /[A-Z]/g;
    return (name.charAt(0).toUpperCase() +
        name.slice(1).replace(uppercasePattern, "_$&").toUpperCase());
};
var getUsedVariables = function (variables, operationDefinition) {
    return (operationDefinition.variableDefinitions || []).reduce(function (usedVariables, variable) {
        var variableName = variable.variable.name.value;
        if (variables[variableName]) {
            usedVariables[variableName] = variables[variableName];
        }
        return usedVariables;
    }, {});
};
var findFragmentDependencies = function (fragmentDefinitions, definition) {
    var fragmentByName = function (name) {
        return fragmentDefinitions.find(function (def) { var _a; return ((_a = def.name) === null || _a === void 0 ? void 0 : _a.value) === name; });
    };
    var findReferencedFragments = function (selectionSet) {
        var selections = selectionSet.selections;
        var namedFragments = selections
            .map(function (selection) {
            if (selection.kind === "FragmentSpread") {
                return fragmentByName(selection.name.value);
            }
            return null;
        })
            .filter(Boolean);
        var nestedNamedFragments = selections.reduce(function (acc, selection) {
            if ((selection.kind === "Field" ||
                selection.kind === "SelectionNode" ||
                selection.kind === "InlineFragment") &&
                selection.selectionSet !== undefined) {
                return __spreadArray(__spreadArray([], acc, true), findReferencedFragments(selection.selectionSet), true);
            }
            return acc;
        }, []);
        return __spreadArray(__spreadArray([], namedFragments, true), nestedNamedFragments, true);
    };
    var selectionSet = definition.selectionSet;
    return findReferencedFragments(selectionSet);
};
var operationDataByName = function (graph, name) {
    return graph.find(function (operationData) { return operationData.name === name; });
};
var topologicalSortHelper = function (_a, result) {
    var graph = _a.graph, node = _a.node, temp = _a.temp, visited = _a.visited;
    temp[node.name] = true;
    var neighbors = node.fragmentDependencies;
    neighbors.forEach(function (fragmentDependency) {
        var fragmentOperationData = operationDataByName(graph, fragmentDependency.name.value);
        if (!fragmentOperationData) {
            return;
        }
        if (temp[fragmentOperationData.name]) {
            internalConsole_1.internalConsole.error("The operation graph has a cycle");
            return;
        }
        if (!visited[fragmentOperationData.name]) {
            topologicalSortHelper({
                node: fragmentOperationData,
                visited: visited,
                temp: temp,
                graph: graph,
            }, result);
        }
    });
    temp[node.name] = false;
    visited[node.name] = true;
    result.push(node);
};
var toposort = function (graph) {
    var result = [];
    var visited = {};
    var temp = {};
    graph.forEach(function (node) {
        if (!visited[node.name] && !temp[node.name]) {
            topologicalSortHelper({ node: node, visited: visited, temp: temp, graph: graph }, result);
        }
    });
    return result;
};
var computeOperationDataList = function (_a) {
    var GraphQL = _a.GraphQL, parsedDoc = _a.parsedDoc, query = _a.query, variables = _a.variables, fragmentDefinitions = _a.fragmentDefinitions;
    var operationDefinitions = getOperationNodes(query);
    var rawOperationDataList = operationDefinitions.map(function (operationDefinition) {
        var _a, _b;
        var persistableOperationString = operationDefinition.kind === graphql_1.Kind.OPERATION_DEFINITION
            ? (_b = (_a = (0, graphqlHelpers_1.extractPersistableOperation)(GraphQL, parsedDoc, operationDefinition)) === null || _a === void 0 ? void 0 : _a.persistableOperationString) !== null && _b !== void 0 ? _b : null
            : null;
        return {
            query: (0, graphql_1.print)(operationDefinition),
            name: getOperationName(operationDefinition),
            displayName: getOperationDisplayName(operationDefinition),
            type: operationDefinition.kind === graphql_1.Kind.OPERATION_DEFINITION
                ? operationDefinition.operation
                : "fragment",
            variableName: formatVariableName(getOperationName(operationDefinition)),
            variables: getUsedVariables(variables, operationDefinition),
            operationDefinition: operationDefinition,
            fragmentDependencies: findFragmentDependencies(fragmentDefinitions, operationDefinition),
            persistableOperationString: persistableOperationString,
        };
    });
    var operationDataList = toposort(rawOperationDataList);
    return {
        operationDefinitions: operationDefinitions,
        fragmentDefinitions: fragmentDefinitions,
        rawOperationDataList: rawOperationDataList,
        operationDataList: operationDataList,
    };
};
exports.computeOperationDataList = computeOperationDataList;
var capitalizeFirstLetter = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
var unnamedSymbols = new Set(["query", "mutation", "subscription"]);
var isOperationNamed = function (operationData) {
    return !unnamedSymbols.has(operationData.name.trim());
};
var addLeftWhitespace = function (string, padding) {
    var paddingString = " ".repeat(padding);
    return string
        .split("\n")
        .map(function (line) { return paddingString + line; })
        .join("\n");
};
var collapseExtraNewlines = function (string) { return string.replace(/\n{2,}/g, "\n\n"); };
var snippetOptions = {
    inputTypename: "Options",
    schemaSdl: "\n  enum HttpMethod {\n    POST\n    GET\n  }\n\ninput Options {\n    \"\"\"\n    Make call over POST\n    \"\"\"\n    postHttpMethod: HttpMethod\n    \"\"\"\n    Use user's OAuth token\n    \"\"\"\n    useClientAuth: Boolean!\n}\n    ",
};
var operationFunctionName = function (operationData) {
    var type = operationData.type;
    var prefix = "unknow";
    switch (type) {
        case "query":
            prefix = "fetch";
            break;
        case "mutation":
            prefix = "execute";
            break;
        case "subscription":
            prefix = "subscribeTo";
            break;
        default:
            break;
    }
    var fnName = prefix +
        (prefix.length === 0
            ? operationData.name
            : capitalizeFirstLetter(operationData.name));
    return fnName;
};
var coercerFor = function (type, name) {
    var typeName = (0, graphql_1.print)(type).replace(/\W+/gi, "").toLocaleLowerCase();
    switch (typeName) {
        case "string":
            return "" + name;
        case "int":
            return "parseInt(" + name + ")";
        case "float":
            return "parseFloat(" + name + ")";
        case "boolean":
            return name + " === 'true'";
        default:
            return "" + name;
    }
};
var asyncFetcherInvocation = function (operationDataList, pluckerStyle) {
    var invocations = operationDataList
        .filter(function (operationData) {
        return ["query", "mutation", "subscription"].includes(operationData.type);
    })
        .map(function (namedOperationData) {
        var _a, _b, _c, _d, _e;
        var params = (namedOperationData.operationDefinition.variableDefinitions || []).map(function (def) { return def.variable.name.value; });
        var invocationParams = params.map(function (param) { return param + ": " + (0, codegenHelpers_1.munge)(param); });
        var pluckers = {
            get: ((_b = (_a = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _a === void 0 ? void 0 : _a.variableDefinitions) === null || _b === void 0 ? void 0 : _b.map(function (def) {
                var name = def.variable.name.value;
                var withCoercer = coercerFor(def.type, "event.queryStringParameters?." + name);
                return "const " + (0, codegenHelpers_1.munge)(name) + " = " + withCoercer + ";";
            }).join("\n  ")) || "",
            post: ((_d = (_c = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _c === void 0 ? void 0 : _c.variableDefinitions) === null || _d === void 0 ? void 0 : _d.map(function (def) {
                var name = def.variable.name.value;
                return "const " + (0, codegenHelpers_1.munge)(name) + " = eventBodyJson?." + name + ";";
            }).join("\n  ")) || "",
        };
        var variableValidation = "";
        var requiredVariableCount = 0;
        if ((((_e = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _e === void 0 ? void 0 : _e.variableDefinitions) || [])
            .length !== 0 ||
            0) {
            var requiredVariableNames = namedOperationData.operationDefinition.variableDefinitions
                .map(function (def) {
                return (0, graphql_1.print)(def.type).endsWith("!") ? def.variable.name.value : null;
            })
                .filter(Boolean);
            requiredVariableCount = requiredVariableNames.length;
            // TODO: Filter nullable variables
            var condition = requiredVariableNames
                .map(function (name) { return (0, codegenHelpers_1.munge)(name) + " === undefined || " + (0, codegenHelpers_1.munge)(name) + " === null"; })
                .join(" || ");
            var message = requiredVariableNames
                .map(function (name) { return "`" + name + "`"; })
                .join(", ");
            variableValidation = "  if (" + condition + ") {\n    return {\n      statusCode: 422,\n      body: JSON.stringify({\n        error: 'You must supply parameters for: " + message + "'\n      }),\n    };\n  }";
        }
        return (pluckerStyle === "get" ? pluckers.get : pluckers.post) + "\n\n" + (requiredVariableCount > 0 ? variableValidation : "") + "\n\n  const { errors: " + namedOperationData.name + "Errors, data: " + namedOperationData.name + "Data } =\n    await NetlifyGraph." + operationFunctionName(namedOperationData) + "({ " + invocationParams.join(", ") + " }, {accessToken: accessToken});\n\n  if (" + namedOperationData.name + "Errors) {\n    console.error(JSON.stringify(" + namedOperationData.name + "Errors, null, 2));\n  }\n\n  console.log(JSON.stringify(" + namedOperationData.name + "Data, null, 2));";
    })
        .join("\n\n");
    return invocations;
};
var clientSideInvocations = function (operationDataList, pluckerStyle, useClientAuth) {
    var invocations = operationDataList
        .filter(function (operationData) {
        return ["query", "mutation", "subscription"].includes(operationData.type);
    })
        .map(function (namedOperationData) {
        var _a, _b;
        var whitespace = 8;
        var params = (namedOperationData.operationDefinition.variableDefinitions || []).map(function (def) { return def.variable.name.value; });
        var bodyPayload = "";
        if (((_b = (_a = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _a === void 0 ? void 0 : _a.variableDefinitions) === null || _b === void 0 ? void 0 : _b.length) ||
            0 > 0) {
            var variableNames = namedOperationData.operationDefinition.variableDefinitions.map(function (def) { return def.variable.name.value; });
            var variables = variableNames
                .map(function (name) { return "\"" + name + "\": " + name; })
                .join(",\n");
            bodyPayload = "\n" + variables + "\n";
        }
        var clientAuth = useClientAuth
            ? ",\n      headers: {\n        ...netlifyGraphAuth?.authHeaders()\n      }"
            : "";
        return "async function " + operationFunctionName(namedOperationData) + "(" + (useClientAuth ? "netlifyGraphAuth, " : "") + "params) {\n  const {" + params.join(", ") + "} = params || {};\n  const resp = await fetch(`/.netlify/functions/" + namedOperationData.name + (pluckerStyle === "get"
            ? "?" + params.map(function (param) { return param + "=${" + param + "}"; }).join("&")
            : "") + "`,\n    {\n      method: \"" + pluckerStyle.toLocaleUpperCase() + "\"" + (pluckerStyle === "get"
            ? ""
            : ",\n      body: JSON.stringify({" + addLeftWhitespace(bodyPayload, whitespace).trim() + "})" + clientAuth) + "\n    });\n\n    const text = await resp.text();\n\n    return JSON.parse(text);\n}";
    })
        .join("\n\n");
    return invocations;
};
var subscriptionHandler = function (_a) {
    var netlifyGraphConfig = _a.netlifyGraphConfig, operationData = _a.operationData;
    return {
        kind: "UnnamedExportedFile",
        language: "javascript",
        content: imp(netlifyGraphConfig, "NetlifyGraph", netlifyGraphConfig.netlifyGraphRequirePath) + "\n\n" + exp(netlifyGraphConfig, "handler") + " = async (event, context) => {\n  const payload = NetlifyGraph.parseAndVerify" + operationData.name + "Event(event);\n\n  if (!payload) {\n    return {\n      statusCode: 412,\n      data: JSON.stringify({\n        success: false,\n        error: 'Unable to verify payload signature',\n      }),\n    };\n  }\n  const { errors: " + operationData.name + "Errors, data: " + operationData.name + "Data } = payload;\n\n  if (" + operationData.name + "Errors) {\n    console.error(" + operationData.name + "Errors);\n  }\n\n  console.log(" + operationData.name + "Data);\n\n  /**\n   * If you want to unsubscribe from this webhook\n   * in order to stop receiving new events,\n   * simply return status 410, e.g.:\n   *\n   * return {\n   *   statusCode: 410,\n   *   body: JSON.stringify(null),\n   *   headers: {\n   *     'content-type': 'application/json',\n   *   },\n   * }\n   */\n\n  return {\n    statusCode: 200,\n    body: JSON.stringify({\n      successfullyProcessedIncomingWebhook: true,\n    }),\n    headers: {\n      'content-type': 'application/json',\n    },\n  };\n};\n",
    };
};
var imp = function (netlifyGraphConfig, name, packageName) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "const " + name + " = require(\"" + packageName + "\")";
    }
    return "import " + name + " from \"" + packageName + "\"";
};
var exp = function (netlifyGraphConfig, name) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "exports." + name;
    }
    return "export const " + name;
};
// Snippet generation!
exports.netlifyFunctionSnippet = {
    name: "Netlify Function",
    generateHandlerOptions: snippetOptions,
    supportedDefinitionTypes: [],
    id: "netlify-graph-codegen/serverless",
    version: "0.0.1",
    generateHandler: function (opts) { return __awaiter(void 0, void 0, void 0, function () {
        var netlifyGraphConfig, options, operationDataList, firstOperation, filename, isSubscription, result, fetcherInvocation, passThroughResults, clientSideCalls, whitespace, snippet, content;
        return __generator(this, function (_a) {
            netlifyGraphConfig = opts.netlifyGraphConfig, options = opts.options;
            operationDataList = opts.operationDataList.map(function (operationData, idx) {
                if (!isOperationNamed(operationData)) {
                    return __assign(__assign({}, operationData), { name: ("unnamed" + capitalizeFirstLetter(operationData.type) + (idx + 1)).trim(), query: "# Consider giving this " + operationData.type + " a unique, descriptive\n# name in your application as a best practice\n" + operationData.type + " unnamed" + capitalizeFirstLetter(operationData.type) + (idx + 1) + " " + operationData.query
                            .trim()
                            .replace(/^(query|mutation|subscription) /i, "") });
                }
                return operationData;
            });
            firstOperation = operationDataList.find(function (operation) {
                return operation.operationDefinition.kind === "OperationDefinition";
            });
            if (!firstOperation) {
                return [2 /*return*/, {
                        exportedFiles: [
                            {
                                kind: "UnnamedExportedFile",
                                content: "// No operation found",
                                language: "javascript",
                            },
                        ],
                    }];
            }
            filename = firstOperation.name + "." + netlifyGraphConfig.extension;
            isSubscription = firstOperation.type === "subscription";
            if (isSubscription) {
                result = subscriptionHandler({
                    netlifyGraphConfig: netlifyGraphConfig,
                    operationData: firstOperation,
                });
                return [2 /*return*/, {
                        exportedFiles: [result],
                    }];
            }
            fetcherInvocation = asyncFetcherInvocation(operationDataList, options.postHttpMethod === true ? "post" : "get");
            passThroughResults = operationDataList
                .filter(function (operationData) {
                return ["query", "mutation", "subscription"].includes(operationData.type);
            })
                .map(function (operationData) { return operationData.name + "Errors: " + operationData.name + "Errors,\n" + operationData.name + "Data: " + operationData.name + "Data"; })
                .join(",\n");
            clientSideCalls = clientSideInvocations(operationDataList, options.postHttpMethod === true ? "post" : "get", options.useClientAuth);
            whitespace = 6;
            snippet = imp(netlifyGraphConfig, "NetlifyGraph", "./netlifyGraph") + "\n\n" + exp(netlifyGraphConfig, "handler") + " = async (event) => {\n  // By default, all API calls use no authentication\n  let accessToken;\n\n  //// If you want to use the client's accessToken when making API calls on the user's behalf:\n  // accessToken = event.headers[\"authorization\"]?.split(\" \")[1]\n\n  //// If you want to use the API with your own access token:\n  // accessToken = event.netlifyGraphToken\n      \n  const eventBodyJson = JSON.parse(event.body || \"{}\");\n\n  " + fetcherInvocation + "\n\n  return {\n    statusCode: 200,\n    body: JSON.stringify({\n      success: true,\n" + addLeftWhitespace(passThroughResults, whitespace) + "\n    }),\n    headers: {\n      'content-type': 'application/json',\n    },\n  };\n};\n\n/** \n * Client-side invocations:\n * Call your Netlify function from the browser (after saving\n * the code to `" + filename + "`) with these helpers:\n */\n\n/**\n" + clientSideCalls + "\n*/\n";
            content = collapseExtraNewlines(snippet);
            return [2 /*return*/, {
                    exportedFiles: [
                        {
                            kind: "UnnamedExportedFile",
                            content: content,
                            language: "javascript",
                        },
                    ],
                }];
        });
    }); },
};
exports.id = "netlify-builtin:serverless";
exports.version = "0.0.1";
exports.generators = [exports.netlifyFunctionSnippet];
exports.codegenModule = {
    id: exports.id,
    version: exports.version,
    generators: exports.generators,
    generateRuntime: common_1.generateRuntime,
    sigil: "netlify-builtin:serverless",
};
//# sourceMappingURL=genericExporter.js.map