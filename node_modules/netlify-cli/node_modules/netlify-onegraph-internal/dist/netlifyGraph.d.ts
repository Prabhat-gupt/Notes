import { DocumentNode, FragmentDefinitionNode, GraphQLSchema, OperationDefinitionNode, OperationTypeNode } from "graphql";
import * as GraphQLPackage from "graphql";
import { Codegen, ExportedFile } from "./codegen/codegenHelpers";
import { CodegenHelpers } from ".";
export declare type State = {
    set: (key: string, value?: any) => any;
    get: (key: string) => any;
};
export declare type NetlifySite = {
    id: string;
};
export declare const NETLIFY_DIRECTIVE_NAME = "netlify";
export declare const NETLIFY_CACHE_CONTROL_DIRECTIVE_NAME = "netlifyCacheControl";
export declare type NetlifyGraphConfig = {
    functionsPath: string[];
    webhookBasePath: string;
    netlifyGraphImplementationFilename: string[];
    netlifyGraphTypeDefinitionsFilename: string[];
    graphQLOperationsSourceDirectory: string[];
    graphQLSchemaFilename: string[];
    netlifyGraphRequirePath: string[];
    netlifyGraphPath: string[];
    graphQLOperationsSourceFilename?: string[];
    graphQLConfigJsonFilename: string[];
    framework: string;
    extension: string;
    moduleType: "commonjs" | "esm";
    language: "javascript" | "typescript";
    runtimeTargetEnv: "node" | "browser";
};
export declare type ExecutionStrategy = "DYNAMIC" | "PERSISTED";
export declare type CacheStrategy = {
    enabled: boolean;
    timeToLiveSeconds: number;
};
export declare type ExtractedFunction = {
    id: string;
    operationName: string;
    description: string;
    kind: OperationTypeNode;
    executionStrategy: ExecutionStrategy;
    cacheStrategy: CacheStrategy | undefined;
    fallbackOnError: boolean;
    parsedOperation: OperationDefinitionNode;
    operationString: string;
    operationStringWithoutNetlifyDirective: string;
    persistableOperationString: string;
};
export declare type ExtractedFragment = {
    id: string;
    fragmentName: string;
    typeCondition: string;
    description: string;
    kind: "fragment";
    parsedOperation: FragmentDefinitionNode;
    operationString: string;
    operationStringWithoutNetlifyDirective: string;
};
export declare type ParsedFunction = ExtractedFunction & {
    fnName: string;
    safeBody: string;
    returnSignature: string;
    variableSignature: string;
    variableNames: string[];
};
export declare type ParsedFragment = ExtractedFragment & {
    safeBody: string;
    returnSignature: string;
};
export declare type PersistedFunction = ParsedFunction & {
    persistedDocId: string;
};
export declare const defaultSourceOperationsDirectoryName: string[];
export declare const defaultSourceOperationsFilename = "netlifyGraphOperationsLibrary.graphql";
export declare const defaultGraphQLSchemaFilename = "netlifyGraphSchema.graphql";
export declare const defaultNetlifyGraphConfig: NetlifyGraphConfig;
export declare const defaultExampleOperationsDoc = "query ExampleQuery @netlify(doc: \"An example query to start with.\") {\n  __typename\n}";
export declare const generateSubscriptionFunctionTypeDefinition: (GraphQL: typeof GraphQLPackage, schema: GraphQLSchema, fn: ParsedFunction, fragments: Record<string, ParsedFragment>) => string;
export declare const generateSubscriptionFunction: (GraphQL: typeof GraphQLPackage, schema: GraphQLSchema, fn: ParsedFunction, fragments: never[], netlifyGraphConfig: NetlifyGraphConfig) => string;
export declare const fragmentToParsedFragmentDefinition: (GraphQL: typeof GraphQLPackage, currentFragments: Record<string, FragmentDefinitionNode>, fullSchema: GraphQLSchema, extractedFragment: ExtractedFragment) => {
    fragmentDefinitions: Record<string, FragmentDefinitionNode[]>;
    fragment?: ParsedFragment | undefined;
};
export declare const queryToFunctionDefinition: (GraphQL: typeof GraphQLPackage, fullSchema: GraphQLSchema, parsedDoc: DocumentNode, persistedQuery: ExtractedFunction, enabledFragments: Record<string, ParsedFragment>) => ParsedFunction | undefined;
export declare const generateRuntime: ({ GraphQL, fragments, generate, netlifyGraphConfig, operationsDoc, operations, schema, schemaId, }: {
    GraphQL: typeof GraphQLPackage;
    netlifyGraphConfig: NetlifyGraphConfig;
    schema: GraphQLSchema;
    operationsDoc: string;
    operations: Record<string, ExtractedFunction>;
    fragments: Record<string, ExtractedFragment>;
    generate: CodegenHelpers.GenerateRuntimeFunction;
    schemaId: string;
}) => Promise<CodegenHelpers.NamedExportedFile[]>;
export declare const pluckNetlifyDirective: (definitionNode: OperationDefinitionNode | FragmentDefinitionNode) => {
    id: string;
    description: string;
    executionStrategy: ExecutionStrategy;
} | null;
export declare const pluckNetlifyCacheControlDirective: (definitionNode: OperationDefinitionNode) => {
    cacheStrategy: CacheStrategy | undefined;
    fallbackOnError: boolean;
};
/**
 * Extracts basic functions from a parsed GraphQL operations document
 * @param {DocumentNode} parsedDoc The parsed GraphQL document with @netlify directives
 * @returns {functions: Record<string, ExtractedFunction>, fragments: Record<string, ExtractedFragment>}
 */
export declare const extractFunctionsFromOperationDoc: (GraphQL: typeof GraphQLPackage, parsedDoc: DocumentNode) => {
    functions: Record<string, ExtractedFunction>;
    fragments: Record<string, ExtractedFragment>;
};
/**
 * Given a schema, GraphQL operations doc, a target definitionId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
export declare const generateHandlerSource: ({ GraphQL, handlerOptions, netlifyGraphConfig, operationId: definitionId, operationsDoc, schema, }: {
    GraphQL: typeof GraphQLPackage;
    handlerOptions: Record<string, boolean>;
    netlifyGraphConfig: NetlifyGraphConfig;
    operationId: string;
    operationsDoc: string;
    schema: GraphQLSchema;
}) => Promise<{
    exportedFiles: ExportedFile[];
    operation: OperationDefinitionNode;
} | undefined>;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
export declare const generateCustomHandlerSource: ({ GraphQL, handlerOptions, netlifyGraphConfig, operationId, operationsDoc, schema, generate, }: {
    GraphQL: typeof GraphQLPackage;
    handlerOptions: Record<string, boolean>;
    netlifyGraphConfig: NetlifyGraphConfig;
    operationId: string;
    operationsDoc: string;
    schema: GraphQLSchema;
    generate: Codegen["generateHandler"];
}) => Promise<{
    exportedFiles: ExportedFile[];
    operation: OperationDefinitionNode;
} | undefined>;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a preview of the full handler's output
 */
export declare const generatePreview: ({ GraphQL, handlerOptions, netlifyGraphConfig, operationId, operationsDoc, schema, generate, }: {
    GraphQL: typeof GraphQLPackage;
    handlerOptions: Record<string, boolean>;
    netlifyGraphConfig: NetlifyGraphConfig;
    operationId: string;
    operationsDoc: string;
    schema: GraphQLSchema;
    generate: Codegen["generatePreview"];
}) => {
    exportedFile: ExportedFile;
    operation: OperationDefinitionNode;
} | undefined;
