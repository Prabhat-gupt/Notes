import GeneratedClient, { GraphQLError } from "./generatedOneGraphClient";
import type { CLISessionQuery, CreateNewSchemaMutationInput } from "./generatedOneGraphClient";
import type { GraphQLSchema, IntrospectionQuery } from "graphql";
export declare type JwtResult = {
    jwt: string;
    expiration: number;
};
export declare function getGraphJwtForSite({ siteId, nfToken, }: {
    siteId: string;
    nfToken: string;
}): Promise<JwtResult>;
/**
 * Fetch a schema (in json form) for an app by its schemaId
 * @param {object} input
 * @param {string} input.appId
 * @param {string} input.schemaId
 * @param {string} input.accessToken
 * @returns {Promise<Record<string, any>>} The schema json
 */
export declare const fetchOneGraphSchemaByIdJson: ({ appId, schemaId, accessToken, }: {
    appId: string;
    schemaId: string;
    accessToken: string;
}) => Promise<{
    data: IntrospectionQuery;
} | undefined>;
/**
 * Fetch a schema and parse it for an app by its schemaId
 * @param {object} input
 * @param {string} input.siteId
 * @param {string} input.schemaId
 * @param {string} input.accessToken
 * @returns {Promise<GraphQLSchema>} The schema for the app
 */
export declare const fetchOneGraphSchemaById: ({ siteId, schemaId, accessToken, }: {
    siteId: string;
    schemaId: string;
    accessToken: string;
}) => Promise<GraphQLSchema | undefined>;
/**
 * Given an appId and desired services, fetch the schema (in json form) for that app
 * @param {string} appId
 * @param {string[]} enabledServices
 * @returns {Promise<Record<string, unknown>>} The schema for the app
 */
export declare const fetchOneGraphSchemaForServicesJson: (appId: string, enabledServices: string[]) => Promise<{
    data: IntrospectionQuery;
} | undefined>;
/**
 * Given an appId and desired services, fetch the schema json for an app and parse it into a GraphQL Schema
 * @param {string} appId
 * @param {string[]} enabledServices
 * @returns {Promise<GraphQLSchema>} The schema for the app
 */
export declare const fetchOneGraphSchemaForServices: (appId: string, enabledServices: string[]) => Promise<GraphQLSchema | undefined>;
export declare type PersistedQuery = {
    id: string;
    query: string;
    freeVariables?: string[];
    fixedVariables?: unknown;
    description?: string;
    allowedOperationNames?: string[];
    tags?: string[];
};
/**
 * Fetch a persisted doc belonging to appId by its id
 * @param {string} jwt
 * @param {string} appId
 * @param {string} docId
 * @returns {string|undefined} The persisted operations doc
 */
export declare const fetchPersistedQuery: (jwt: string, appId: string, docId: string) => Promise<PersistedQuery | undefined>;
declare type OneGraphCliEvent = Record<string, any>;
/**
 *
 * @param {object} options
 * @param {string} options.appId The app to query against, typically the siteId
 * @param {string} options.jwt The netlify jwt that is used for authentication
 * @param {string} options.sessionId The session id to fetch CLI events for
 * @returns {Promise<{session: CLISessionQuery["data"]["oneGraph"]["netlifyCliSession"] , errors: any[]}>} The unhandled events for the cli session to process
 */
export declare const fetchCliSession: (options: {
    appId: string;
    jwt: string;
    sessionId: string;
    desiredEventCount?: number | undefined;
}) => Promise<{
    session: CLISessionQuery["data"]["oneGraph"]["netlifyCliSession"];
    errors?: GraphQLError[] | undefined;
}>;
/**
 *
 * @param {object} options
 * @param {string} options.appId The app to query against, typically the siteId
 * @param {string} options.jwt The netlify jwt that is used for authentication
 * @param {string} options.sessionId The session id to fetch CLI events for
 * @returns {Promise<OneGraphCliEvent[]|undefined>} The unhandled events for the cli session to process
 */
export declare const fetchCliSessionEvents: (options: {
    appId: string;
    jwt: string;
    sessionId: string;
}) => Promise<{
    events?: OneGraphCliEvent[] | undefined;
    errors?: any[] | undefined;
} | undefined>;
/**
 * Register a new CLI session with OneGraph
 * @param {string} jwt The netlify jwt to use for authentication
 * @param {string} appId The app to query against, typically the siteId
 * @param {string} name The name of the CLI session, will be visible in the UI and CLI ouputs
 * @param {object} metadata Any additional metadata to attach to the session
 * @returns {Promise<object|undefined>} The CLI session object
 */
export declare const createCLISession: (jwt: string, appId: string, name: string, metadata: Record<string, any>) => Promise<object | undefined>;
/**
 * Update the CLI session with new metadata (e.g. the latest docId) by its id
 * @param {string} jwt The netlify jwt to use for authentication
 * @param {string} appId The app to query against, typically the siteId
 * @param {string} sessionId The session id to update
 * @param {object} metadata The new metadata to set on the session
 * @returns {Promise<object|undefined>} The updated session object
 */
export declare const updateCLISessionMetadata: (jwt: string, appId: string, sessionId: string, metadata: Record<string, any>) => Promise<object | undefined>;
/**
 * Acknoledge CLI events that have been processed and delete them from the upstream queue
 * @param {object} input
 * @param {string} input.appId The app to query against, typically the siteId
 * @param {string} input.jwt The netlify jwt that is used for authentication, if any
 * @param {string} input.sessionId The session id the events belong to
 * @param {string[]} input.eventIds The event ids to ack (and delete) from the session queue, having been processed
 * @returns
 */
export declare const ackCLISessionEvents: (input: {
    appId: string;
    jwt: string;
    sessionId: string;
    eventIds: string[];
}) => Promise<{
    events: {
        id: string;
    }[];
}>;
export declare const executeCreatePersistedQueryMutation: typeof import("./generatedOneGraphClient").executeCreatePersistedQueryMutation;
/**
 *
 * @param {OneGraphCliEvent} event
 * @returns {string} a human-friendly description of the event
 */
export declare const friendlyEventName: (event: OneGraphCliEvent) => string;
export declare type OneGraphCliEventAudience = "UI" | "CLI";
/**
 *
 * @param {OneGraphCliEvent} event
 * @returns {OneGraphCliEventAudience} Which audience the event is intended for
 */
export declare const eventAudience: (event: OneGraphCliEvent) => OneGraphCliEventAudience;
/**
 * Fetch the schema metadata for a site (enabled services, id, etc.)
 */
export declare const fetchAppSchemaQuery: typeof GeneratedClient.fetchAppSchemaQuery;
/**
 * If a site does not exists upstream in OneGraph for the given site, create it
 * @param {string} jwt The netlify jwt that is used for authentication, if any
 * @param {string} siteId The site id to create an app for upstream on OneGraph
 * @returns
 */
export declare const upsertAppForSite: (jwt: string, siteId: string) => Promise<{
    id: string;
    name: string;
    corsOrigins: string[];
    customCorsOrigins: {
        friendlyServiceName: string;
        displayName: string;
        encodedValue: string;
    }[];
}>;
/**
 * Create a new schema in OneGraph for the given site with the specified metadata (enabled services, etc.)
 * @param {string} jwt The netlify jwt that is used for authentication, if any
 * @param {object} input The details of the schema to create
 * @returns {Promise<object>} The schema metadata for the site
 */
export declare const createNewAppSchema: (jwt: string, input: CreateNewSchemaMutationInput["input"]) => Promise<object>;
/**
 * Ensure that an app exists upstream in OneGraph for the given site
 * @param {string} jwt The netlify jwt that is used for authentication, if any
 * @param {string} siteId The site id to create an app for upstream on OneGraph
 * @returns
 */
export declare const ensureAppForSite: (jwt: string, siteId: string) => Promise<void>;
/**
 * Fetch a list of what services are enabled for the given site
 * @param {string} jwt The netlify jwt that is used for authentication
 * @param {string} appId The app id to query against
 * @returns
 */
export declare const fetchEnabledServicesForApp: (jwt: string, appId: string) => Promise<{
    friendlyServiceName: string;
    logoUrl?: string | undefined;
    graphQLField: string;
    slug: string;
    supportsCustomRedirectUri: boolean;
    supportsCustomServiceAuth: boolean;
    supportsOauthLogin: boolean;
}[] | undefined>;
/**
 * Fetch a list of what services are enabled for the given session
 * @param {string} jwt The netlify jwt that is used for authentication
 * @param {string} sessionId The session ID to query against
 */
export declare const fetchGraphQLSchemaForSession: (jwt: string, siteId: string, sessionId: string) => Promise<{
    appId: string;
    createdAt: string;
    id: string;
    services: {
        friendlyServiceName: string;
        logoUrl?: string | undefined;
        graphQLField: string;
        slug: string;
        supportsCustomRedirectUri: boolean;
        supportsCustomServiceAuth: boolean;
        supportsOauthLogin: boolean;
    }[];
    updatedAt: string;
} | undefined>;
export declare type MiniSession = {
    id: string;
    status: "ACTIVE" | "INACTIVE" | "UNCLAIMED" | "TERMINATED";
    createdAt: string;
    updatedAt: string;
};
/**
 * Mark a CLI session as active and update the session's heartbeat
 * @param {string} jwt The netlify jwt that is used for authentication
 * @param {string} appId The app to query against, typically the siteId
 * @param {string} sessionId The session id to mark as active / update heartbeat
 * @returns {Promise<{ errors?: GraphQLError[]; data: MiniSession }>}
 */
export declare const executeMarkCliSessionActiveHeartbeat: (jwt: string, appId: string, sessionId: string) => Promise<{
    errors?: GraphQLError[];
    data: MiniSession;
}>;
/**
 * Mark a CLI session as inactive
 * @param {string} jwt The netlify jwt that is used for authentication
 * @param {string} appId The app to query against, typically the siteId
 * @param {string} sessionId The session id to mark as inactive
 * @returns {Promise<{ errors?: GraphQLError[]; data: MiniSession }>}
 */
export declare const executeMarkCliSessionInactive: (jwt: string, appId: string, sessionId: string) => Promise<{
    errors?: GraphQLError[];
    data: MiniSession;
}>;
export declare const executeCreateApiTokenMutation: typeof GeneratedClient.executeCreateApiTokenMutation;
export declare const executeCreateGraphQLSchemaMutation: typeof GeneratedClient.executeCreateGraphQLSchemaMutation;
/**
 * List shared documents given a set of filters
 */
export declare const fetchListSharedDocumentsQuery: typeof GeneratedClient.fetchListSharedDocumentsQuery;
/**
 * Create a document with a shared operation for others to import and use
 */
export declare const executeCreateSharedDocumentMutation: typeof GeneratedClient.executeCreateSharedDocumentMutation;
/**
 * Find a shared document given its id
 */
export declare const fetchSharedDocumentQuery: typeof GeneratedClient.fetchSharedDocumentQuery;
/**
 * Find a shared document given its id
 */
export declare const fetchListNetlifyEnabledServicesQuery: typeof GeneratedClient.fetchListNetlifyEnabledServicesQuery;
/**
 * Create a new event for a CLI session to consume
 */
export declare const executeCreateCLISessionEventMutation: typeof GeneratedClient.executeCreateCLISessionEventMutation;
/**
 * Fetch schema metadata for cli session
 */
export declare const fetchNetlifySessionSchemaQuery: typeof GeneratedClient.fetchFetchNetlifySessionSchemaQuery;
export {};
