"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePreview = exports.generateCustomHandlerSource = exports.generateHandlerSource = exports.extractFunctionsFromOperationDoc = exports.pluckNetlifyCacheControlDirective = exports.pluckNetlifyDirective = exports.generateRuntime = exports.queryToFunctionDefinition = exports.fragmentToParsedFragmentDefinition = exports.generateSubscriptionFunction = exports.generateSubscriptionFunctionTypeDefinition = exports.defaultExampleOperationsDoc = exports.defaultNetlifyGraphConfig = exports.defaultGraphQLSchemaFilename = exports.defaultSourceOperationsFilename = exports.defaultSourceOperationsDirectoryName = exports.NETLIFY_CACHE_CONTROL_DIRECTIVE_NAME = exports.NETLIFY_DIRECTIVE_NAME = void 0;
var uuid_1 = require("uuid");
var graphql_1 = require("graphql");
var internalConsole_1 = require("./internalConsole");
var graphqlHelpers_1 = require("./graphqlHelpers");
var genericExporter_1 = require("./codegen/genericExporter");
var nextjsExporter_1 = require("./codegen/nextjsExporter");
var remixExporter_1 = require("./codegen/remixExporter");
var capitalizeFirstLetter = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
var replaceAll = function (target, search, replace) {
    var simpleString = search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return target.replace(new RegExp(simpleString, "g"), replace);
};
exports.NETLIFY_DIRECTIVE_NAME = "netlify";
exports.NETLIFY_CACHE_CONTROL_DIRECTIVE_NAME = "netlifyCacheControl";
exports.defaultSourceOperationsDirectoryName = ["operations"];
exports.defaultSourceOperationsFilename = "netlifyGraphOperationsLibrary.graphql";
exports.defaultGraphQLSchemaFilename = "netlifyGraphSchema.graphql";
exports.defaultNetlifyGraphConfig = {
    extension: "js",
    functionsPath: ["netlify", "functions"],
    netlifyGraphPath: ["netlify", "functions", "netlifyGraph"],
    webhookBasePath: "/.netlify/functions",
    graphQLConfigJsonFilename: [".graphqlrc.json"],
    netlifyGraphImplementationFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        "index.js",
    ],
    netlifyGraphTypeDefinitionsFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        "index.d.ts",
    ],
    graphQLOperationsSourceDirectory: [
        "netlify",
        "functions",
        "netlifyGraph",
        "operations",
    ],
    graphQLSchemaFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        exports.defaultGraphQLSchemaFilename,
    ],
    netlifyGraphRequirePath: ["./netlifyGraph"],
    framework: "custom",
    moduleType: "commonjs",
    language: "javascript",
    runtimeTargetEnv: "node",
};
exports.defaultExampleOperationsDoc = "query ExampleQuery @netlify(doc: \"An example query to start with.\") {\n  __typename\n}";
var subscriptionParserReturnName = function (fn) {
    return fn.operationName + "Event";
};
var subscriptionParserName = function (fn) {
    return "parseAndVerify" + fn.operationName + "Event";
};
var subscriptionFunctionName = function (fn) {
    return "subscribeTo" + fn.operationName;
};
var generateSubscriptionFunctionTypeDefinition = function (GraphQL, schema, fn, fragments) {
    var fragmentDefinitions = Object.entries(fragments).reduce(function (acc, _a) {
        var _b;
        var fragmentName = _a[0], fragment = _a[1];
        return __assign(__assign({}, acc), (_b = {}, _b[fragmentName] = fragment.parsedOperation, _b));
    }, {});
    var parsingFunctionReturnSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperation)(GraphQL, schema, fn.parsedOperation, fragmentDefinitions);
    var variableNames = (fn.parsedOperation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(GraphQL, variableNames, schema, fn.parsedOperation);
    var jsDoc = replaceAll(fn.description || "", "*/", "!")
        .split("\n")
        .join("\n* ");
    return "/**\n* " + jsDoc + "\n*/\nexport function " + subscriptionFunctionName(fn) + "(\n  /**\n   * This will be available in your webhook handler as a query parameter.\n   * Use this to keep track of which subscription you're receiving\n   * events for.\n   */\n  variables: " + (variableSignature === "{}" ? "Record<string, never>" : variableSignature) + ",\n  options?: {\n    /**\n     * The accessToken to use for the lifetime of the subscription.\n     */\n    accessToken?: string | null | undefined;\n    /**\n     * A string id that will be passed to your webhook handler as a query parameter\n     * along with each event.\n     * This can be used to keep track of which subscription you're receiving\n     */\n    netlifyGraphWebhookId?: string | null | undefined;\n    /**\n     * The absolute URL of your webhook handler to handle events from this subscription.\n     */\n    webhookUrl?: string | null | undefined;\n    /**\n     * The secret to use when signing the webhook request. Use this to verify\n     * that the webhook payload is coming from Netlify Graph. Defaults to the\n     * value of the NETLIFY_GRAPH_WEBHOOK_SECRET environment variable.\n     */\n    webhookSecret?: string | null | undefined;\n  }) : void\n\nexport type " + subscriptionParserReturnName(fn) + " = " + parsingFunctionReturnSignature + "\n\n/**\n * Verify the " + fn.operationName + " event body is signed securely, and then parse the result.\n */\nexport function " + subscriptionParserName(fn) + " (/** A Netlify Handler Event */ event : WebhookEvent) : null | " + subscriptionParserReturnName(fn) + "\n";
};
exports.generateSubscriptionFunctionTypeDefinition = generateSubscriptionFunctionTypeDefinition;
// TODO: Handle fragments
var generateSubscriptionFunction = function (GraphQL, schema, fn, fragments, netlifyGraphConfig) {
    var _a;
    var patchedWithWebhookUrl = (0, graphqlHelpers_1.patchSubscriptionWebhookField)({
        GraphQL: GraphQL,
        schema: schema,
        definition: fn.parsedOperation,
    });
    var patched = (0, graphqlHelpers_1.patchSubscriptionWebhookSecretField)({
        GraphQL: GraphQL,
        schema: schema,
        definition: patchedWithWebhookUrl,
    });
    // TODO: Don't allow unnamed operations as subscription
    var filename = (patched.name && patched.name.value) || "Unknown";
    var body = (0, graphql_1.print)(patched);
    var safeBody = replaceAll(body, "${", "\\${");
    return "const " + subscriptionFunctionName(fn) + " = (\n  variables,\n  rawOptions\n  ) => {\n    const options = rawOptions || {};\n    const netlifyGraphWebhookId = options.netlifyGraphWebhookId;\n    const netlifyGraphWebhookUrl = options.webhookUrl || `${process.env.DEPLOY_URL}" + netlifyGraphConfig.webhookBasePath + "/" + filename + "?netlifyGraphWebhookId=${netlifyGraphWebhookId}`;\n    const secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET\n    const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}\n\n    const subscriptionOperationDoc = `" + safeBody + "`;\n\n    fetchNetlifyGraph({\n      query: subscriptionOperationDoc,\n      operationName: \"" + fn.operationName + "\",\n      variables: fullVariables,\n      options: options,\n      fetchStrategy: \"" + (fn.executionStrategy === "PERSISTED" &&
        (((_a = fn.cacheStrategy) === null || _a === void 0 ? void 0 : _a.timeToLiveSeconds) || 0) > 0
        ? "GET"
        : "POST") + "\",\n  })\n}\n\nconst " + subscriptionParserName(fn) + " = (event, options) => {\n  if (!verifyRequestSignature({ event: event }, options)) {\n    console.warn(\"Unable to verify signature for " + filename + "\")\n    return null\n  }\n\n  return JSON.parse(event.body || '{}')\n}";
};
exports.generateSubscriptionFunction = generateSubscriptionFunction;
var makeFunctionName = function (kind, operationName) {
    if (kind === "query") {
        return "fetch" + capitalizeFirstLetter(operationName);
    }
    if (kind === "mutation") {
        return "execute" + capitalizeFirstLetter(operationName) + " ";
    }
    return capitalizeFirstLetter(operationName).trim();
};
var fragmentToParsedFragmentDefinition = function (GraphQL, currentFragments, fullSchema, extractedFragment) {
    var basicFn = {
        id: extractedFragment.id,
        operationString: extractedFragment.operationString,
        description: extractedFragment.description || "",
    };
    var body = basicFn.operationString;
    var safeBody = replaceAll(body, "${", "\\${");
    var parsed = (0, graphql_1.parse)(body, { noLocation: true });
    var operations = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });
    var fragmentDefinitions = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });
    var fragments = fragmentDefinitions.reduce(function (acc, def) {
        var _a;
        return (__assign(__assign({}, acc), (_a = {}, _a[def.name.value] = def, _a)));
    }, {});
    if (!operations) {
        internalConsole_1.internalConsole.error("Fragment definition is required in " + basicFn.id);
        return { fragmentDefinitions: fragments };
    }
    var operation = fragmentDefinitions[0];
    if (operation.kind !== graphql_1.Kind.FRAGMENT_DEFINITION) {
        internalConsole_1.internalConsole.error("Definition is not an fragment in " + basicFn.id);
        return { fragmentDefinitions: fragments };
    }
    var returnSignature = (0, graphqlHelpers_1.typeScriptSignatureForFragment)(GraphQL, fullSchema, operation, __assign(__assign({}, currentFragments), fragments));
    var variableNames = (operation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(GraphQL, variableNames, fullSchema, 
    // @ts-ignore TODO: FIX THIS!
    operation);
    var fragmentName = operation.name && operation.name.value;
    if (!fragmentName) {
        internalConsole_1.internalConsole.error("Operation name is required in " + basicFn.operationString + "\n\tfound: " + JSON.stringify(operation.name));
        return { fragmentDefinitions: fragments };
    }
    var operationWithoutNetlifyDirective = __assign(__assign({}, operation), { directives: (operation.directives || []).filter(function (directive) { return directive.name.value !== exports.NETLIFY_DIRECTIVE_NAME; }) });
    var typeCondition = operation.typeCondition.name.value;
    var fn = __assign(__assign({}, basicFn), { safeBody: safeBody, kind: "fragment", returnSignature: returnSignature, fragmentName: fragmentName, typeCondition: typeCondition, parsedOperation: operation, operationStringWithoutNetlifyDirective: (0, graphql_1.print)(operationWithoutNetlifyDirective) });
    return { fragmentDefinitions: fragments, fragment: fn };
};
exports.fragmentToParsedFragmentDefinition = fragmentToParsedFragmentDefinition;
var queryToFunctionDefinition = function (GraphQL, fullSchema, parsedDoc, persistedQuery, enabledFragments) {
    var basicFn = {
        id: persistedQuery.id,
        operationString: persistedQuery.operationString,
        description: persistedQuery.description || "",
    };
    var body = basicFn.operationString;
    var safeBody = replaceAll(body, "${", "\\${");
    var parsed = (0, graphql_1.parse)(body, { noLocation: true });
    var operations = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });
    var fragmentDefinitions = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });
    var fragments = Object.values(enabledFragments).reduce(function (acc, def) {
        var _a;
        return (__assign(__assign({}, acc), (_a = {}, _a[def.fragmentName] = def.parsedOperation, _a)));
    }, {});
    if (!operations) {
        internalConsole_1.internalConsole.error("Operation definition is required in " + basicFn.id);
        return;
    }
    var operation = operations[0];
    if (operation.kind !== graphql_1.Kind.OPERATION_DEFINITION) {
        internalConsole_1.internalConsole.error("Definition is not an operation in " + basicFn.id);
        return;
    }
    var returnSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperation)(GraphQL, fullSchema, operation, fragments);
    var variableNames = (operation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(GraphQL, variableNames, fullSchema, operation);
    var operationName = operation.name && operation.name.value;
    if (!operationName) {
        internalConsole_1.internalConsole.error("Operation name is required in " + basicFn.operationString + "\n\tfound: " + JSON.stringify(operation.name));
        return;
    }
    var operationWithoutNetlifyDirective = __assign(__assign({}, operation), { directives: (operation.directives || []).filter(function (directive) { return directive.name.value !== exports.NETLIFY_DIRECTIVE_NAME; }) });
    var persistableOperationFacts = (0, graphqlHelpers_1.extractPersistableOperation)(GraphQL, parsedDoc, operation) || { persistableOperationString: (0, graphql_1.print)(operation) };
    var persistableOperationString = persistableOperationFacts.persistableOperationString;
    var cacheControl = (0, exports.pluckNetlifyCacheControlDirective)(operation);
    var netlifyDirective = (0, exports.pluckNetlifyDirective)(operation);
    var fn = __assign(__assign({}, basicFn), { fnName: makeFunctionName(operation.operation, operationName), safeBody: safeBody, kind: operation.operation, variableSignature: variableSignature, cacheStrategy: cacheControl.cacheStrategy, fallbackOnError: cacheControl.fallbackOnError, persistableOperationString: persistableOperationString, returnSignature: returnSignature, operationName: operationName, parsedOperation: operation, operationStringWithoutNetlifyDirective: (0, graphql_1.print)(operationWithoutNetlifyDirective), variableNames: variableNames, executionStrategy: (netlifyDirective === null || netlifyDirective === void 0 ? void 0 : netlifyDirective.executionStrategy) || "DYNAMIC" });
    return fn;
};
exports.queryToFunctionDefinition = queryToFunctionDefinition;
var generateRuntime = function (_a) {
    var GraphQL = _a.GraphQL, fragments = _a.fragments, generate = _a.generate, netlifyGraphConfig = _a.netlifyGraphConfig, operationsDoc = _a.operationsDoc, operations = _a.operations, schema = _a.schema, schemaId = _a.schemaId;
    return __awaiter(void 0, void 0, void 0, function () {
        var allFragmentNodes, fragmentResults, fragmentDefinitions, parsedDoc, odl, functionDefinitions, runtime;
        return __generator(this, function (_b) {
            allFragmentNodes = Object.fromEntries(Object.entries(fragments).map(function (_a) {
                var key = _a[0], value = _a[1];
                return [
                    value.fragmentName,
                    value.parsedOperation,
                ];
            }));
            fragmentResults = Object.entries(fragments).reduce(function (_a, _b) {
                var _c;
                var fragmentDefinitions = _a.fragmentDefinitions;
                var fragmentName = _b[0], fragment = _b[1];
                var parsed = (0, exports.fragmentToParsedFragmentDefinition)(GraphQL, allFragmentNodes, schema, fragment);
                return {
                    fragmentDefinitions: __assign(__assign({}, fragmentDefinitions), (_c = {}, _c[fragmentName] = parsed.fragment, _c)),
                };
            }, { fragmentDefinitions: {} });
            fragmentDefinitions = fragmentResults.fragmentDefinitions;
            parsedDoc = (0, graphql_1.parse)(operationsDoc, { noLocation: true });
            odl = (0, genericExporter_1.computeOperationDataList)({
                GraphQL: GraphQL,
                parsedDoc: parsedDoc,
                query: operationsDoc,
                variables: {},
                fragmentDefinitions: Object.values(allFragmentNodes),
            });
            functionDefinitions = Object.values(operations)
                .map(function (query) {
                return (0, exports.queryToFunctionDefinition)(GraphQL, schema, parsedDoc, query, fragmentDefinitions);
            })
                .filter(Boolean)
                .sort(function (a, b) {
                return a.id.localeCompare(b.id);
            });
            runtime = generate({
                GraphQL: GraphQL,
                netlifyGraphConfig: netlifyGraphConfig,
                schema: schema,
                functionDefinitions: functionDefinitions,
                fragments: Object.values(fragmentDefinitions),
                operationDataList: odl.operationDataList,
                schemaId: schemaId,
                options: {},
            });
            return [2 /*return*/, runtime];
        });
    });
};
exports.generateRuntime = generateRuntime;
var pluckDirectiveArgEnumValue = function (directive, argName) {
    var _a;
    var targetArg = (_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find(function (arg) { return arg.name.value === argName; });
    if (!(targetArg && targetArg.value)) {
        return null;
    }
    if (targetArg.value.kind === graphql_1.Kind.ENUM) {
        return targetArg.value.value;
    }
    return null;
};
var pluckDirectiveArgStringValue = function (directive, argName) {
    var _a;
    var targetArg = (_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find(function (arg) { return arg.name.value === argName; });
    if (!(targetArg && targetArg.value)) {
        return null;
    }
    if (targetArg.value.kind === graphql_1.Kind.STRING) {
        return targetArg.value.value;
    }
    return null;
};
var pluckDirectiveArgBooleanValue = function (directive, argName) {
    var _a;
    var targetArg = (_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find(function (arg) { return arg.name.value === argName; });
    if (!(targetArg && targetArg.value)) {
        return null;
    }
    if (targetArg.value.kind === graphql_1.Kind.BOOLEAN) {
        return targetArg.value.value;
    }
    return null;
};
var pluckDirectiveArgObjectValue = function (directive, argName) {
    var _a;
    var targetArg = (_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find(function (arg) { return arg.name.value === argName; });
    if (!(targetArg && targetArg.value)) {
        return null;
    }
    if (targetArg.value.kind === graphql_1.Kind.OBJECT) {
        return targetArg.value;
    }
    return null;
};
var pluckNetlifyDirective = function (definitionNode) {
    var _a;
    var directive = (_a = definitionNode.directives) === null || _a === void 0 ? void 0 : _a.find(function (localDirective) { return localDirective.name.value === exports.NETLIFY_DIRECTIVE_NAME; });
    if (!directive) {
        return null;
    }
    var docString = pluckDirectiveArgStringValue(directive, "doc") || "";
    var id = pluckDirectiveArgStringValue(directive, "id");
    var executionStrategy = pluckDirectiveArgEnumValue(directive, "executionStrategy");
    if (id === null) {
        id = (0, uuid_1.v4)();
    }
    if (executionStrategy === null ||
        !["DYNAMIC", "PERSISTED"].includes(executionStrategy)) {
        executionStrategy = "DYNAMIC";
    }
    return {
        id: id,
        description: docString,
        executionStrategy: executionStrategy,
    };
};
exports.pluckNetlifyDirective = pluckNetlifyDirective;
var pluckNetlifyCacheControlDirective = function (definitionNode) {
    var _a;
    var defaultStrategy = {
        cacheStrategy: undefined,
        fallbackOnError: false,
    };
    var directive = (_a = definitionNode.directives) === null || _a === void 0 ? void 0 : _a.find(function (localDirective) {
        return localDirective.name.value === exports.NETLIFY_CACHE_CONTROL_DIRECTIVE_NAME;
    });
    if (!directive) {
        return defaultStrategy;
    }
    var rawFallbackOnError = pluckDirectiveArgBooleanValue(directive, "fallbackOnError");
    var fallbackOnError = typeof rawFallbackOnError === "boolean" ? rawFallbackOnError : false;
    var rawCacheStrategy = pluckDirectiveArgObjectValue(directive, "cacheStrategy") || undefined;
    var cacheStrategy = undefined;
    if (rawCacheStrategy) {
        var enabledArg = pluckDirectiveArgBooleanValue(directive, "enabled");
        var enabled = enabledArg || false;
        var field = rawCacheStrategy.fields.find(function (field) { return field.name.value === "timeToLiveSeconds"; });
        if ((field === null || field === void 0 ? void 0 : field.value.kind) === graphql_1.Kind.FLOAT || (field === null || field === void 0 ? void 0 : field.value.kind) === graphql_1.Kind.INT) {
            cacheStrategy = {
                enabled: enabled,
                timeToLiveSeconds: parseFloat(field.value.value),
            };
        }
    }
    var finalStrategy = {
        cacheStrategy: cacheStrategy,
        fallbackOnError: fallbackOnError,
    };
    return finalStrategy;
};
exports.pluckNetlifyCacheControlDirective = pluckNetlifyCacheControlDirective;
/**
 * Extracts basic functions from a parsed GraphQL operations document
 * @param {DocumentNode} parsedDoc The parsed GraphQL document with @netlify directives
 * @returns {functions: Record<string, ExtractedFunction>, fragments: Record<string, ExtractedFragment>}
 */
var extractFunctionsFromOperationDoc = function (GraphQL, parsedDoc) {
    var functions = {};
    var fragments = {};
    parsedDoc.definitions.forEach(function (next) {
        var _a;
        if (next.kind !== graphql_1.Kind.OPERATION_DEFINITION &&
            next.kind !== graphql_1.Kind.FRAGMENT_DEFINITION) {
            return null;
        }
        var key = ((_a = next.name) === null || _a === void 0 ? void 0 : _a.value) || "unknown";
        var netlifyDirective = (0, exports.pluckNetlifyDirective)(next);
        if (netlifyDirective === null) {
            return null;
        }
        var nextWithoutNetlifyDirective = __assign(__assign({}, next), { directives: (next.directives || []).filter(function (directive) {
                return ![
                    exports.NETLIFY_DIRECTIVE_NAME,
                    exports.NETLIFY_CACHE_CONTROL_DIRECTIVE_NAME,
                ].includes(directive.name.value);
            }) });
        if (next.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
            var typeCondition = next.typeCondition.name.value;
            var operation = {
                id: netlifyDirective.id,
                fragmentName: key,
                typeCondition: typeCondition,
                description: netlifyDirective.description,
                parsedOperation: next,
                kind: "fragment",
                operationString: (0, graphql_1.print)(next),
                operationStringWithoutNetlifyDirective: (0, graphql_1.print)(nextWithoutNetlifyDirective),
            };
            fragments[netlifyDirective.id] = operation;
        }
        else if (next.kind === graphql_1.Kind.OPERATION_DEFINITION) {
            var isQuery = next.operation === "query";
            var fnName = makeFunctionName(next.operation, key);
            var cacheControl = isQuery
                ? (0, exports.pluckNetlifyCacheControlDirective)(next)
                : { cacheStrategy: undefined, fallbackOnError: false };
            var persistableOperationString = ((0, graphqlHelpers_1.extractPersistableOperation)(GraphQL, parsedDoc, next) || { persistableOperationString: null }).persistableOperationString;
            var operation = {
                id: netlifyDirective.id,
                operationName: key,
                description: netlifyDirective.description,
                cacheStrategy: cacheControl.cacheStrategy,
                fallbackOnError: cacheControl.fallbackOnError,
                persistableOperationString: persistableOperationString || (0, graphql_1.print)(next),
                parsedOperation: next,
                kind: next.operation,
                operationString: (0, graphql_1.print)(next),
                operationStringWithoutNetlifyDirective: (0, graphql_1.print)(nextWithoutNetlifyDirective),
                executionStrategy: netlifyDirective.executionStrategy,
            };
            functions[netlifyDirective.id] = operation;
        }
    });
    return { functions: functions, fragments: fragments };
};
exports.extractFunctionsFromOperationDoc = extractFunctionsFromOperationDoc;
var frameworkGeneratorMap = {
    "Next.js": nextjsExporter_1.nextjsFunctionSnippet.generateHandler,
    Remix: remixExporter_1.remixFunctionSnippet.generateHandler,
    default: genericExporter_1.netlifyFunctionSnippet.generateHandler,
};
var defaultGenerator = genericExporter_1.netlifyFunctionSnippet.generateHandler;
/**
 * Given a schema, GraphQL operations doc, a target definitionId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
var generateHandlerSource = function (_a) {
    var GraphQL = _a.GraphQL, handlerOptions = _a.handlerOptions, netlifyGraphConfig = _a.netlifyGraphConfig, definitionId = _a.operationId, operationsDoc = _a.operationsDoc, schema = _a.schema;
    return __awaiter(void 0, void 0, void 0, function () {
        var parsedDoc, operations, functions, fn, odl, generate, exportedFiles;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    parsedDoc = (0, graphql_1.parse)(operationsDoc, { noLocation: true });
                    operations = (0, exports.extractFunctionsFromOperationDoc)(GraphQL, parsedDoc);
                    functions = operations.functions;
                    fn = functions[definitionId] || operations.fragments[definitionId];
                    if (!fn) {
                        internalConsole_1.internalConsole.warn("Operation " + definitionId + " not found in graphql, found: " + Object.keys(functions).join(", ") + "}");
                        return [2 /*return*/];
                    }
                    odl = (0, genericExporter_1.computeOperationDataList)({
                        GraphQL: GraphQL,
                        parsedDoc: parsedDoc,
                        query: fn.operationString,
                        variables: {},
                        fragmentDefinitions: parsedDoc.definitions.filter(function (d) { return d.kind === graphql_1.Kind.FRAGMENT_DEFINITION; }),
                    });
                    generate = frameworkGeneratorMap[netlifyGraphConfig.framework] || defaultGenerator;
                    return [4 /*yield*/, generate({
                            GraphQL: GraphQL,
                            netlifyGraphConfig: netlifyGraphConfig,
                            operationDataList: odl.operationDataList,
                            schema: schema,
                            options: handlerOptions,
                        })];
                case 1:
                    exportedFiles = (_b.sent()).exportedFiles;
                    return [2 /*return*/, { exportedFiles: exportedFiles, operation: fn.parsedOperation }];
            }
        });
    });
};
exports.generateHandlerSource = generateHandlerSource;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
var generateCustomHandlerSource = function (_a) {
    var GraphQL = _a.GraphQL, handlerOptions = _a.handlerOptions, netlifyGraphConfig = _a.netlifyGraphConfig, operationId = _a.operationId, operationsDoc = _a.operationsDoc, schema = _a.schema, generate = _a.generate;
    return __awaiter(void 0, void 0, void 0, function () {
        var parsedDoc, operations, fn, odl, exportedFiles;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    parsedDoc = (0, graphql_1.parse)(operationsDoc, { noLocation: true });
                    operations = (0, exports.extractFunctionsFromOperationDoc)(GraphQL, parsedDoc);
                    fn = operations.functions[operationId] || operations.fragments[operationId];
                    if (!fn) {
                        internalConsole_1.internalConsole.warn("Operation " + operationId + " not found in graphql among:\n [" + Object.keys(operations).join(",\n ") + "]");
                        return [2 /*return*/];
                    }
                    odl = (0, genericExporter_1.computeOperationDataList)({
                        GraphQL: GraphQL,
                        parsedDoc: parsedDoc,
                        query: fn.operationString,
                        variables: {},
                        fragmentDefinitions: parsedDoc.definitions.filter(function (d) { return d.kind === graphql_1.Kind.FRAGMENT_DEFINITION; }),
                    });
                    return [4 /*yield*/, generate({
                            GraphQL: GraphQL,
                            netlifyGraphConfig: netlifyGraphConfig,
                            operationDataList: odl.operationDataList,
                            schema: schema,
                            options: handlerOptions,
                        })];
                case 1:
                    exportedFiles = (_b.sent()).exportedFiles;
                    return [2 /*return*/, { exportedFiles: exportedFiles, operation: fn.parsedOperation }];
            }
        });
    });
};
exports.generateCustomHandlerSource = generateCustomHandlerSource;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a preview of the full handler's output
 */
var generatePreview = function (_a) {
    var GraphQL = _a.GraphQL, handlerOptions = _a.handlerOptions, netlifyGraphConfig = _a.netlifyGraphConfig, operationId = _a.operationId, operationsDoc = _a.operationsDoc, schema = _a.schema, generate = _a.generate;
    if (!generate) {
        return;
    }
    var parsedDoc = (0, graphql_1.parse)(operationsDoc, { noLocation: true });
    var operations = (0, exports.extractFunctionsFromOperationDoc)(GraphQL, parsedDoc);
    var fn = operations.functions[operationId];
    if (!fn) {
        internalConsole_1.internalConsole.warn("Operation " + operationId + " not found in graphql among:\n [" + Object.keys(operations).join(",\n ") + "]");
        return;
    }
    var odl = (0, genericExporter_1.computeOperationDataList)({
        GraphQL: GraphQL,
        parsedDoc: parsedDoc,
        query: fn.operationString,
        variables: {},
        fragmentDefinitions: parsedDoc.definitions.filter(function (d) { return d.kind === graphql_1.Kind.FRAGMENT_DEFINITION; }),
    });
    var exportedFile = generate({
        GraphQL: GraphQL,
        netlifyGraphConfig: netlifyGraphConfig,
        operationDataList: odl.operationDataList,
        schema: schema,
        options: handlerOptions,
    });
    if (!exportedFile) {
        return;
    }
    return { exportedFile: exportedFile, operation: fn.parsedOperation };
};
exports.generatePreview = generatePreview;
//# sourceMappingURL=netlifyGraph.js.map