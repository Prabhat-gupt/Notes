"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.fetchFetchNetlifySessionSchemaQuery = exports.fetchListNetlifyEnabledServicesQuery = exports.fetchSharedDocumentQuery = exports.executeCreateSharedDocumentMutation = exports.fetchListSharedDocumentsQuery = exports.executeMarkCLISessionInactive = exports.executeMarkCLISessionActiveHeartbeat = exports.executeCreateNewSchemaMutation = exports.executeUpsertAppForSiteMutation = exports.fetchAppSchemaQuery = exports.executeAckCLISessionEventMutation = exports.fetchCLISessionQuery = exports.executeCreateCLISessionEventMutation = exports.executeUpdateCLISessionMetadataMutation = exports.executeCreateCLISessionMutation = exports.fetchPersistedQueryQuery = exports.fetchListPersistedQueries = exports.executeCreatePersistedQueryMutation = exports.executeCreateApiTokenMutation = exports.executeCreateGraphQLSchemaMutation = exports.verifyRequestSignature = void 0;
/* eslint-disable */
// @ts-nocheck
// GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!
var fetch = require("node-fetch");
var internalConsole = require("./internalConsole").internalConsole;
var netlifyGraphHost = process.env.NETLIFY_GRAPH_HOST || "graph.netlify.com";
// Basic LRU cache implementation
var makeLRUCache = function (max) {
    return { max: max, cache: new Map() };
};
var oldestCacheKey = function (lru) {
    return lru.keys().next().value;
};
// Depend on Map keeping track of insertion order
var getFromCache = function (lru, key) {
    var item = lru.cache.get(key);
    if (item) {
        // Delete key and re-insert so key is now at the end,
        // and now the last to be gc'd.
        lru.cache.delete(key);
        lru.cache.set(key, item);
    }
    return item;
};
var setInCache = function (lru, key, value) {
    if (lru.cache.has(key)) {
        lru.cache.delete(key);
    }
    if (lru.cache.size == lru.max) {
        var cacheKey = oldestCacheKey(lru);
        if (cacheKey) {
            lru.cache.delete(cacheKey);
        }
    }
    lru.cache.set(key, value);
};
// Cache the results of the Netlify Graph API for conditional requests
var cache = makeLRUCache(100);
var calculateCacheKey = function (payload) {
    return JSON.stringify(payload);
};
var httpFetch = function (siteId, options) { return __awaiter(void 0, void 0, void 0, function () {
    var reqBody, userHeaders, headers, timeoutMs, reqOptions, url, resp;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                reqBody = options.body || null;
                userHeaders = options.headers || {};
                headers = __assign(__assign({}, userHeaders), { "Content-Type": "application/json", "Content-Length": reqBody.length });
                timeoutMs = 30000;
                reqOptions = {
                    method: "POST",
                    headers: headers,
                    timeout: timeoutMs,
                    body: reqBody,
                };
                url = "https://" + netlifyGraphHost + "/graphql?app_id=" + siteId;
                return [4 /*yield*/, fetch(url, reqOptions)];
            case 1:
                resp = _a.sent();
                return [2 /*return*/, resp];
        }
    });
}); };
var fetchNetlifyGraph = function fetchNetlifyGraph(input) {
    var query = input.query;
    var docId = input.doc_id;
    var operationName = input.operationName;
    var variables = input.variables;
    var options = input.options || {};
    var accessToken = options.accessToken;
    var siteId = options.siteId || process.env.SITE_ID;
    var payload = {
        query: query,
        doc_id: docId,
        variables: variables,
        operationName: operationName,
    };
    var cachedOrLiveValue = new Promise(function (resolve) {
        var cacheKey = calculateCacheKey(payload);
        // Check the cache for a previous result
        var cachedResultPair = getFromCache(cache, cacheKey);
        var conditionalHeaders = {
            "If-None-Match": "",
        };
        var cachedResultValue;
        if (cachedResultPair) {
            var etag = cachedResultPair[0], previousResult = cachedResultPair[1];
            conditionalHeaders = {
                "If-None-Match": etag,
            };
            cachedResultValue = previousResult;
        }
        var response = httpFetch(siteId, {
            method: "POST",
            headers: __assign(__assign({}, conditionalHeaders), { Authorization: accessToken ? "Bearer " + accessToken : "" }),
            body: JSON.stringify(payload),
        });
        response.then(function (result) {
            // Check response headers for a 304 Not Modified
            if (result.status === 304) {
                // Drain the body so the connection will be closed
                result.text();
                // Return the cached result
                resolve(cachedResultValue);
            }
            else if (result.status === 200) {
                // Update the cache with the new etag and result
                var etag_1 = result.headers.get("etag");
                var resultJson = result.json();
                resultJson.then(function (json) {
                    if (etag_1) {
                        // Make a note of the new etag for the given payload
                        setInCache(cache, cacheKey, [etag_1, json]);
                    }
                    resolve(json);
                });
            }
            else {
                return result.json().then(function (json) {
                    resolve(json);
                });
            }
        });
    });
    return cachedOrLiveValue;
};
var verifyRequestSignature = function (request, options) {
    var event = request.event;
    var secret = options.webhookSecret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET;
    var signature = event.headers["x-netlify-graph-signature"];
    var body = event.body;
    if (!secret) {
        console.error("NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request");
        return false;
    }
    return verifySignature({ secret: secret, signature: signature, body: body || "" });
};
exports.verifyRequestSignature = verifyRequestSignature;
var executeCreateGraphQLSchemaMutation = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation CreateGraphQLSchemaMutation($input: OneGraphCreateGraphQLSchemaInput!) {\n  oneGraph {\n    createGraphQLSchema(input: $input) {\n      graphQLSchema {\n        id\n        externalGraphQLSchemas {\n          nodes {\n            id\n            endpoint\n            serviceInfo {\n              graphQLField\n            }\n            createdAt\n            updatedAt\n          }\n        }\n        parentGraphQLSchemaId\n        salesforceSchema {\n          id\n          createdAt\n          updatedAt\n        }\n        services {\n          graphQLField\n        }\n        updatedAt\n        createdAt\n        appId\n      }\n    }\n  }\n}",
        operationName: "CreateGraphQLSchemaMutation",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeCreateGraphQLSchemaMutation = executeCreateGraphQLSchemaMutation;
var executeCreateApiTokenMutation = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation CreateApiTokenMutation($input: OneGraphCreateApiTokenTokenInput!) {\n  oneGraph {\n    createApiToken(input: $input) {\n      accessToken {\n        token\n        userAuths {\n          serviceInfo {\n            graphQLField\n          }\n          foreignUserId\n          scopes\n        }\n        appId\n        expireDate\n        name\n        netlifyId\n        anchor\n      }\n    }\n  }\n}",
        operationName: "CreateApiTokenMutation",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeCreateApiTokenMutation = executeCreateApiTokenMutation;
var executeCreatePersistedQueryMutation = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation CreatePersistedQueryMutation($cacheStrategy: OneGraphPersistedQueryCacheStrategyArg, $allowedOperationNames: [String!]!, $fallbackOnError: Boolean!, $freeVariables: [String!]!, $query: String!, $tags: [String!]!, $description: String, $appId: String!) {\n  oneGraph {\n    createPersistedQuery(\n      input: {query: $query, appId: $appId, cacheStrategy: $cacheStrategy, allowedOperationNames: $allowedOperationNames, fallbackOnError: $fallbackOnError, freeVariables: $freeVariables, tags: $tags, description: $description}\n    ) {\n      persistedQuery {\n        id\n        allowedOperationNames\n        description\n        fixedVariables\n        freeVariables\n        query\n        tags\n      }\n    }\n  }\n}",
        operationName: "CreatePersistedQueryMutation",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeCreatePersistedQueryMutation = executeCreatePersistedQueryMutation;
var fetchListPersistedQueries = function (variables, options) {
    return fetchNetlifyGraph({
        query: "query ListPersistedQueries($appId: String!, $first: Int!, $after: String, $tags: [String!]!) {\n  oneGraph {\n    app(id: $appId) {\n      id\n      persistedQueries(first: $first, after: $after, tags: $tags) {\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        nodes {\n          id\n          query\n          fixedVariables\n          freeVariables\n          allowedOperationNames\n          tags\n          description\n        }\n      }\n    }\n  }\n}",
        operationName: "ListPersistedQueries",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.fetchListPersistedQueries = fetchListPersistedQueries;
var fetchPersistedQueryQuery = function (variables, options) {
    return fetchNetlifyGraph({
        query: "query PersistedQueryQuery($appId: String!, $id: String!) {\n  oneGraph {\n    persistedQuery(appId: $appId, id: $id) {\n      id\n      query\n      allowedOperationNames\n      description\n      freeVariables\n      fixedVariables\n      tags\n    }\n  }\n}",
        operationName: "PersistedQueryQuery",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.fetchPersistedQueryQuery = fetchPersistedQueryQuery;
var executeCreateCLISessionMutation = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation CreateCLISessionMutation($appId: String!, $name: String!, $metadata: JSON) {\n  oneGraph {\n    createNetlifyCliSession(\n      input: {appId: $appId, name: $name, metadata: $metadata}\n    ) {\n      session {\n        id\n        appId\n        netlifyUserId\n        name\n        cliHeartbeatIntervalMs\n      }\n    }\n  }\n}",
        operationName: "CreateCLISessionMutation",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeCreateCLISessionMutation = executeCreateCLISessionMutation;
var executeUpdateCLISessionMetadataMutation = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation UpdateCLISessionMetadataMutation($sessionId: String!, $metadata: JSON!) {\n  oneGraph {\n    updateNetlifyCliSession(input: {id: $sessionId, metadata: $metadata}) {\n      session {\n        id\n        name\n        metadata\n        cliHeartbeatIntervalMs\n      }\n    }\n  }\n}",
        operationName: "UpdateCLISessionMetadataMutation",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeUpdateCLISessionMetadataMutation = executeUpdateCLISessionMetadataMutation;
var executeCreateCLISessionEventMutation = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation CreateCLISessionEventMutation($sessionId: String!, $payload: JSON!) {\n  oneGraph {\n    createNetlifyCliTestEvent(\n      input: {data: {payload: $payload}, sessionId: $sessionId}\n    ) {\n      event {\n        id\n        createdAt\n        sessionId\n      }\n    }\n  }\n}",
        operationName: "CreateCLISessionEventMutation",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeCreateCLISessionEventMutation = executeCreateCLISessionEventMutation;
var fetchCLISessionQuery = function (variables, options) {
    return fetchNetlifyGraph({
        query: "query CLISessionQuery($sessionId: String!, $first: Int!)\n    @netlify(\n      id: \"\"\"\n      12b5bdea-9bab-4124-a731-5e697b155009\n      \"\"\"\n      doc: \"\"\"\n      Fetch a single CLI session by its id\n      \"\"\"\n    ) {\n      oneGraph {\n        __typename\n        netlifyCliSession(id: $sessionId) {\n          appId\n          createdAt\n          id\n          cliHeartbeatIntervalMs\n          events(first: $first) {\n            __typename\n            createdAt\n            id\n            sessionId\n            ... on OneGraphNetlifyCliSessionLogEvent {\n              id\n              message\n              sessionId\n              createdAt\n            }\n            ... on OneGraphNetlifyCliSessionTestEvent {\n              id\n              createdAt\n              payload\n              sessionId\n            }\n          }\n          lastEventAt\n          metadata\n          name\n          netlifyUserId\n          status\n          graphQLSchema {\n            createdAt\n            id\n            externalGraphQLSchemas {\n              nodes {\n                endpoint\n                id\n                service\n                serviceInfo {\n                  friendlyServiceName\n                  graphQLField\n                }\n              }\n            }\n          }\n        }\n      }\n    }",
        operationName: "CLISessionQuery",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.fetchCLISessionQuery = fetchCLISessionQuery;
var executeAckCLISessionEventMutation = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation AckCLISessionEventMutation($sessionId: String!, $eventIds: [String!]!) {\n  oneGraph {\n    ackNetlifyCliEvents(input: {eventIds: $eventIds, sessionId: $sessionId}) {\n      events {\n        id\n      }\n    }\n  }\n}",
        operationName: "AckCLISessionEventMutation",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeAckCLISessionEventMutation = executeAckCLISessionEventMutation;
var fetchAppSchemaQuery = function (variables, options) {
    return fetchNetlifyGraph({
        query: "query AppSchemaQuery($appId: String!) @netlify(id: \"\"\"12b5bdea-9bab-4124-a731-5e697b155011\"\"\", doc: \"\"\"Fetch the schema metadata for a site (enabled services, id, etc.)\"\"\") {\n      oneGraph {\n        app(id: $appId) {\n          graphQLSchema {\n            ...OneGraphGraphQLSchema\n          }\n        }\n      }\n    }\n\n\nfragment OneGraphGraphQLSchema on OneGraphGraphQLSchema @netlify(id: \"\"\"0000bdea-9bab-4124-a731-5e697b150000\"\"\", doc: \"\"\"Metadata for a GraphQL schema (enabled services, id, etc.)\"\"\") {\n  appId\n  createdAt\n  id\n  services {\n    friendlyServiceName\n    logoUrl\n    graphQLField\n    slug\n    supportsCustomRedirectUri\n    supportsCustomServiceAuth\n    supportsOauthLogin\n  }\n  updatedAt\n}",
        operationName: "AppSchemaQuery",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.fetchAppSchemaQuery = fetchAppSchemaQuery;
var executeUpsertAppForSiteMutation = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation UpsertAppForSiteMutation($siteId: String!) {\n  oneGraph {\n    upsertAppForNetlifySite(input: {netlifySiteId: $siteId}) {\n      org {\n        id\n        name\n      }\n      app {\n        id\n        name\n        corsOrigins\n        customCorsOrigins {\n          friendlyServiceName\n          displayName\n          encodedValue\n        }\n      }\n    }\n  }\n}",
        operationName: "UpsertAppForSiteMutation",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeUpsertAppForSiteMutation = executeUpsertAppForSiteMutation;
var executeCreateNewSchemaMutation = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation CreateNewSchemaMutation($input: OneGraphCreateGraphQLSchemaInput!) {\n  oneGraph {\n    createGraphQLSchema(input: $input) {\n      app {\n        graphQLSchema {\n          id\n        }\n      }\n      graphqlSchema {\n        id\n        services {\n          friendlyServiceName\n          logoUrl\n          graphQLField\n          slug\n          supportsCustomRedirectUri\n          supportsCustomServiceAuth\n          supportsOauthLogin\n        }\n      }\n    }\n  }\n}",
        operationName: "CreateNewSchemaMutation",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeCreateNewSchemaMutation = executeCreateNewSchemaMutation;
var executeMarkCLISessionActiveHeartbeat = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation MarkCLISessionActiveHeartbeat($id: String!) {\n  oneGraph {\n    updateNetlifyCliSession(input: {status: ACTIVE, id: $id}) {\n      session {\n        id\n        status\n        createdAt\n        updatedAt\n        cliHeartbeatIntervalMs\n      }\n    }\n  }\n}",
        operationName: "MarkCLISessionActiveHeartbeat",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeMarkCLISessionActiveHeartbeat = executeMarkCLISessionActiveHeartbeat;
var executeMarkCLISessionInactive = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation MarkCLISessionInactive($id: String!) {\n  oneGraph {\n    updateNetlifyCliSession(input: {status: INACTIVE, id: $id}) {\n      session {\n        id\n        status\n        createdAt\n        updatedAt\n        cliHeartbeatIntervalMs\n      }\n    }\n  }\n}",
        operationName: "MarkCLISessionInactive",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeMarkCLISessionInactive = executeMarkCLISessionInactive;
var fetchListSharedDocumentsQuery = function (variables, options) {
    return fetchNetlifyGraph({
        query: "query ListSharedDocumentsQuery($first: Int = 10, $status: OneGraphSharedDocumentModerationStatusEnum, $services: [OneGraphServiceEnumArg!]!, $style: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {\n  oneGraph {\n    sharedDocuments(\n      first: $first\n      filter: {moderationStatus: {equalTo: $status}, services: {in: $services}}\n    ) {\n      nodes {\n        description\n        body\n        createdAt\n        id\n        moderationStatus\n        operationName\n        siteId\n        updatedAt\n        services {\n          friendlyServiceName\n          logoUrl(style: $style)\n          graphQLField\n          slug\n        }\n      }\n    }\n  }\n}",
        operationName: "ListSharedDocumentsQuery",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.fetchListSharedDocumentsQuery = fetchListSharedDocumentsQuery;
var executeCreateSharedDocumentMutation = function (variables, options) {
    return fetchNetlifyGraph({
        query: "mutation CreateSharedDocumentMutation($input: OneGraphCreateSharedDocumentInput!) {\n  oneGraph {\n    createSharedDocument(input: $input) {\n      sharedDocument {\n        id\n        moderationStatus\n        operationName\n        services {\n          friendlyServiceName\n        }\n        description\n      }\n    }\n  }\n}",
        operationName: "CreateSharedDocumentMutation",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.executeCreateSharedDocumentMutation = executeCreateSharedDocumentMutation;
var fetchSharedDocumentQuery = function (variables, options) {
    return fetchNetlifyGraph({
        query: "query SharedDocumentQuery($id: String!, $logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE) {\n  oneGraph {\n    sharedDocument(id: $id) {\n      body\n      createdAt\n      description\n      id\n      moderationStatus\n      operationName\n      updatedAt\n      services {\n        logoUrl(style: $logoStyle)\n        friendlyServiceName\n        graphQLField\n        slug\n      }\n    }\n  }\n}",
        operationName: "SharedDocumentQuery",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.fetchSharedDocumentQuery = fetchSharedDocumentQuery;
var fetchListNetlifyEnabledServicesQuery = function (variables, options) {
    return fetchNetlifyGraph({
        query: "query ListNetlifyEnabledServicesQuery($logoStyle: OneGraphAppLogoStyleEnum = ROUNDED_RECTANGLE, $betaServices: [OneGraphServiceEnumArg!] = []) {\n  oneGraph {\n    services(\n      filter: {or: [{service: {in: $betaServices}}, {supportsNetlifyGraph: true}, {supportsNetlifyApiAuthentication: true}]}\n    ) {\n      friendlyServiceName\n      logoUrl(style: $logoStyle)\n      graphQLField\n      slug\n      supportsCustomRedirectUri\n      supportsCustomServiceAuth\n      supportsOauthLogin\n      netlifyGraphEnabled\n      netlifyApiAuthenticationEnabled\n    }\n  }\n}",
        operationName: "ListNetlifyEnabledServicesQuery",
        variables: variables,
        options: options,
        fetchStrategy: "GET",
    });
};
exports.fetchListNetlifyEnabledServicesQuery = fetchListNetlifyEnabledServicesQuery;
var fetchFetchNetlifySessionSchemaQuery = function (variables, options) {
    return fetchNetlifyGraph({
        query: "query FetchNetlifySessionSchemaQuery($sessionId: String!) {\n  oneGraph {\n    netlifyCliSession(id: $sessionId) {\n      graphQLSchema {\n        appId\n        createdAt\n        id\n        services {\n          friendlyServiceName\n          logoUrl\n          graphQLField\n          slug\n          supportsCustomRedirectUri\n          supportsCustomServiceAuth\n          supportsOauthLogin\n        }\n        updatedAt\n      }\n    }\n  }\n}",
        operationName: "FetchNetlifySessionSchemaQuery",
        variables: variables,
        options: options,
        fetchStrategy: "POST",
    });
};
exports.fetchFetchNetlifySessionSchemaQuery = fetchFetchNetlifySessionSchemaQuery;
/**
 * The generated NetlifyGraph library with your operations
 */
var functions = {
    /**
     * Create a GraphQL Schema by specifying its inputs (services, external GraphQL schemas, etc.)
     */
    executeCreateGraphQLSchemaMutation: exports.executeCreateGraphQLSchemaMutation,
    /**
     * Create a token belonging to a specific siteId to persist operations and create GraphQL schemas later
     */
    executeCreateApiTokenMutation: exports.executeCreateApiTokenMutation,
    /**
     * Create a persisted operations doc to be later retrieved, usually from a GUI
     */
    executeCreatePersistedQueryMutation: exports.executeCreatePersistedQueryMutation,
    /**
     * Fetch a paginated list of persisted queries belonging to an app
     */
    fetchListPersistedQueries: exports.fetchListPersistedQueries,
    /**
     * Fetch a persisted doc belonging to appId by its id
     */
    fetchPersistedQueryQuery: exports.fetchPersistedQueryQuery,
    /**
     * Register a new CLI session with OneGraph
     */
    executeCreateCLISessionMutation: exports.executeCreateCLISessionMutation,
    /**
     * Update the CLI session with new metadata (e.g. the latest docId) by its id
     */
    executeUpdateCLISessionMetadataMutation: exports.executeUpdateCLISessionMetadataMutation,
    /**
     * Create a new event for a CLI session to consume
     */
    executeCreateCLISessionEventMutation: exports.executeCreateCLISessionEventMutation,
    /**
     * Fetch a single CLI session by its id
     */
    fetchCLISessionQuery: exports.fetchCLISessionQuery,
    /**
     * Acknowledge CLI events that have been processed and delete them from the upstream queue
     */
    executeAckCLISessionEventMutation: exports.executeAckCLISessionEventMutation,
    /**
     * Fetch the schema metadata for a site (enabled services, id, etc.)
     */
    fetchAppSchemaQuery: exports.fetchAppSchemaQuery,
    /**
     * If a site does not exists upstream in OneGraph for the given site, create it
     */
    executeUpsertAppForSiteMutation: exports.executeUpsertAppForSiteMutation,
    /**
     * Create a new schema in OneGraph for the given site with the specified metadata (enabled services, etc.)
     */
    executeCreateNewSchemaMutation: exports.executeCreateNewSchemaMutation,
    /**
     * Mark a CLI session as active and update the session's heartbeat
     */
    executeMarkCLISessionActiveHeartbeat: exports.executeMarkCLISessionActiveHeartbeat,
    /**
     * Mark a CLI session as inactive
     */
    executeMarkCLISessionInactive: exports.executeMarkCLISessionInactive,
    /**
     * List shared documents given a set of filters
     */
    fetchListSharedDocumentsQuery: exports.fetchListSharedDocumentsQuery,
    /**
     * Create a document with a shared operation for others to import and use
     */
    executeCreateSharedDocumentMutation: exports.executeCreateSharedDocumentMutation,
    /**
     * Find a shared document given its id
     */
    fetchSharedDocumentQuery: exports.fetchSharedDocumentQuery,
    /**
     * Retrieve a list of _all_ supported services from OneGraph
     */
    fetchListNetlifyEnabledServicesQuery: exports.fetchListNetlifyEnabledServicesQuery,
    /**
     * Create a document with a shared operation for others to import and use
     */
    fetchFetchNetlifySessionSchemaQuery: exports.fetchFetchNetlifySessionSchemaQuery,
};
exports.default = functions;
var handler = function () {
    // return a 401 json response
    return {
        statusCode: 401,
        body: JSON.stringify({
            message: "Unauthorized",
        }),
    };
};
exports.handler = handler;
//# sourceMappingURL=generatedOneGraphClient.js.map